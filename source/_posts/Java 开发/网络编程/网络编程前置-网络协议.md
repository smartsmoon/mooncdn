---
title: 网络协议初识
date: 2022-01-25 00:00:00
type:
comments:
tags: 
  - TCP
  - HTTP
  - 网络协议
categories: 
  - Java 开发
description: 
keywords: Docker
cover: https://w.wallhaven.cc/full/v9/wallhaven-v97wl5.png
top_img: https://w.wallhaven.cc/full/v9/wallhaven-v97wl5.png
---

# 计算机网络

​		计算机网络：利用通信线路将地理上分散的、具有独立功能的`计算机系统和通信设备`按不同的形式连接起来，以功能完善的`网络软件及协议`实现资源共享和信息传递的系统。（协议：不同操作系统计算机之间的`共识`）

​		按地理位置可以划分为：局域网、城域网、广域网。那么此时地理位置不同、操作系统不同的的主机，怎么`互联(通信)`起来呢？ ====> 开放性的标准化计算机网络体系结构：`OSI 模型 和 TCP/IP 模型`。

1、OSI 模型（开发系统互联参考模型）由 ISO 组织提出，七层模型。 =====> 为`不同计算机联通提供的标准`，但是偏于学术。

​		模型层级：物理层（网卡）、数据链路层（网卡驱动）`|`  网络层 `|` 传输层 `|` 会话层、表示层、应用层。（`因`为绿茶`婊` `会` `传` 情所以 `网`  `恋` `无`了）

2、`TCP/IP` 模型由 IEEE 工程师协会提出，四层模型。（实际标准）

​		模型层级：数据链路层、网络层、传输层、应用层。

![jYzXCR.png](https://s1.ax1x.com/2022/07/05/jYzXCR.png)

## TCP/IP 协议族

​		TCP/IP 协议族是 Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的 TCP 协议组成，协议采用了4层的层级结构（TCP/IP 计算机网络模型）。然而在很多情况下，它是利用 IP 进行通信时所必须用到的协议群的统称。

![image-20220705101154067](https://s1.ax1x.com/2022/07/05/jtStMV.png)

​		需要注意的是：TCP/IP 协议并不是只有这两个协议，而是一个协议族，在各层都有对应的协议实现功能。

​		在网络传输过程中，有几个新的概念：

1、`包`：全能性术语，可以说是传输过程中附加的安全校验等，也可以说是整个在网络通信过程中流通的单位。

​		传输层附加 TCP 包首部，网络层附加 IP 包首部，数据链路层附加以太网包首部

2、`帧`：表示数据链路层中包的单位。

3、`片`：表示 IP 中数据的信息。

4、`段`：表示 TCP 数据流中的信息。

​	消息就是指应用协议中数据的单位（广义抽象），而包在每一层就被称为：帧、片、段。（具体抽象）

整个消息的发送过程如下：

![image-20220705103613863](https://s1.ax1x.com/2022/07/05/jt9gED.png)

TCP 是面向连接的、可靠的流协议（三次握手），而 UDP  是面向无连接的通讯协议。IP 则是在源地址和目的地址之间传送的数据包，其作用可以理解为 `寻址`。

报文：将要发送的消息打包成 “一个整体”，这个整体就可以称作报文，后续进行直接发送或是拆解发送。

> 问题：如果想越过这几层直接操作数据链路层，则就需要使用原始套接字，但是 Java 并没有提供对应的方法（C++ 提供）。抓包就是基于数据链路层操作。

![image-20220705104126874](https://s1.ax1x.com/2022/07/05/jtFOe0.png)

> ICMP：控制报文协议。
>
> IGMP：internet组管理协议。
>
> ARP ：地址解析协议：把 mac 地址转化成 ip 地址。
>
> RARP：反向地址转化协议。

## 网络通讯地址

1、MAC 地址：

​		windows 系统下通过 `ipconfig -all` 命令可以到本机的 MAC 地址 和 IPV4 地址。MAC 地址是指媒体访问控制地址，也叫做：局域网地址、以太网地址、物理地址（主要`负责局域网内的通信地址`），可以理解为`硬件地址`，因此这个地址是硬件绑定的地址，是网卡绑定的地址，一般不会变更。

​		MAC 地址格式：48位，共 6 个字节。例如 80-FA-5B-76-1B-5F

2、IP 地址：

​		IP 地址一般是区分`互联网上主机`的唯一的逻辑地址，用来和物理地址进行区分，非常灵活，一般使用 IPV4 地址。（IPV6 出现是因为 IPV4 不够用）

和 MAC 地址的区别：

​	1）IP 地址是网络上区分不同主机的，可以灵活修改，而 MAC 地址网卡出厂基本就不会变更。

​	2）二者寻址协议不同：IP 地址在网络层通信（负责`不同网络子网`之间的通信），而 MAC 地址在数据链路层（主要负责`局域网内`设备的通信）

> 案例说明：A 发送消息到 B，是怎么知道 B 的呢，知道自己寻找的 B 在哪？
>
> ​	1）假设 ABCD 都在同一局域网内部（内网），A 发送数据包时会携带 B 的MAC 地址，同时 A 是广播发送，BCD 服务器收到消息后会进行 MAC 地址的比对，不相同则丢弃数据包，相同才会接收数据包。
>
> ​	2）如果不是在同一局域网内部，A知道B的 IP 地址，A 将消息（`携带 IP 和子网掩码`）广播发送给网关，网关通过计算发现访问的不是 A 所在子网的地址（不是内网），因此将数据包向外进行传送，通过无数的路由器，到达最终的 B。

3、端口 Port 地址：

​		端口号 Port 是用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为 `程序地址`，区分不同的服务。

​	需要注意的是 0~1023 端口一般是已经被注册使用的端口，默认分配的端口在 49152~65535 之间，但是会不停变化。服务端指定端口号，但客户端不需要指定也行（服务端端口等待连接需要固定，但客户端并不需要）

4、如何识别一个通信呢？ ===> 通过源 IP 地址、目的 IP 地址、协议号（TCP/UDP 等）、源端口号、目的端口号五个元素确定一个通信。

> 如果使用 TCP 通信，前三个部分是 IP 首部，后两个部分是 TCP 首部，数据则是在首部的后面。

# TCP 协议概述

​		TCP 协议：传输控制协议，主要用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。其主要包括几个特点：

1）`面向连接`。只有经过三次握手之后，才会开始发送数据。

2）`可靠性`。可靠性主要体现在`超时重传 和 应答确认机制`，以此保证数据拆分传输但不会丢包。

3）`RTT 和 RTO`：超时时间，可靠性的一种保证。

​		超时时间怎么确定呢？（动态调整）操作系统会采样数据包的传送时间，这个时间就称为 RTT（Round Trip Time：消息来回时长），这个时间会动态变化，同时根据 RTT 动态确定最终的时间 RTO（重传超时时长）。

4）`数据排序`。数据拆分传输后，如何保证收到消息的正确性呢？

​		例如将数据拆分成100份，这100份按顺序发送出去，但 `IP 协议并不能保证接收的数据是按顺序的`，因此 TCP 拆分的包提供数据排序的功能（发送的每个数据包会带上数据包的序号），收到后进行排序（收到的先后顺序并不能确定，部分包可能延时），同时如果收到的某个包`损坏也会进行重传`。

5）`流量控制`。两台服务器通信，无法保证两台服务器处理数据的性能一样，那么一次传输中接收不到的包就会被丢弃，安排下次重传，影响效率。

​		提出`滑动窗口`的概念进行流量控制，在发送数据包之前进行通信，确定滑动窗口大小，每次发送都按协商出的滑动窗口大小进行发送（通信过程会滑动窗口大小发生动态变化：需要协商改变）

6）`全双工`：TCP 是一个两端均支持发送和接收的协议。

## 三次握手

​		TCP 的三次握手就说明了其 `面向连接` 的特性，是由操作系统内核负责：表示建立 TCP 连接时，需要客户端和服务端总共`发送3个包以确认连接`的建立。

具体三次握手过程如图：

![](https://s1.ax1x.com/2022/07/05/jtaYqI.png)

​		那么为什么需要三次握手呢？ ====> 这是根据 Arpanet 的设计思路（节点分散就需要建立网络连接通道：`虚拟通道`）

​		TCP 是面对连接的，所以需要`双方都确认连接`的建立。保证数据可靠传输，双方需要维护序列号，而三次握手就是实现可靠传输的最小次数。同时正常发送的每个包时，都会有应答，如果没应答，就会启动超时重传机制，因此导致 TCP 比 UDP 慢。

​		但是 TCP 的三次握手仍然会有问题：`SYN 洪泛攻击`（DDOS 攻击），也称为洪水攻击。

洪泛攻击：通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。

具体实现原理：攻击者客户端利用伪造的 IP 地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端（伪造的那个客户端 IP），服务端在等待客户端的第三次握手(永远都不会有的)，`服务端在等待这种半开的连接过程中消耗了资源`，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。

如何解决呢？

1）无效连接监控释放：指定时间释放连接资源，但同时也会释放正常连接。

2）延缓 TCB 分配方法：服务端 TCB 连接控制资源，设置成三次连接后再开辟TCB资源，会影响效率。

3）`防火墙的配置`。

## 四次挥手

​		TCP 断开连接前需要进行四次挥手（分手），一共四个报文，当使用 Wireshark 进行抓包时可能看不到四个报文（因为实际网络通讯过程中，第一个报文可能混合在数据发送报文中，同时2和3步骤可能中间没有数据发送会合并成一个报文，因此最终看到的可能是2个或3个报文）

注意：断开连接的发起人可能是客户端也可能是服务端，下图描述以`客户端发起断开连接` 为示例。

![](https://pic1.imgdb.cn/item/6336bbb816f2c2beb18c69ed.png)

问题一：为什么 TCP 连接需要三次，但是分手需要四次数据包？

​		因为 TCP 是双全工(即客户端和服务器端可以相互发送和接收请求)，所以`需要双方都确认关闭连接`，双方都需要确认和应答，读和写的通道都需要关闭。

问题二：为什么发起断开请求的一方需要 TIME-WAIT 状态，而不是直接断开呢？

​		`TIME_WAIT 状态` 是主动关闭的一端出现的状态，此状态会持续一段时间原因在于：

​	1）`可靠的终止连接`：如果服务器没有收到 ACK 确认报文，那么服务器会认为客户端没有接收到 FIN 报文，会重发 FIN 报文，客户端就需要等待一段时间，确认服务端不会再发送 FIN 报文，并且还需要发送确认报文等待服务端收到确认，因此需要 TIME-WAIT状态 ===> 客户端无法确认服务端收到 ACK 确认报文。

​	2）`保证迟来的 TCP 报文可以丢弃`。如果直接进入 关闭状态，此端口可能会被下一个服务直接使用，如果之前的确认包迟来了，那么这个（无用的）数据包就会被新的服务直接接收，如果存在 TIME-WAIT 状态，那么就能够保证这个包自然的消失（具体消失的处理并不需要了解）。

而这个数据包持续时间叫 `MSL`，含义就是数据报在 Intenet 中存活的最长时间，按 RFC1122 规定定义为 2min，实际 linux 底层中改成了 30s。

注意：如果服务端主动发起关闭，则如果大量服务处于 TIME-WAIT 状态，则会导致服务器`内存占用率`居高不下，因此一般设置为更短：5~10s。

问题三：为什么不将服务端发给客户端的那两个请求和应答合并成一个数据包发送呢？

​		不合并是因为中间可能还有业务数据没法送完，分开发送可以保证中间数据完整发送，如果没有数据发送，抓包时就会发现就是一个数据包（进行了合并）。

## 抓包示例

​		以 windows 系统上的 Wireshark 抓包分析连接远程 MySQL数据库时的 TCP 三次握手和四次挥手过程。

1、Wireshark 的基本使用：

​	1）安装时需要选中 `Install Nocap` 选项。

​	2）Wireshark 使用时提供两种过滤器，对所有的包进行过滤：`捕获过滤器` 和 `显示过滤器`。捕获过滤器使用 BPF 语法表达式（具体用法可直接百度条件），比如 dst.192.168.0.10 & tcp port 80 表示捕获目的主机 192.168.0.10 通信协议为 TCP ，端口为 80 （源和目的）的报文。至于显示过滤器也可以直接百度表达式，例如 tcp and !mysql 表示 。

2、配置捕获过滤器：host 8.142.92.222，配置显示过滤器：tcp and !mysql，再使用本地的 Navicate 连接远程的 MySQL 数据库，观察抓包情况：

​	1）分析抓包：Ethernet Ⅱ 是数据链路层信息，Internet Protocol 是 IP 传输层协议相关信息，Transmission Control Protocol 是传输层 TCP 协议的相关信息。

​	2）分析 Flags 选项即为标志位变化。第一个 SYN 数据报：源端口 5304，目的端口 3306，SYN = 1，seq = 320006790，滑动窗口大小 64240。第二个 SYN，ACK 数据报：源端口 3306，目的端口 5304， seq = 4035172433，ACK =1，SYN = 1，ack = 320006791（`J+1`），第三个 ACK 数据报：源端口 5304，目的端口 3306，seq = 320006791，ACK = 1，SYN = 0。

​	3）分析四次挥手过程，发现实际只有三个数据报 ：1）FIN 和 ACK ；  2)FIN 和 ACK；  3）ACK。

# HTTP 协议概述

​		HTTP 协议：超文本传输协议，是基于 TCP/IP 协议族从万维网服务器传输超文本到本地浏览器的传送协议。

​		HTTP 协议实现是`客户端---服务器 架构`（即C/S架构模型），浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 Web 服务器（Tomcat）发送所有请求。

HTTP 协议的特性：

​	1）无连接：连接后处理一个请求，请求响应完毕后断开连接，节省传输时间。

​	2）媒体独立特性：任何类型的数据都可以通过 HTTP 发送，而媒体类型是通过 Web 服务器告知浏览器的，通过 `Content-Type` 来设置。

​	3）无状态性：HTTP 协议对事务处理没有记忆，如果某个请求处理需要前面的信息，则它必须重传前面的信息，会导致连接传送的数据量增大，但是当服务器不需要之前的信息时此种方式的应答就比较快。

​	HTTP 使用统一资源标识符 `URI` 来传输数据和建立连接。（URL 是统一资源定位符，用于定位且标识某个资源）[注意：此处不做其请求头的具体描述]

经典问题：一次完整 HTTP 请求的过程？

​	1）首先进行 DNS 域名解析。

> `域名`就代表某个计算机主机（IP地址），域名解析寻找顺序：本地浏览器缓存 ----> 本地操作系统缓存 ----> DNS 远程服务器。

​	2）三次握手建立 TCP 连接：TCP 是可靠连接，必须三次握手。

​	3）客户端发起 HTTP 请求：通过 URI/URL 请求服务器上的某个位置的资源（此处以请求 Html 页面为例）。

> 请求报文包括：请求行、请求头、空行、请求数据。

> 请求方法总共八种，主要用到 `POST、GET、PUT、DELETE` 四种。（对应 Restful 风格的操作）

​	4）服务器响应 HTTP 请求：包含响应状态码、响应数据等。

> 响应报文主要包括：状态行、响应报头、空行、相应正文。

> 常见响应状态码为：2XX（成功）、3XX（重定向）、4XX（客户端错误：服务器无法处理请求）、5XX（服务器错误：服务器处理请求出错）

​	5）客户端解析 Html 代码，并请求 Html 代码中的资源文件（Js、Css、Image等）。

​	6）客户端渲染展示内容，此次 TCP 连接关闭。

注意：如果设置了 `keey-alive` 属性，可以使 HTTP 连接变成持续连接，直接就可以进行 3-6 过程，持续解析页面渲染展示。
