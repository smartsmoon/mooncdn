---
title: 谷粒商城-用户认证处理
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringCloud
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## 用户认证环境搭建

​	新建 Boot 2.1.8 版本项目 `shop-auth` ，用于构建用户认证相关的服务 `auth-server` ，包括社交登录服务、OAuth2.0、单点登录等服务逻辑，初始时导入 Lombok、Thymeleaf、DevTools、Web 模块、OpenFeign 远程调用依赖。

0、引入通用依赖 shop-common，同时设置 cloud 等版本问题，并排除掉 mybatis ：

```xml
<spring-cloud.version>Greenwich.SR3</spring-cloud.version>
<dependency>
    <groupId>com.example</groupId>
    <artifactId>shop-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <exclusions>
        <exclusion>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

1、将 auth 服务添加到注册中心，并设置对应的命名空间 auth ，设置配置中心，并在启动类上添加注册中心注解。

`auth.yml` 配置文件：

```yml
spring:
  application:
    name: shop-auth-server
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8849
server:
  port: 20000
```

`bootstrap.yml` 配置文件：

```yml
spring:
  application:
    name: shop-auth
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8849
        namespace: auth-id
        group: dev
        ext-config:
            - data-id: auth.yml
              group: dev
              refresh: true
```

2、修改 host 文件，配置 `auth.moonshop.com`，并且将静态资源放入 nginx 静态目录，并配置转发网关，同时修改前端页面中的链接到本系统的指定位置。

```yml
- id: shop_auth_route
  # 路由到检索服务首页
  uri: lb://shop-auth
  predicates: 
  	- Host=auth.moonshop.com
```

3、配置 login 和 register 的路径跳转，为了避免单一的跳转路径的请求的浪费书写，因此采用 SpringMVC 提供的 ViewController 组件实现将请求和页面映射。

```java
@Configuration
public class ShopWebConfig implements WebMvcConfigurer {

    /**
     * 官方解释：This is useful in cases where there is no need for custom controller logic
     * @param registry viewController 的注册中心
     */
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/login.html").setViewName("login");
        registry.addViewController("/register.html").setViewName("register");
    }
}
```

## 基础登录实现

### 注册手机验证码

1、在阿里云的云市场购买免费短信验证码套餐，在 `third-service` 服务中创建单独的 component 包，创建 SmsComponent 组件用于发送短信服务。

```java
@Data
@Component
//ConfigurationProperties 注解想要提示需要引入依赖：spring-boot-configuration-processor
@ConfigurationProperties("spring.sms")
@Slf4j
public class SmsComponent {

    private String host;
    private String path;
    private String smsSignId;
    private String smsTemplateNo;
    private String appcode;

    public void sendSmsCode(String phone, String SmsCode) {
        String host = this.host;
        String path = this.path;
        String method = "POST";
        String appcode = this.appcode;
        Map<String, String> headers = new HashMap<String, String>();
        headers.put("Authorization", "APPCODE " + appcode);
        //根据API的要求，定义相对应的Content-Type
        headers.put("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
        //需要给X-Ca-Nonce的值生成随机字符串，每次请求不能相同
        headers.put("X-Ca-Nonce", UUID.randomUUID().toString());
        Map<String, String> querys = new HashMap<String, String>();
        Map<String, String> bodys = new HashMap<String, String>();
        bodys.put("filterVirtual", "true");
        bodys.put("phoneNumber", phone);
        bodys.put("smsSignId", smsSignId);  //签名编号，目前只能使用 0000
        bodys.put("smsTemplateNo", smsTemplateNo);    //短信模板编号
        bodys.put("verifyCode", SmsCode);

        try {
            HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);
            System.out.println(response.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

> ​	`HttpUtils` 是按照官方 API 文档，从 `https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/ demo/util/HttpUtils.java` 中下载。

配置文件：

```yml
spring:
  sms:
    host: https://miitangs09.market.alicloudapi.com
    path: /v1/tools/sms/code/sender
    smsSignId: "0000"
    smsTemplateNo: "0009"
    appcode: b5b436b3972842aba7ab33afa4a225cf
```

2、编写 controller 向其他服务提供短信服务：

```java
/**
 * SmsController
 * 提供给其他服务进行调用发送验证码
 * @param phone 电话号码
 * @param code  验证码
 * @return  验证码
 */
@GetMapping("/sendCode")
@ResponseBody
public R sendSmsCode(@RequestParam("phone") String phone, @RequestParam("code") String code){
    smsComponent.sendSmsCode(phone, code);
    return R.ok();
}
```

3、前端页面发送请求向后台拿取验证码：

```html
<div class="register-box">
    <label class="other_label">
        <span>中国 0086</span>
        <input class="phone" id="phoneNum" maxlength="20" type="text" placeholder="建议使用常用手机">
    </label>
    <div class="tips"></div>
</div>
<script>
    //定时验证码点击实现
    $(function () {
        $("#sendCode").click(function () {
            console.log("已发送验证码......");
            if ($(this).hasClass("disabled")) {
                // 说明正在倒计时，那么就不再次发送请求
            } else {
                // 像后端发送请求获取验证码
                $.get("/sms/sendCode?phone=" + $("#phoneNum").val(), function (data) {
                    if (data.code !== 0) {
                        alert(data.msg);
                    }
                });
                timeoutChangeStyle();
            }
        })
    })

    var num = 60;
    function timeoutChangeStyle() {
        $("#sendCode").attr("class", "disabled");
        if (num === 0) {
            $("#sendCode").text("发送验证码");
            num = 60;
        } else {
            var str = num + "s 后再次发送";
            $("#sendCode").text(str);
            setTimeout("timeoutChangeStyle()", 1000);
        }
        num--;
    }
</script>
```

4、auth 服务中提供前端请求的接收 handler，并远程调用 thirdservice 服务：

```java
/**
 * LoginController
 * 接收前端请求，远程调用 thirdservice 服务获取六位验证码
 * @param phone 电话号码
 * @return 请求状态
 * 注意：我选用的那个发送验证码的服务API 只能发送数字，否则 610 状态码
 * 注意：存储在redis中的是 code+time，但实际发送的是单纯6位数 code
 */
@GetMapping("/sendCode")
@ResponseBody
public R sendCode(@RequestParam("phone") String phone){
    //TODO:1.接口防刷设置（后端就是校验时间，前端还未完成!）
    //2.验证码 60 s 校验问题
    String redisCode = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_KEY_PREFIX + phone);
    if (!StringUtils.isEmpty(redisCode)) {
        long redisCodeCurrentTime = Long.parseLong(redisCode.split("_")[1]);
        if (System.currentTimeMillis() - redisCodeCurrentTime < 60 * 1000) {
            //60s内不能再发
            return R.error(BizCode.SMS_CODE_EXCEPTION.getCode(), BizCode.SMS_CODE_EXCEPTION.getMessage());
        }
    }
    String code = (Math.round((Math.random()+1) * 100000) + "") + "_" + System.currentTimeMillis();
    //2.验证码的再次校验(5min) ===> 使用 Redis 存储key = phone,value = code
    redisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_KEY_PREFIX + phone, code, 5, TimeUnit.MINUTES);
    System.out.println("发送验证码 code = " + code);
    thirdServiceFeignService.sendSmsCode(phone, code.substring(0,6));
    return R.ok();
}
```

常量类修改：

```java
public class AuthServerConstant {
    public static final String SMS_CODE_KEY_PREFIX = "sms:code:";
}

//BizCode 添加新的异常类型
SMS_CODE_EXCEPTION(10002, "验证码获取频率太高，请稍后再试!")
```

auth 服务中的本地存根：

```java
@FeignClient("shop-thirdservice")
public interface ThirdServiceFeignService {

    @GetMapping("/sms/sendCode")
    R sendSmsCode(@RequestParam("phone") String phone, @RequestParam("code") String code);
}
```

thirdservice 服务中的实际逻辑实现：

```java
/**
 * SmsController
 * 提供给其他服务进行调用发送验证码
 * @param phone 电话号码
 * @param code  验证码
 * @return  验证码
 */
@GetMapping("/sendCode")
public R sendSmsCode(@RequestParam("phone") String phone, @RequestParam("code") String code){
    smsComponent.sendSmsCode(phone, code);
    return R.ok();
}
```

### 注册业务实现

1、封装一个前端提交注册数据的实体类：

```java
@Data
public class UserRegisterVo {
    @NotEmpty(message = "用户名必须提交")
    @Length(min = 6, max = 18, message = "用户名必须是6~18位字符")
    private String username;

    @NotEmpty(message = "密码必须填写")
    @Length(min = 6, max = 18, message = "用户名必须是6~18位字符")
    private String password;

    @Pattern(regexp = "^[1]([3-9])[0-9]{9}$", message = "手机号格式不正确")
    private String phone;

    @NotEmpty(message = "验证码必须填写")
    private String code;
}
```

2、封装网络传递封装的实体类到 member 服务：

```java
@Data
public class MemberRegisterVo {
    private String username;
    private String password;
    private String phone;
}
```

3、member 服务实现注册的逻辑：

1）控制器接收请求：

```java
@PostMapping("/register")
public R register(@RequestBody MemberRegisterVo memberRegisterUser) {
    try {
        //register 内部可能会抛出两个自己定义的检查型异常，从而返回不同的结果让远程感知到
        memberService.register(memberRegisterUser);
    } catch (UsernameExistException usernameExistException) {
        return R.error(BizCode.USERNAME_EXIST_EXCEPTION.getCode(), BizCode.USERNAME_EXIST_EXCEPTION.getMessage());
    } catch (PhoneExistException phoneExistException) {
        return R.error(BizCode.PHONE_EXIST_EXCEPTION.getCode(), BizCode.PHONE_EXIST_EXCEPTION.getMessage());
    }
    return R.ok();
}
```

2）service 具体实现服务逻辑：

```java
/**
 * MemberServiceImpl：实现注册功能
 * @param memberRegisterUser 前端传递的用户参数
 */
@Override
public void register(MemberRegisterVo memberRegisterUser) {
    MemberEntity memberEntity = new MemberEntity();
    //1.设置默认等级
    memberEntity.setLevelId(memberLevelDao.getDefaultLevel().getId());
    //2.检验前端传递的用户名和手机号的唯一性:为了让 controller 感知到，则应该使用异常机制
    this.checkPhoneUnique(memberRegisterUser.getPhone());
    memberEntity.setMobile(memberRegisterUser.getPhone());
    this.checkUsernameUnique(memberRegisterUser.getUsername());
    memberEntity.setUsername(memberRegisterUser.getUsername());
    //3.密码进行加密存储(不可逆存储加密算法:MD5盐值加密-信息摘要算法) ===> BCryptPasswordEncoder 编码(自带盐值)
    BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
    memberEntity.setPassword(passwordEncoder.encode(memberRegisterUser.getPassword()));

    this.baseMapper.insert(memberEntity);
}
```

3）用户名和手机号校验的相关处理异常类逻辑：

```java
@Override
public void checkPhoneUnique(String phone) throws PhoneExistException{
    Integer mobileCount = this.baseMapper.selectCount(new QueryWrapper<MemberEntity>().eq("mobile", phone));
    if (mobileCount > 0)
        throw new PhoneExistException();
}

@Override
public void checkUsernameUnique(String username) throws UsernameExistException{
    Integer usernameCount = this.baseMapper.selectCount(new QueryWrapper<MemberEntity>().eq("username", username));
    if (usernameCount > 0)
        throw new UsernameExistException();
}
```

```java
public class PhoneExistException extends RuntimeException{
    public PhoneExistException() {
        super("手机号已存在!");
    }
}

public class UsernameExistException extends RuntimeException{
    public UsernameExistException() {
        super("用户名已存在!");
    }
}
```

4）针对上面的 service 里面的方法，需要实现：

```xml
<select id="getDefaultLevel" resultType="com.example.member.pojo.MemberLevelEntity">
    select * from ums_member_level where default_status=1
</select>
```

4、auth 服务中进行远程调用 member 服务接收前端的请求：

auth 本地存根：

```java
@FeignClient("shop-member")
public interface MemberFeignService {

    @PostMapping("/member/member/register")
    R register(@RequestBody UserRegisterVo memberRegisterUser);
}
```

注册接受请求逻辑：

```java
public class AuthServerConstant {

    public static final String SMS_CODE_KEY_PREFIX = "sms:code:";
}
```

```java
/**
  * LoginController：注册功能实现
  * @param registerUser  注册用户信息
  * @param result   校验结果封装
  * @param session HttpSession
  * 注：重定向利用 Session 来携带页面数据，TODO：需要解决分布式下 session 共享问题
  */
@PostMapping("/register")
public String register(@Valid UserRegisterVo registerUser, BindingResult result, HttpSession session) {
    log.info("有用户注册，提交的用户信息：" + registerUser);
    Map<String, String> errors = new HashMap<>();
    if (result.hasErrors()) {
        errors = result.getFieldErrors().stream().collect(Collectors.toMap(
            FieldError::getField,
            FieldError::getDefaultMessage
        ));
        log.error("注册发生错误,错误信息：" + errors);
        session.setAttribute("errors", errors);
        //校验出错，跳转到注册页重写填写
        return "redirect:http://auth.moonshop.com/register.html";
    }
    //真正注册的逻辑实现：需要调用远程 member 服务进行注册
    //1.从 redis 中取出验证码进行校验
    String pageCode = registerUser.getCode();
    String redisCode = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_KEY_PREFIX + registerUser.getPhone()).substring(0, 6);
    System.out.println("pageCode = " + pageCode);
    System.out.println("redisCode = " + redisCode);
    if (StringUtils.isNotEmpty(redisCode) && pageCode.equals(redisCode)) {
        // 验证码校验成功，可以调用远程服务注册校验重名情况并删除 redis 中的验证码
        R registerStatus = memberFeignService.register(registerUser);
        if (registerStatus.getCode() == 0) {
            //注册成功则删除 redis 中保存的验证码，避免重复使用
            redisTemplate.delete(AuthServerConstant.SMS_CODE_KEY_PREFIX + registerUser.getPhone());
            return "redirect:http://auth.moonshop.com/login.html";
        }else {
            errors.put("msg", registerStatus.getData("msg", new TypeReference<String>(){}));
            session.setAttribute("errors", errors);
            log.error("注册发生错误,错误信息：" + errors);
            return "redirect:http://auth.moonshop.com/register.html";
        }
    } else {
        // 验证码校验失败，转发到注册页，返回错误信息
        errors.put("code", "验证码校验错误");
        log.error("注册发生错误,错误信息：" + errors);
        return "redirect:http://auth.moonshop.com/register.html";
    }
}
```

注意：原始的返回结果集修改增加获取 msg 消息的方法。

```java
public R setData(Object data) {
    put("data", data);
    return this;
}

/**
 * Object->JSON->T
 */
public <T> T getData(TypeReference<T> typeReference) {
    Object data = get("data");
    String s = JSON.toJSONString(data);
    return JSON.parseObject(s, typeReference);
}

public <T> T getData(String name, TypeReference<T> typeReference) {
    Object data = get(name);
    String s = JSON.toJSONString(data);
    T t = JSON.parseObject(s, typeReference);
    return t;
}
```

### 登陆业务实现

1、封装前端传递的登录信息：

```java
//auth 服务的相关封装
@Data
public class UserLoginVo {
    private String loginAccount;
    private String password;
}

//member 服务的相关封装
@Data
public class MemberLoginVo {
    private String loginAccount;
    private String password;
}
```

2、前端表单添加 name 属性，提交请求，后端 auth 服务接收请求：

```java
@PostMapping("/login")
public String login(UserLoginVo userLoginUser, HttpSession session){
    //远程调用 member 服务进行登陆校验
    R loginStatus = memberFeignService.login(userLoginUser);
    if (loginStatus.getCode() == 0) {
        System.out.println("登陆成功");
        return "redirect:http://moonshop.com";
    } else {
        System.out.println("登陆失败");
        Map<String, String> errors = new HashMap<>();
        errors.put("msg", loginStatus.getData("msg", new TypeReference<String>(){}));
        session.setAttribute("errors", errors);
        return "redirect:http://auth.moonshop.com/login.html";
    }
}
```

远程 login 逻辑的本地存根：

```java
@PostMapping("/member/member/login")
R login(@RequestBody UserLoginVo userLoginVo);
```

3、远程调用的具体服务逻辑实现：

```java
@PostMapping("/login")
public R login(@RequestBody MemberLoginVo memberLoginUser){
    System.out.println("远程调用 member 服务......");
    MemberEntity member = memberService.login(memberLoginUser);
    System.out.println(member);
    //新增异常消息：ACCOUNT_PASSWORD_INVALID_EXCEPTION(15003, "账户或密码错误");
    if (member != null) {
        //TODO:登陆成功后的处理逻辑
        return R.ok();
    } else {
        return R.error(BizCode.ACCOUNT_PASSWORD_INVALID_EXCEPTION.getCode(), BizCode.ACCOUNT_PASSWORD_INVALID_EXCEPTION.getMessage());
    }
}
```

4、具体业务逻辑：密码校验查询数据库等实现。

```java
@Override
public MemberEntity login(MemberLoginVo memberLoginUser) {
    System.out.println(memberLoginUser);
    QueryWrapper<MemberEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("username", memberLoginUser.getLoginAccount());
    wrapper.or().eq("mobile", memberLoginUser.getLoginAccount());
    MemberEntity memberEntity = this.baseMapper.selectOne(wrapper);
    if (memberEntity == null) {
        return null;    //登陆失败
    } else {
        //由于密码是经过加密存入数据库的，而且相同密码会加密成多种密文，必须通过 BCryptPasswordEncoder 加密
        String loginUserPassword = memberEntity.getPassword();
        BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
        boolean matches = bCryptPasswordEncoder.matches(memberLoginUser.getPassword(), loginUserPassword);
        return matches ? memberEntity : null;
    }
}
```

## OAuth2.0 社交登录

​		由于 微博和微信 都需要备案，此处使用了`gitee` 作为登录的社交账号进行测试使用：用户在我们系统登录页面，不用点注册或者登录，而是点击 Gitee 图标跳转到 Gitee 的登录页，登陆后点击授权按钮，然后获得`授权码`，然后跳转回我们的系统，`用这个授权码获取 Token`，成功获取到 Token 后，利用 token 获取 Gitee 用户信息，然后，把这个 userinfo，注册或者登录我们自己的系统（如果这个社交账号之前没有登陆过，就自动注册并登录，根据 Gitee 返回的ID判断）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/803bf7f2dcad424caf74714cd2ad63e6.png)

由于需要后端单独调用 OpenAPI 发送请求，需要使用之前封装的 HttpUtils，导入到 common 模块，并导入依赖：

```xml
<!-- http-client -->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.2.1</version>
</dependency>
```

1、抽取出按照社交 openApi 生成的社交帐户信息：

```java
@Data
public class SocialUser {
    private String access_token;    //用户授权的唯一票据
    private long expires_in;        //令牌过期时间
    private String uid;             //附加登录信息 uid
    private String nickname;        //附加登录信息 nickname
    private String username;        //附加登录信息 username
}
```

2、member 实体类添加属性：

```java
private String socialUid;
private String accessToken;
private Long expiresIn;
```

3、auth 封装一个当前登录用户的实体类：

```java
@Data
@ToString
public class MemberRespVo implements Serializable {
	private Long id;
	private Long levelId;
	private String username;
	private String password;
	private String nickname;
	private String mobile;
	private String email;
	private String header;
	private Integer gender;
	private Date birth;
	private String city;
	private String job;
	private String sign;
	private Integer sourceType;
	private Integer integration;
	private Integer growth;
	private Integer status;
	private Date createTime;
	private String socialUid;
	private String accessToken;
	private Long expiresIn;
}
```

4、auth 服务内部的逻辑实现：接受请求，进行远程调用 member 服务。

```java
@GetMapping("/oauth2.0/gitee/success")
public String gitLogin(@RequestParam("code") String code) throws Exception {
    System.out.println("code = " + code);
    //1.查询参数封装信息:https://gitee.com/oauth/token
    Map<String, String> requestBody = new HashMap<>();
    requestBody.put("grant_type", "authorization_code");
    requestBody.put("code", code);
    requestBody.put("client_id", "508b4d6f85cc7a733039c283d05facd5282b95bcb1c7937bfdbefa4d07241f48");
    requestBody.put("redirect_uri", "http://auth.moonshop.com/oauth2.0/gitee/success");
    requestBody.put("client_secret", "bfc491ff24ee59a120b31f31db5d615e84d1a1cdb7f21160cde84592e2e94ea9");

    //2.根据获得的 code 发送请求来获取 access-token
    HttpResponse response = HttpUtils.doPost(
        "https://gitee.com",
        "/oauth/token",
        "post",
        new HashMap<>(),
        requestBody,
        new HashMap<>());

    //3.获取响应信息，其中包括了 access-token
    if (response.getStatusLine().getStatusCode() == 200) {
        //获取 token 请求成功，需要封装信息执行用户新增或修改操作(需要根据是否是第一次登录)
        //获取到了响应实体信息，并转化为通用社交登录对象
        String jsonString = EntityUtils.toString(response.getEntity());
        /* Gitee 请求结果的数据结构形式：
            {
                  "access_token":"896f854e5f916ee322e1e552e4477d28",
                  "token_type":"bearer",
                  "expires_in":86400,
                  "refresh_token":"7e3894b0cb693a248f373ca8696c8fbf67a1851fe5de1492d743c0c2117ec495",
                  "scope":"user_info",
                  "created_at":1667366220
            }
            */
        System.out.println(jsonString);
        SocialUser socialUser = JSON.parseObject(jsonString, SocialUser.class);
        //3.1 根据 access-token 获取用户信息 uid，实际上可以封装很多基本信息
        Map<String, String> userRequestBody = new HashMap<>();
        userRequestBody.put("access_token", socialUser.getAccess_token());
        HttpResponse userResponse = HttpUtils.doGet(
            "https://gitee.com",
            "/api/v5/user",
            "get",
            new HashMap<>(),
            userRequestBody);
        JSONObject jsonObject = JSON.parseObject(EntityUtils.toString(userResponse.getEntity()));
        String nickname = (String) jsonObject.get("login");
        String uid = String.valueOf(jsonObject.get("id"));
        String name = (String) jsonObject.get("name");
        socialUser.setUid(uid);
        socialUser.setUsername(name);
        socialUser.setNickname(nickname);
        //4.登陆成功过后的处理？需要远程调用 member 服务
        R auth2LoginStatus = memberFeignService.oAuth2Login(socialUser);
        if (auth2LoginStatus.getCode() == 0) {
            MemberRespVo currentAuthLoginUser = auth2LoginStatus.getData("data", new TypeReference<MemberRespVo>() {});
            System.out.println("登陆成功：" + currentAuthLoginUser.toString());
            return "redirect:http://moonshop.com";
        } else {
            return "redirect:http://auth.moonshop.com/login.html";
        }
    }else {
        //获取 token 失败，跳转到登录页面
        return "redirect:http://auth.moonshop.com/login.html";
    }
}
```

```java
@PostMapping("/member/member/oauth2/login")
R oAuth2Login(@RequestBody SocialUser socialUser);
```

5、member 针对远程调用进行具体的业务逻辑实现：

```java
@PostMapping("/oauth2/login")
public R oAuth2Login(@RequestBody SocialUser socialUser){
    MemberEntity member = memberService.login(socialUser);
    System.out.println(member);
    if (member != null) {
        //TODO:登陆成功后的处理逻辑
        return R.ok().setData(member);
    } else {
        return R.error(BizCode.ACCOUNT_PASSWORD_INVALID_EXCEPTION.getCode(), BizCode.ACCOUNT_PASSWORD_INVALID_EXCEPTION.getMessage());
    }
}
```

```java
/**
 * MemberServiceImpl：社交帐号的登录逻辑，包含登录和注册的逻辑
 * @param socialUser 社交登录信息
 */
@Override
public MemberEntity login(SocialUser socialUser) {
    //1.判断当前社交用户是否在系统中已经登陆过用户
    MemberEntity memberEntity = this.baseMapper.selectOne(new QueryWrapper<MemberEntity>().eq("social_uid", socialUser.getUid()));
    if (memberEntity != null) {
        //说明用户已经注册，需要更新令牌和过期时间
        MemberEntity updateMember = new MemberEntity();
        updateMember.setId(memberEntity.getId());
        updateMember.setNickname(socialUser.getNickname());
        updateMember.setUsername(socialUser.getUsername());
        updateMember.setAccessToken(socialUser.getAccess_token());
        updateMember.setExpiresIn(socialUser.getExpires_in());
        updateMember.setSocialUid(socialUser.getUid());
        this.baseMapper.updateById(updateMember);

        memberEntity.setNickname(socialUser.getNickname());
        memberEntity.setAccessToken(socialUser.getAccess_token());
        memberEntity.setExpiresIn(socialUser.getExpires_in());
        return memberEntity;
    } else {
        //说明用户没有注册，需要进行注册操作，新增一个用户信息
        MemberEntity registerUser = new MemberEntity();
        registerUser.setNickname(socialUser.getNickname());
        registerUser.setUsername(socialUser.getUsername());
        registerUser.setAccessToken(socialUser.getAccess_token());
        registerUser.setExpiresIn(socialUser.getExpires_in());
        registerUser.setSocialUid(socialUser.getUid());
        this.baseMapper.insert(registerUser);
        return registerUser;
    }
}
```

## 分布式 Session 问题

​	根据上面的开发过程能够发现，实际上登录逻辑和首页资源逻辑是分开不同域名(不同服务)的，甚至后面还有多个相同服务之间 session 内容的问题，因此传统的 session 存储实际上是无法使用的，是会存在 `session 不共享问题` ，主要就是两个问题：

`[问题1]` 不同服务下之间的相互调用时，子域之间 session 不共享问题。 =====> 实际上就是需要修改每次存储 session 时的`作用域 Domain 问题` ，需要指定域名为子域之上的父域名（默认是当前子域），从而实现各个子域之间的 session 透明。 =====> `SpringSession 框架` 

`[问题2]` 同一个服务域名下，复制多份相同服务，session 不同步问题。

1》`session 复制(同步)方案`：Tomcat 原生支持，只需要修改配置文件即可（大型系统不会使用）。

- 实现容易，只需要修改 web-server 的配置文件即可。

- session 同步需要数据传输，`占用大量网络带宽`，降低服务器集群的业务处理能力。

- 所有 web-server 保存全量数据，`内存限制`较大，导致无法扩展更多的服务。

2》`客户端存储方案`：浏览器存储到 cookie 中（基本不会使用）。

- 服务器不需要存储session，节省服务器资源。

- 每次 Http 请求都需要携带 cookie 完整信息，浪费网络带宽。

- session 数据存储在 cookie 中，但 cookie 有长度限制 4K，无法保存大量信息。

- 安全问题：存在泄露、篡改、窃取等安全隐患。

3》`Hash一致性方案`：同一个 IP 根据 Hash 一致性一直定位到同一个服务器上的该服务资源（能够使用，使用较多）。

- 只需要修改 nginx 配置，实现容易，同时本身还是负载均衡的，支持 web-server 的水平扩展，不需要进行 session 的复制。

- web-server 重启时可能会导致 session 丢失，影响业务，比如可能会导致重新登陆等问题。

- wen-server 水平扩展时，会导致 rehash，可能部分用户路由不到指定的服务，就会导致 session 读取不到。

4》`统一存储 session 方案`：使用一个固定的位置来存储 session 信息，例如 Redis 等。

- 没有安全隐患，支持水平扩展（只需要解决 Redis 内存问题），web-server 扩展时也不会丢失。

- 增加了网络调用交互，并且需要查询 redis 的相关操作，比直接从内存 session 中读取速度慢。 =====> `SpringSession 框架` 

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/a3b24723c0da4cbc88ea4010b1b89b66.png)

### SpringSession 整合

1、common 模块中放入 spring-session 的依赖，注意在其他不需要的项目中将 spring-session 依赖排除，同时 member 服务还需要引入 redis 依赖：

```xml
<!-- spring-session 整合 -->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
    <version>2.1.8.RELEASE</version>
</dependency>
```

2、配置文件配置 session 保存位置：

```yml
spring: 
	session: 
    	store-type: redis
# redis 连接信息
```

3、编写 session 相关的配置，并添加 `@EnableRedisHttpSession` 注解，此配置类用于设置cookie作用域以及 session-redis 的序列化机制(默认是 JDK 序列化)：

```java
//注：所有项目都需要这个配置，可以考虑放入 common 模块
@Configuration
@EnableRedisHttpSession		//整合 redis 作为 session 存储，此时 session 的存储就都是位于 redis 中。
public class SessionConfig {
    //cookie 相关的设置
    @Bean
    public CookieSerializer cookieSerializer(){
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        cookieSerializer.setDomainName("moonshop.com");    //放大cookie里面的session作用域到父域
        cookieSerializer.setCookieName("MOONSESSION");
        return cookieSerializer;
    }

    //session序列化机制:使用 fastjson 序列化机制
    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer(){
        return new GenericFastJsonRedisSerializer();
    }
}
```

4、此时就需要就需要修改原来的 product 服务，进行 spring-session 的相关配置，并开启 redis-session 服务。

5、auth 服务在登陆成功后需要将数据信息存入 session 中：

```java
session.setAttribute("loginUser", currentAuthLoginUser);
```

前端就可以直接从 session 中取出数据：

```js
<li>
	<a href="http://auth.moonshop.com/login.html" th:if="${session.loginUser == null}">您好，请登录</a>
	<a class="aa" th:if="${session.loginUser!=null}">欢迎您，[[${session.loginUser.nickname}]]</a>
</li>
```

注意在之前登录的位置添加 session 信息，用来保证整个服务的 session 信息的正确性。

![](https://pic1.imgdb.cn/item/63627dca16f2c2beb13d2d82.png)

7、此时还会发现当登陆过后时，仍然还是可以直接进入 auth 的 login 页面，因此 login 的配置不能通过简单的映射配置，而是应该单独设置自定义的业务逻辑，并且需要删除原先的 login.html 页面映射。

```java
@PostMapping("/login.html")
public String loginPage(UserLoginVo userLoginUser, HttpSession session) {
    //登陆后的账户不回到登录页，而是直接回到首页
    if (session.getAttribute(AuthServerConstant.LOGIN_USER) == null) {
        return "login";
    } else {
        return "redirect:http://moonshop.com/";
    }
}
```

> 注：域名信息实际上应该抽取到配置文件进行配置，方便上线后修改。

### SpringSession 原理

​	其主要实现是通过 `EnableRedisHttpSession` 注解：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@Documented
@Import({RedisHttpSessionConfiguration.class})	//给容器中添加 redis-session 配置
@Configuration
public @interface EnableRedisHttpSession {
    int maxInactiveIntervalInSeconds() default 1800;

    String redisNamespace() default "spring:session";

    RedisFlushMode redisFlushMode() default RedisFlushMode.ON_SAVE;

    String cleanupCron() default "0 * * * * *";
}
```

​	RedisHttpSessionConfiguration 配置的具体项：主要就是 `RedisOperationsSessionRepository` 组件，用来操作 redis 。

```java
@Configuration
@EnableScheduling
public class RedisHttpSessionConfiguration extends SpringHttpSessionConfiguration
		implements BeanClassLoaderAware, EmbeddedValueResolverAware, ImportAware,
		SchedulingConfigurer{
    //......
    @Bean	// RedisHttpSessionConfiguration 向容器中注入组件：RedisOperationsSessionRepository，相当于操作 redis 的一个 dao 对象
	public RedisOperationsSessionRepository sessionRepository();
    //......
}
```

​	实现了 SpringHttpSessionConfiguration 配置，而该组件内部注入了 `SessionRepositoryFilter` 存储过滤器，实际就是 Filter，因此每个请求进入系统都会经过这个过滤器。

```java
@Bean
public <S extends Session> SessionRepositoryFilter<? extends Session> springSessionRepositoryFilter(SessionRepository<S> sessionRepository)
```

​	而 `SessionRepositoryFilter` 作为过滤器的核心就是 `doFilterInternal `方法，就是过滤时的操作逻辑。

```java
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
    		throws ServletException, IOException {
    //同一个请求期间共享数据，使用同一个 session 操作类
    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);
    //对原生请求进行包装 SessionRepositoryRequestWrapper
    SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(
        request, response, this.servletContext);
     //对原生响应进行包装 SessionRepositoryResponseWrapper
    SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryResponseWrapper(
        wrappedRequest, response);
    try {
        //需要放行的是包装过后的请求和响应对象
        filterChain.doFilter(wrappedRequest, wrappedResponse);
    }
    finally {
        wrappedRequest.commitSession();
    }
}
```

​	包装的原因就是拒绝使用原生的 `request.getSession()` 来获取 session 数据，而是可以使用包装后的 request 来获取 Session，利用`装饰者模式`来进行一些原生的没有的操作：`getRequestSession` 方法，而这个方法内部就是使用之前的那个 `RedisOperationsSessionRepository` 组件进行操作，这也就导致了对 session 的操作都是使用 redis 来进行操作。		=====> 核心： `装饰者模式改变 session 的获取和存储方式`

## 单点登陆问题

针对单分布式系统，登陆问题和session共享问题得到了解决，但是是通过配置父域域名作用域的方式，如果此时整个大型系统架构中包括多个不同的父域域名时（例如 moonshop.com、webmoonshop.com、sun.com 等），此时每次访问其中的一个系统是不是都需要单独注册用户呢？如果都是需要不同账户或者说是同一个账户重新登陆，会非常麻烦。而 `SpringSession 只能将 session 作用域扩大到父域，并不能跨域名` ，那么如何能够实现此时的 `单点登陆需求` 呢？

单点登录 SSO ：`一次登录，处处可用`，也就是说在同架构下的多系统中能够实现在一处登录，其它系统(域名)都会自动登录，下线时会一起下线。

> 单点登录优秀开源框架：`https://gitee.com/xuxueli0323/xxl-sso?_from=gitee_search` 
>

​	单点登录核心就在于多个系统即使域名不相同，只要想办法给多个系统同步同一个用户的票据即可，主要就是通过中央认证服务器来实现。

注：此系统由于不涉及到多个不同域名系统的相关问题，因此不实现单点登录逻辑问题。
