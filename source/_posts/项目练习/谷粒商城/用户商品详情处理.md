---
title: 谷粒商城-用户商品详情处理
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringCloud
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## 异步编排

​	可以通过继承 Thread 类、实现 Runnable 接口、实现 Callable 接口 + FutureTask ，或是使用线程池来实现创建新线程，但那些都是基本的一些知识，因此此处主要讲述 `ComletableFuture(JDK1.8 功能)` 异步编排相关的业务场景和使用方案。

`[场景]`：现在需要查询到商品详情页的相关信息，那么就需要调用到很多的方法，如果一步步来执行那么就会导致响应时间过长，那么就需要进行`异步查询`，同时部分查询可能还需要依赖之前查询的结果来进行查询 ======> 就需要使用 `ComletableFuture (类似于 Promise) `。

1、异步任务执行：

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        //启动异步任务，使用自己定义的线程池
//        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
//            System.out.println("当前线程：" + Thread.currentThread().getName());
//            int i = 10 / 2;
//            System.out.println(i);
//        }, executor);
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getName());
            int i = 10 / 2;
            System.out.println(i);
            return i;
        }, executor);
        System.out.println("future.get() = " + future.get());
        System.out.println("main-end......");
    }
}
```

2、完成回调函数和异常处理方式：

1）`whenComplete` 得到返回结果和 `exceptionally` 处理异常分开处理：

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getName());
            int i = 10 / 0;
            System.out.println(i);
            return i;
        }, executor).whenComplete((result, throwable) -> {	//成功回调函数
            System.out.println("异步任务成功完成.....");
            System.out.println("结果 result = " + result);
            System.out.println("异常 throwable = " + throwable);
        }).exceptionally(throwable -> {		//异常处理函数
            return -1;  //出现异常的默认返回
        });
        System.out.println("future.get() = " + future.get());
        System.out.println("main-end......");
    }
}
```

2）`handle` 同时感知异常并处理结果：

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getName());
            int i = 10 / 0;
            System.out.println(i);
            return i;
        }, executor).handle((result, throwable) -> {
            if (result != null) {
                return result * 10;
            }
            if (throwable != null) {
                throwable.printStackTrace();
                return -1;
            }
            return -1;
        });
        System.out.println("future.get() = " + future.get());
        System.out.println("main-end......");
    }
}
```

3、线程串行化处理：

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getName());
            int i = 10 / 2;
            System.out.println(i);
            return i;
        }, executor)
            /*.thenRunAsync(() -> {
            //thenRunXXX 不能获取上一步的执行结果，也无返回值
            //thenRunAsync 使用新的线程池线程/原线程异步执行新任务
            //thenRun 使用原来的线程同步继续执行新任务
            System.out.println("task2 执行......");
        })*/
            /*.thenAcceptAsync((res) -> {
            //thenAcceptXXX 能获取上一步的执行结果，但无返回值
            //thenAcceptAsync 使用新的线程池线程/原线程异步执行新任务
            //thenAccept 使用原来的线程同步继续执行新任务
            System.out.println("task3-res = " + res);
        })*/
        .thenApplyAsync((res) -> {
            //thenApplyXXX 能获取上一步的执行结果，而且有返回值
            //thenApplyAsync 使用新的线程池线程/原线程异步执行新任务
            //thenApply 使用原来的线程同步继续执行新任务
            System.out.println("task4-res = " + res);
            return res + ",hello!";
        });
        System.out.println("future.get() = " + future.get());
        System.out.println("main-end......");
    }
}
```

4、两任务合并触发回调事件：两个任务进行执行后触发内部的新任务。

1）两个任务都要完成才会触发：

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            System.out.println("任务1-当前线程：" + Thread.currentThread().getName());
            int i = 10 / 5;
            System.out.println("任务1结束......");
            return i;
        }, executor);
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            System.out.println("任务2-当前线程：" + Thread.currentThread().getName());
            System.out.println("任务2结束......");
            return "Hello";
        }, executor);

        //runAfterBothXXX 表示不需要接收两个 future 的返回值，同时也没有返回值
        future1.runAfterBothAsync(future2, () -> {
            System.out.println("任务3开始执行......");
        }, executor);

        //thenAcceptBothXXX 表示需要接收两个 future 的返回值，但是没有返回值
        future1.thenAcceptBothAsync(future2, (res1, res2) -> {
            System.out.println(res1 + res2);
        }, executor);

        //thenCombineXXX 表示需要接收两个 future 的返回值，同时也有返回值
        CompletableFuture<String> future = future1.thenCombineAsync(future2, (res1, res2) -> {
            return res1 + "->" + res2 + "->" + "world!";
        }, executor);
        System.out.println(future.get());
        System.out.println("main-end......");
    }
}
```

2）两个任务执行其中一个就会触发：

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        CompletableFuture<Object> future1 = CompletableFuture.supplyAsync(() -> {
            System.out.println("任务1-当前线程：" + Thread.currentThread().getName());
            int i = 10 / 5;
            System.out.println("任务1结束......");
            return i;
        }, executor);
        CompletableFuture<Object> future2 = CompletableFuture.supplyAsync(() -> {
            System.out.println("任务2-当前线程：" + Thread.currentThread().getName());
            try {
                Thread.sleep(300);
                System.out.println("任务2结束......");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "Hello";
        }, executor);

        //runAfterEitherXXX 表示无需获取两个 future 的返回值，自身也没有返回值
        future1.runAfterEitherAsync(future2, () -> {
            System.out.println("某一个任务执行完毕!");
        }, executor);

        //acceptEitherXXX 表示会获取两个 future 中执行完毕的那个任务的返回值，但自身没有返回值(两个 future 需要相同返回类型)
        future1.acceptEitherAsync(future2, (res) -> {
            System.out.println("某个线程执行完毕的结果：" + res);
        }, executor);

        //applyToEitherXXX 表示会获取两个 future 中执行完毕的那个任务的返回值，自身有返回值(两个 future 需要相同返回类型)
        CompletableFuture<String> future = future1.applyToEitherAsync(future2, (res) -> {
            return res + "......";
        });
        System.out.println("future.get() = " + future.get());
        System.out.println("main-end......");
    }
}
```

5、多任务组合：多个任务组合查询。

```java
public class ThreadTest {
    private static ExecutorService executor = Executors.newFixedThreadPool(10);
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main-start......");
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            System.out.println("查询商品的图片信息......");
            return "product-image";
        }, executor);
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            System.out.println("查询商品的属性信息......");
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "product-attr";
        }, executor);
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            System.out.println("查询商品的介绍信息......");
            return "product-desc";
        }, executor);
        //使用 get 进行阻塞式等待可以解决，但是很浪费资源，需要等待很久,因此考虑使用 allOf 和 anyOf 功能
        //CompletableFuture<Void> allOfFuture = CompletableFuture.allOf(future1, future2, future3);
        CompletableFuture<Object> anyOfFuture = CompletableFuture.anyOf(future1, future2, future3);
        //allOfFuture.get();    //等待所有结果完成
        anyOfFuture.get();      //等待任意一个任务完成
        System.out.println("main-end......");
    }
}
```

## 商品详情

1、修改 host 文件夹，增加 `item.moonshop.com` 映射配置：

2、修改网关配置：

```yml
- id: shop_host_route
    # 路由到商品服务首页
    uri: lb://shop-product   
    predicates: 
        - Host=moonshop.com,item.moonshop.com
```

3、复制前端页面到 nginx ，将 html 页面复制到项目里面。

4、构建前端需要数据的Java Bean 模型：

1）前端所需要数据的封装：

```java
@Data
public class SkuItemVo {
    //1.获取sku基本信息:pms_sku_info
    private SkuInfoEntity info;
    private boolean hasStock = true;
    //2.获取sku图片信息:pms_sku_images
    private List<SkuImagesEntity> images;
    //3.获取spu销售属性组合
    private List<SkuItemSaleAttrVo> saleAttr;
    //4.获取spu介绍
    private SpuInfoDescEntity desc;
    //5.获取spu规则参数信息
    private List<SpuItemBaseAttrGroupVo> groupAttrs;
}
```

2）前端显示 spu 销售属性的封装：

```java
@Data
public class SkuItemSaleAttrVo {
    private Long attrId;
    private String attrName;
    private List<AttrValueWithSkuIdVo> attrValues;
}
```

3）前端显示 spu 属性的封装：

```java
@Data
@ToString
public class SpuItemBaseAttrGroupVo {
    private String groupName;
    private List<SpuBaseAttrVo> attrs;
}
```

```java
@Data
@ToString
public class SpuBaseAttrVo {
    private String attrName;
    private String attrValue;
}
```

此处封装成两个是为了方便前端多个属性的选择点击，将笛卡尔积属性条件变为属性对应的 spu 取交集。

5、controller 接受请求，调用业务，装载数据：

```java
@Controller
public class ItemController {
    @Autowired
    private SkuInfoService skuInfoService;

    @GetMapping("/{skuId}.html")
    public String skuItem(@PathVariable("skuId") Long skuId, Model model) throws ExecutionException, InterruptedException {
        SkuItemVo skuItemVo = skuInfoService.item(skuId);
        model.addAttribute("item", skuItemVo);
        return "item";
    }
}
```

6、业务具体涉及多个操作，并且之间有一定的关系，能够利用到 `CompletableFuture` 进行异步编排，因此需要设计单独的线程池：

```java
@EnableConfigurationProperties(ThreadPoolConfigProperties.class)
@Configuration
public class MyThreadConfig {
    @Bean
    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool){
        return new ThreadPoolExecutor(
                pool.getCoreSize(),
                pool.getMaxSize(),
                pool.getKeepAliveTime(),
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(100000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
    }
}
```

```java
//ConfigurationProperties动态配置线程池
@ConfigurationProperties(prefix = "shop.thread")
@Component
@Data
@Primary    //@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。
public class ThreadPoolConfigProperties {
    private Integer coreSize;
    private Integer maxSize;
    private Integer keepAliveTime;
}
```

```yml
shop: 
  thread: 
    core-size: 20
    max-size: 200
    keep-alive-time: 10
```

7、具体的业务处理则调用 item 方法：

```java
/**
 * SkuInfoServiceImpl
 * 查询某个商品详情页需要的信息
 * @param skuId 具体商品的 skuId
 * 注：CompletableFuture 异步编排方式实现
 */
@Autowired
ThreadPoolExecutor threadPool;

@Override
public SkuItemVo item(Long skuId) throws ExecutionException, InterruptedException {
    SkuItemVo skuItemVo = new SkuItemVo();
    CompletableFuture<SkuInfoEntity> infoFuture = CompletableFuture.supplyAsync(() -> {
        //1.获取sku基本信息:pms_sku_info
        SkuInfoEntity skuInfo = this.getById(skuId);
        skuItemVo.setInfo(skuInfo);
        return skuInfo;
    }, threadPool);

    CompletableFuture<Void> saleAttrFuture = infoFuture.thenAcceptAsync((skuInfo) -> {
        //3.获取spu销售属性组合(依赖于第一个任务)
        List<SkuItemSaleAttrVo> saleAttrVos = skuSaleAttrValueService.getSaleAttrsBySpuId(skuInfo.getSpuId());
        skuItemVo.setSaleAttr(saleAttrVos);
    }, threadPool);

    CompletableFuture<Void> spuDescFuture = infoFuture.thenAcceptAsync((skuInfo) -> {
        //4.获取spu介绍:pms_spu_info_desc(依赖于第一个任务)
        SpuInfoDescEntity spuInfoDescEntity = spuInfoDescService.getById(skuInfo.getSpuId());
        skuItemVo.setDesc(spuInfoDescEntity);
    }, threadPool);

    CompletableFuture<Void> baseAttrFuture = infoFuture.thenAcceptAsync((skuInfo) -> {
        //5.获取spu规则参数信息:pms_spu_info_desc(依赖于第一个任务)
        List<SpuItemBaseAttrGroupVo> attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(skuInfo.getSkuId(), skuInfo.getCatalogId());
        skuItemVo.setGroupAttrs(attrGroupVos);
    }, threadPool);


    //2.获取sku图片信息:pms_sku_images(和其它任务没有关系)
    CompletableFuture<Void> imageFuture = CompletableFuture.runAsync(() -> {
        List<SkuImagesEntity> skuImagesEntities = imagesService.getImagesBySkuId(skuId);
        skuItemVo.setImages(skuImagesEntities);
    }, threadPool);

    //需要等待所有任务完成在进行返回数据
    CompletableFuture.allOf(saleAttrFuture, spuDescFuture, baseAttrFuture, imageFuture).get();

    return skuItemVo;
}
```

1）获取 spu 销售属性组合：

```java
//SkuSaleAttrValueServiceImpl 
@Override
public List<SkuItemSaleAttrVo> getSaleAttrsBySpuId(Long spuId) {
    return this.baseMapper.getSaleAttrsBySpuId(spuId);
}

//SkuSaleAttrValueDao
List<SkuItemSaleAttrVo> getSaleAttrsBySpuId(@Param("spuId") Long spuId);
```

```xml
<!-- 分析当前 spu 有多少sku，所有sku设计到的属性组合 -->
<resultMap id="SkuItemSaleAttrVo" type="com.example.product.pojo.vo.web.SkuItemSaleAttrVo">
    <result column="attr_id" property="attrId"></result>
    <result column="attr_name" property="attrName"></result>
    <collection property="attrValues" ofType="com.example.product.pojo.vo.web.AttrValueWithSkuIdVo">
        <result column="attr_value" property="attrValue"></result>
        <result column="sku_ids" property="skuIds"></result>
    </collection>
</resultMap>
<select id="getSaleAttrsBySpuId" resultMap="SkuItemSaleAttrVo">
        select
               ssav.attr_id as attr_id,
               ssav.attr_name as attr_name,
               ssav.attr_value,
               group_concat(distinct info.sku_id) as sku_ids
        from pms_sku_info as info
        left join pms_sku_sale_attr_value as ssav on ssav.sku_id = info.sku_id
        where info.spu_id = #{spuId}
        group by ssav.attr_id, ssav.attr_name, ssav.attr_value
</select>
```

2）获取 spu 规则参数信息：

```java
/**
 * AttrGroupServiceImpl
 * 查出当前 spu 所有属性分组信息以及对应的属性值
 * @param spuId spuId
 */
@Override
public List<SpuItemBaseAttrGroupVo> getAttrGroupWithAttrsBySpuId(Long spuId, Long catalogId) {
    return this.baseMapper.getAttrGroupWithAttrsBySpuId(spuId, catalogId);
}

//AttrGroupDao
List<SpuItemBaseAttrGroupVo> getAttrGroupWithAttrsBySpuId(@Param("spuId") Long spuId, @Param("catalogId") Long catalogId);
```

```xml
<!-- resultType 返回集合里面元素的类型，只要有嵌套属性就必须封装自定义结果集 -->
<resultMap id="spuItemBaseAttrGroupVo" type="com.example.product.pojo.vo.web.SpuItemBaseAttrGroupVo">
    <result column="attr_group_name" property="groupName"></result>
    <collection property="attrs" ofType="com.example.product.pojo.vo.web.SpuBaseAttrVo">
        <result column="attr_name" property="attrName"></result>
        <result column="attr_value" property="attrValue"></result>
    </collection>
</resultMap>
<select id="getAttrGroupWithAttrsBySpuId" resultMap="spuItemBaseAttrGroupVo">
    select
        pav.spu_id,
        ag.attr_group_name,
        ag.attr_group_id,
        aar.attr_id,
        attr.attr_name,
        pav.attr_value
    from pms_attr_group as ag
    left join pms_attr_attrgroup_relation as aar on aar.attr_group_id = ag.attr_group_id
    left join pms_attr as attr on attr.attr_id = aar.attr_id
    left join pms_product_attr_value as pav on pav.attr_id = attr.attr_id
    where ag.catelog_id = #{catalogId} and pav.spu_id = #{spuId}
</select>
```
