---
title: 谷粒商城-仓储服务模块
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringBoot
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## 仓库维护

将 ware 加入到注册中心中，并进行配置中心的相关配置，主启动类添加 `EnableDiscoveryClient` 注解开启 nacos 注册，同时将 MybatisConfig 配置添加进去。

修改网关配置，将网关配置对应的路由规则。

```yml
- id: ware_route
  uri: lb://shop-ware
  predicates: # 规定前端项目的路由都带有 /api/ware/ 前缀
    - Path=/api/ware/**
  filters:
    - RewritePath=/api/(?<segment>.*),/$\{segment}
```

1、根据前端接口，实现后端的模糊查询的基本列表展示接口。

![](https://pic1.imgdb.cn/item/634d191d16f2c2beb1fcd1b8.png)

```java
/**
 * WareInfoController
 * 获取指定 searchKey 搜索出来的仓库列表
 * @param params 分页参数和 searchKey 信息
 * @return 仓库列表
 */
@GetMapping("/list")
public R list(@RequestParam Map<String, Object> params){
    PageUtils page = wareInfoService.queryPage(params);
    return R.ok().put("page", page);
}

/**
 * WareInfoServiceImpl
 * 获取指定 searchKey 搜索出来的仓库列表
 * @param params 分页参数和 searchKey 信息
 */
@Override
public PageUtils queryPage(Map<String, Object> params) {
    QueryWrapper<WareInfoEntity> wrapper = new QueryWrapper<>();
    String searchKey = (String) params.get("key");
    if (!StringUtils.isNullOrEmpty(searchKey)){
        wrapper.eq("id", searchKey)
            .or().like("name", searchKey)
            .or().like("address", searchKey)
            .or().like("areacode", searchKey);
    }
    IPage<WareInfoEntity> page = this.page(new Query<WareInfoEntity>().getPage(params), wrapper);
    return new PageUtils(page);
}
```

2、其他基本的新增、修改、删除等接口直接使用基本的逆向生成的代码即可（经过测试都没问题）。

## 商品库存

和前端接口对接实现后端逻辑即可。

### 商品库存列表

实现根据对应的条件查询商品库存的接口。

```java
/**
 * WareSkuController
 * 查询商品库存信息
 * @param params 查询参数的封装
 */
@RequestMapping("/list")
public R list(@RequestParam Map<String, Object> params){
    PageUtils page = wareSkuService.queryPageByCondition(params);
    return R.ok().put("page", page);
}

/**
 * WareSkuServiceImpl
 * 根据条件查询商品库存
 * @param params 分页参数和条件
 * @return 商品库存信息
 */
@Override
public PageUtils queryPageByCondition(Map<String, Object> params) {
    QueryWrapper<WareSkuEntity> wrapper = new QueryWrapper<>();
    //封装查询条件
    //1.设置仓库名称，实际上传的仓库id
    String wareId = (String) params.get("wareId");
    if (!StringUtils.isNullOrEmpty(wareId)){
        wrapper.eq("ware_id", wareId);
    }
    //2.设置skuId信息
    String skuId = (String) params.get("skuId");
    if (!StringUtils.isNullOrEmpty(skuId)){
        wrapper.eq("sku_id", skuId);
    }
    //查询数据封装结果集
    IPage<WareSkuEntity> page = this.page(new Query<WareSkuEntity>().getPage(params), wrapper);
    return new PageUtils(page);
}
```

### 商品采购实现

实际上商品库存的新增是应该按照采购单信息来录入的，而采购单是根据采购需求来确定的，并不是由自己来随意填写。

#### 采购需求列表

```java
/**
 * PurchaseDetailController
 * 根据条件获取采购需求列表
 * @param params 分页参数和查询条件
 * @return 采购需求列表
 */
@RequestMapping("/list")
public R list(@RequestParam Map<String, Object> params){
    PageUtils page = purchaseDetailService.queryPageByCondition(params);
    return R.ok().put("page", page);
}

/**
 * PurchaseDetailServiceImpl
 * 根据条件获取采购需求列表
 * @param params 分页参数和查询条件
 * @return 采购需求列表
 */
@Override
public PageUtils queryPageByCondition(Map<String, Object> params) {
    QueryWrapper<PurchaseDetailEntity> wrapper = new QueryWrapper<>();
    //设置前端传递的参数
    //1.设置 searchKey，需要进行整体拼接
    String searchKey  = (String) params.get("key");
    if (!StringUtils.isNullOrEmpty(searchKey)){
        wrapper.and(w -> {
            w.eq("sku_id", searchKey).or().eq("purchase_id", searchKey);
        });
    }
    //2.设置采购单状态信息
    String status  = (String) params.get("status");
    if (!StringUtils.isNullOrEmpty(status)){
        wrapper.eq("status", status);
    }
    //3.设置仓库名称，实际是传递仓库id
    String wareId  = (String) params.get("wareId");
    if (!StringUtils.isNullOrEmpty(wareId)){
        wrapper.eq("ware_id", wareId);
    }
    //封装执行 sql 语句获取数据
    IPage<PurchaseDetailEntity> page = this.page(new Query<PurchaseDetailEntity>().getPage(params), wrapper);
    return new PageUtils(page);
}
```

### 采购单实现

采购需求要么是`人工发起`，要么就应该是`库存告警自动提交`的采购需求，针对这些采购需求，可以在后台人工进行合并，或者系统设置定时任务进行定时合并，合并出采购单后，采购人员再根据采购单进行采购或通知供货商供货，而后采购单才能入库，商品库存才能确定。

#### 查询采购单

查询可合并进的采购单列表：这些可合并进的采购单应该是未领取（新建的或是已分配人员的）的采购单，那么首先就需要显示这个列表。

common 服务下新建状态信息枚举常量类，方便后续多处使用：

```java
public class WareConstant {

    @Getter
    public enum PurchaseStatusEnum {
        CREATED(0, "新建"), ASSIGNED(1, "已分配"),
        RECEIVE(2, "已领取"), FINISH(3, "已完成"),
        HASERROR(4, "有异常");

        private int code;
        private String msg;

        PurchaseStatusEnum(int code, String msg) {
            this.code = code;
            this.msg = msg;
        }
    }
    
    @Getter
    public enum  PurchaseDetailStatusEnum{
        CREATED(0,"新建"),ASSIGNED(1,"已分配"),
        BUYING(2,"正在采购"),FINISH(3,"已完成"),
        HASERROR(4,"采购失败");
        private int code;
        private String msg;

        PurchaseDetailStatusEnum(int code,String msg){
            this.code = code;
            this.msg = msg;
        }
    }
}
```

具体业务逻辑的实现：

```java
/**
 * PurchaseController
 * 获取未被领取的采购单列表
 * @param params 查询条件：未被领取
 * @return 采购单列表
 */
@GetMapping("/unreceive/list")
public R getUnReceiveList(@RequestParam Map<String, Object> params){
    PageUtils page = purchaseService.queryPageUnReceive(params);
    return R.ok().put("page", page);
}

/**
 * PurchaseServiceImpl
 * 增加 status 的条件判断查询对应的采购单
 * @param params 分页信息参数
 */
@Override
public PageUtils queryPageUnReceive(Map<String, Object> params) {
    QueryWrapper<PurchaseEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("status", WareConstant.PurchaseStatusEnum.CREATED.getCode())
        .or().eq("status", WareConstant.PurchaseStatusEnum.ASSIGNED.getCode());
    IPage<PurchaseEntity> page = this.page(new Query<PurchaseEntity>().getPage(params), wrapper);
    return new PageUtils(page);
}
```

#### 合并采购单

进行采购需求的合并，合并到采购单中：

将前端提交的数据封装成 MergeVo：

```java
@Data
public class MergeVo {
    private Long purchaseId;
    private List<Long> items;
}
```

具体的实现逻辑：

```java
/**
 * PurchaseController
 * 合并采购需求
 * @param mergeVo 前端提交的数据封装，可能不存在 purchaseId 那么就需要新建一个采购单
 */
@PostMapping("/merge")
public R mergePurchase(@RequestBody MergeVo mergeVo){
    purchaseService.mergePurchase(mergeVo);
    return R.ok();
}

/**
 * PurchaseServiceImpl
 * 合并采购需求到采购单
 * @param mergeVo 采购需求集合+采购单id
 */
@Transactional
@Override
public void mergePurchase(MergeVo mergeVo) {
    Long purchaseId = mergeVo.getPurchaseId();
    if (purchaseId == null){
        //如果不传入 purchaseId 那么就需要新建一个采购单进行合并
        PurchaseEntity purchaseEntity = new PurchaseEntity();
        purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.CREATED.getCode());    //设置采购单状态
        //TODO:应该使用mybatis设置的默认值
        purchaseEntity.setCreateTime(new Date());
        purchaseEntity.setUpdateTime(new Date());
        this.save(purchaseEntity);
        purchaseId = purchaseEntity.getId();    //新的采购单的 id
    }
    //TODO:需要确认采购单状态是 0（新建），1（已分配） 才可以合并
    //正式合并采购需求
    Long finalPurchaseId = purchaseId;
    List<Long> purchaseItems = mergeVo.getItems();
    List<PurchaseDetailEntity> purchaseDetailEntityList = purchaseItems.stream().map(purchaseItem -> {
        PurchaseDetailEntity detailEntity = new PurchaseDetailEntity();
        //修改采购单状态为已分配，以及采购单id
        detailEntity.setId(purchaseItem);
        detailEntity.setPurchaseId(finalPurchaseId);
        detailEntity.setStatus(WareConstant.PurchaseDetailStatusEnum.ASSIGNED.getCode());
        return detailEntity;
    }).collect(Collectors.toList());
    //更新采购单的细节信息，设置对应的分配信息
    purchaseDetailService.updateBatchById(purchaseDetailEntityList);

    //采购单更新时间的更新
    PurchaseEntity purchaseEntity = new PurchaseEntity();
    purchaseEntity.setId(purchaseId);
    purchaseEntity.setUpdateTime(new Date());
    this.updateById(purchaseEntity);
}
```

#### 采购单领取

此时实际上是应该采购人员员工系统 App 来发送请求，因此此处使用 Postman 进行测试发送请求领取采购单。

Postman 请求：`http://localhost:88/api/ware/purchase/received`

后台实现具体逻辑：

```java
/**
 * PurchaseController
 * 领取采购单的请求接收
 * @param purchaseIds 要领取采购单的列表id
 */
@PostMapping("/received")
public R receivedPurchase(@RequestBody List<Long> purchaseIds){
    purchaseService.receivedPurchase(purchaseIds);
    return R.ok();
}

/**
 * PurchaseServiceImpl
 * 根据一定条件领取对应的采购单
 * @param purchaseIds 采购单id列表
 */
@Override
public void receivedPurchase(List<Long> purchaseIds) {
    //1.手机满足条件的采购单
    List<PurchaseEntity> purchaseEntityList = purchaseIds.stream().map(purchaseId -> {
        return this.getById(purchaseId);
    }).filter(purchase -> {
        //确认当前采购单是新建状态或是已分配状态
        if (purchase.getStatus() == WareConstant.PurchaseStatusEnum.CREATED.getCode() ||
            purchase.getStatus() == WareConstant.PurchaseStatusEnum.ASSIGNED.getCode()) {
            return true;
        }
        return false;
    }).map(purchase -> {
        //2.1设置采购单的状态：已领取
        purchase.setStatus(WareConstant.PurchaseStatusEnum.RECEIVE.getCode());
        purchase.setUpdateTime(new Date());
        return purchase;
    }).collect(Collectors.toList());
    //2.2 修改数据库状态
    this.updateBatchById(purchaseEntityList);

    //3.修改这个采购单里面的每一项的采购需求的信息
    purchaseEntityList.forEach( purchaseEntity -> {
        List<PurchaseDetailEntity> detailEntityList = purchaseDetailService.listDetailByPurchaseId(purchaseEntity.getId());
        List<PurchaseDetailEntity> collect = detailEntityList.stream().map(detailEntity -> {
            PurchaseDetailEntity entity = new PurchaseDetailEntity();
            entity.setId(detailEntity.getId());
            entity.setStatus(WareConstant.PurchaseDetailStatusEnum.BUYING.getCode());   //状态变为正在采购
            return entity;
        }).collect(Collectors.toList());
        purchaseDetailService.updateBatchById(collect);
    });

}

/**
 * PurchaseDetailServiceImpl
 * 根据采购单id获取对应的采购需求信息
 * @param id 采购单id
 * @return 采购需求列表
 */
@Override
public List<PurchaseDetailEntity> listDetailByPurchaseId(Long id) {
    QueryWrapper<PurchaseDetailEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("purchase_id", id);
    return this.list(wrapper);
}
```

![](https://pic1.imgdb.cn/item/634e3be816f2c2beb123a2dc.png)

![](https://pic1.imgdb.cn/item/634e3c0416f2c2beb12403c1.png)

#### 采购单完成

采购人员采购完成后，库存数量才会新增，同样采用 Postman 来模拟采购。

Postman 请求：`http://localhost:88/api/ware/purchase/done` 

![](https://pic1.imgdb.cn/item/634e62a516f2c2beb17f0025.png)

后台实现具体逻辑：

1）收集前端提交数据：

```java
@Data
public class PurchaseDoneVo {
    @NotNull
    private Long id;    //采购单id
    private List<PurchaseItemDoneVo> items; //采购需求项
}

@Data
public class PurchaseItemDoneVo {
    private Long itemId;
    private Integer status;
    private String reason;
}
```

2）PurchaseController 接受请求调用 service 进行处理：

```java
@PostMapping("/done")
public R donePurchase(@RequestBody PurchaseDoneVo purchaseDoneVo){
    purchaseService.done(purchaseDoneVo);
    return R.ok();
}
```

3）PurchaseServiceImpl 进行具体的业务处理：

```java
/**
 * PurchaseServiceImpl
 * 根据采购单提交采购项
 * @param purchaseDoneVo 采购信息
 */
@Transactional
@Override
public void done(PurchaseDoneVo purchaseDoneVo) {
    //TODO：数据库需要进行修改，添加采购失败原因字段，还有应采购数量、实际采购数量的拓展
    //1.改变采购需求的项目
    List<PurchaseItemDoneVo> purchaseItems = purchaseDoneVo.getItems();
    List<PurchaseDetailEntity> updateList = new ArrayList<>();      //需要更新的数据集合
    boolean purchaseFlag = true;    //采购需求状态标志位
    for (PurchaseItemDoneVo purchase : purchaseItems){
        Long detailId = purchase.getItemId();   //采购需求id
        PurchaseDetailEntity detailEntity = purchaseDetailService.getById(detailId);
        //如果采购需求失败,则设置状态 purchaseFlag
        if (purchase.getStatus() == WareConstant.PurchaseDetailStatusEnum.HASERROR.getCode()){
            purchaseFlag = false;
            detailEntity.setStatus(purchase.getStatus());   //设置采购需求失败状态
        }else {
            detailEntity.setStatus(WareConstant.PurchaseDetailStatusEnum.FINISH.getCode());   //设置采购需求成功状态
            //采购成功则将成功采购的商品进行入库，更新库存
            skuService.addStock(detailEntity.getSkuId(),
                                detailEntity.getWareId(), detailEntity.getSkuNum());
        }
        detailEntity.setId(purchase.getItemId());
        updateList.add(detailEntity);
    }
    purchaseDetailService.updateBatchById(updateList);
    //2.修改采购单本身的状态
    PurchaseEntity purchaseEntity = new PurchaseEntity();
    purchaseEntity.setId(purchaseDoneVo.getId());
    purchaseEntity.setStatus(purchaseFlag ?
                             WareConstant.PurchaseStatusEnum.FINISH.getCode() : WareConstant.PurchaseStatusEnum.HASERROR.getCode());
    purchaseEntity.setUpdateTime(new Date());
    this.updateById(purchaseEntity);
}

/**
 * WareSkuServiceImpl
 * 添加商品到库存
 * @param skuId 商品skuId
 * @param wareId  仓库Id
 * @param skuNum  添加数量
 */
@Override
public void addStock(Long skuId, Long wareId, Integer skuNum) {
    //判断是否有这个商品的信息，如果有则是更新操作，如果没有那么就是新增操作
    QueryWrapper<WareSkuEntity> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("sku_id", skuId);
    queryWrapper.eq("ware_id", wareId);
    List<WareSkuEntity> skuEntities = wareSkuDao.selectList(queryWrapper);
    if (skuEntities == null || skuEntities.size() == 0) {
        WareSkuEntity wareSkuEntity = new WareSkuEntity();
        wareSkuEntity.setSkuId(skuId);
        wareSkuEntity.setWareId(wareId);
        wareSkuEntity.setStock(skuNum);
        //远程查询 skuName 设置到 wareSkuEntity 实现前端页面采购单信息的显示
        //使用 try 是为了保证 skuName 设置失败也能够成功加入库存而不至于直接回滚事务
        //TODO:还有什么办法让异常出现以后仍然不会回滚呢？
        try {
            R info = productFeignService.info(skuId);
            if (info.getCode() == 0){
                Map<String, Object> skuInfo = (Map<String, Object>) info.get("skuInfo");
                wareSkuEntity.setSkuName((String) skuInfo.get("skuName"));
            }
        }catch (Exception e) {
            System.out.println("设置 skuName 失败!");
        }
        wareSkuEntity.setStockLocked(0);    //设置默认锁定库存0
        wareSkuDao.insert(wareSkuEntity);
    } else {
        wareSkuDao.addStock(skuId, wareId, skuNum);
    }
}

void addStock(@Param("skuId") Long skuId, @Param("wareId") Long wareId, @Param("skuNum") Integer skuNum);

<update id="addStock">
    update wms_ware_sku set stock=stock+#{skuNum} where sku_id=#{skuId} and ware_id=#{wareId}
</update>
```

采购成功后商品库存页面出现采购的库存数据：

![](https://pic1.imgdb.cn/item/634e637316f2c2beb1805881.png)































