---
title: 谷粒商城-购物车逻辑实现
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringCloud
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

### 环境搭建

创建购物车 `shop-cart` 服务，导入 devtools、lombok、web 服务、Thymeleaf、OpenFeign 服务，并导入 common 服务公共模块(`排除数据源配置`)，并且创建对应的域名映射，配置 nginx 静态资源文件。购物车使用 `30000` 端口，配置 nacos 配置中心和注册中心信息，并需要配置 springsession 相关。

1、修改网关配置，让购物车能够映射正确：

```yml
- id: shop_cart_route
  # 路由到检索服务首页
  uri: lb://shop-cart
  predicates: 
    - Host=cart.moonshop.com
```

2、需求分析：实际上分为在线购物车和离线购物车。

1）用户在`未登录`状态下添加商品到购物车：`离线购物车`。需要注意的是当前浏览器关闭再打开时购物车中内容并不会清空，因此考虑离线购物车的数据应该放在浏览器的本地 localstorage、cookie、webSQL（H5 内嵌数据库） 或 `Redis`(本项目采用) 中。

2）用户在`登录`状态下添加商品到购物车：在线购物车。需要注意的是就是用户登陆以后会将 `当前浏览器登陆前的离线购物车` 中的数据合并进来，并且清空离线购物车中的数据，因此考虑数据放入 `Redis`(本项目采用 Redis 实现，利用实现持久化)、MySQL、MongoDB 等。

因此所有数据都选择存储在 Redis 中，一个用户对应两个购物车信息，采用 `Map<String, Map<String, CartItemInfo>>` 形式的数据结构存储。

3、封装购物车内部的购物项信息：

```java
//购物车内购物项信息封装
@ToString
public class CartItem {
    private Long skuId;
    private Boolean check = true;   //选中状态
    private String title;
    private String image;
    private List<String> skuAttr;   //套餐信息
    private BigDecimal price;
    private Integer count;          //单品数量
    private BigDecimal totalPrice;
    
    //单独设置总价计算方法
    public BigDecimal getTotalPrice() {
        return this.price.multiply(BigDecimal.valueOf(this.count));
    }
    //getter and setter
}
```

封装购物车信息：

```java
@ToString
public class Cart {
    List<CartItem> items;  // 购物车商品项
    Integer itemCount; // 商品数量
    Integer itemTypeCount; // 商品类型数量
    BigDecimal totalPrice; // 总价
    BigDecimal reduce = new BigDecimal("0"); // 减免价格

    public List<CartItem> getItems() {
        return items;
    }

    public void setItems(List<CartItem> items) {
        this.items = items;
    }

    public Integer getItemCount() {
        int count = 0;
        if (this.items != null && this.items.size() > 0) {
            for (CartItem item : items) {
                count += item.getCount();
            }
        }
        return count;
    }

    public Integer getItemTypeCount() {
        int count = 0;
        if (this.items != null && this.items.size() > 0) {
            for (CartItem item : items) {
                count += 1;
            }
        }
        return count;
    }

    public BigDecimal getTotalPrice() {
        //1.商品总价
        BigDecimal price = new BigDecimal("0");
        if (this.items != null && this.items.size() > 0) {
            for (CartItem item : items) {
                if (item.getCheck()) {
                    price = price.add(item.getTotalPrice());
                }
            }
        }
        //2.减免价格
        price = price.subtract(this.getReduce());
        return price;
    }

    public BigDecimal getReduce() {
        return reduce;
    }

    public void setReduce(BigDecimal reduce) {
        this.reduce = reduce;
    }
}
```

根据京东的设置方式，添加购物车常量设置 `临时用户` 的标志常量：

```java
public class CartConstant {
    public final String TEMP_USER_COOKIE_NAME = "user-key";
}
```

封装一个当前网站的使用用户的 To：

```java
@Data
@ToString
public class UserInfoTo {
    private Long userId;    //登陆了则直接就有用户信息
    private String userKey; //没登录则有 user-key 标志
}
```

4、由于每次请求都需要判断是登录用户还是临时用户操作数据，那么就可以直接将获取用户信息的方法`放入拦截器中进行统一管理` ：

```java
@Component
public class CartInterceptor implements HandlerInterceptor {
    //在执行目标方法之前进行拦截，判断用户的登陆状态，并封装传递给 controller 目标请求

    public static ThreadLocal<UserInfoTo> threadLocal = new ThreadLocal<>();

    //目标方法执行之前进行拦截
    //浏览器的cookie中会存放一个 user-key，用来表示临时身份，1个月才会过期
    //登陆时 session 中有用户信息，可以直接用
    //没登录时按照cookie中存放的 user-key 来表示身份，第一次进入该网站时会自动分配一个user-key
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        UserInfoTo currentUser = new UserInfoTo();
        //此处可能报错（com.example.common.vo.MemberRespVo cannot be cast to com.example.common.vo.MemberRespVo）因此采用这种方式转化
        MemberRespVo loginUser = JSON.parseObject(JSON.toJSONString(request.getSession().getAttribute(AuthServerConstant.LOGIN_USER)), MemberRespVo.class);
        if (loginUser != null) {
            //用户已经登录，则放入当前登录 user 信息
            currentUser.setUserId(currentUser.getUserId());
        }
        //用户未登录，则放入 user-key 信息
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (Cookie cookie : cookies) {
                String name = cookie.getName();
                if (name.equals(CartConstant.TEMP_USER_COOKIE_NAME)) {
                    currentUser.setUserKey(cookie.getValue());
                }
            }
        }
        if (StringUtils.isEmpty(currentUser.getUserKey())) {
            //没有临时用户就直接分配一个临时用户
            currentUser.setUserKey(UUID.randomUUID().toString());
        }
        threadLocal.set(currentUser);   //将当前网站使用用户放入共享空间
        return true;    //全部放行：登录用户或是临时用户都是可以操作购物车
    }

    @Override   //拦截器拦截功能提取cookie之后，需要设置 user-key 到 cookie 中，并设置过期时间
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        UserInfoTo userInfo = threadLocal.get();
        if (userInfo.getUserKey() == null) {    //没有临时用户 user-key 则需要手动添加一个
            Cookie cookie = new Cookie(CartConstant.TEMP_USER_COOKIE_NAME, userInfo.getUserKey());
            cookie.setMaxAge(60*60*24*30);      //设置过期时间1个月
            cookie.setDomain("moonshop.com");   //设置cookie作用域
            response.addCookie(cookie);
        }
    }
}
```

那么拦截器拦截请求并将用户信息(登录用户或是临时用户)放入 `ThreadLocal` 中，从而达到在后面的 controller 或是其他同线程类中仍然能够取出。

> `ThreadLocal<Thread, Object> 实际上是一个 Map，实现线程内的资源共享`，而拦截器 -> controller -> service -> dao 整个流程就是在一个线程进行执行的。

同时需要将自定义的拦截器组件放入到配置中：

```java
@Configuration
public class MyWebConfig implements WebMvcConfigurer {
    
    @Override   //向 web 容器中添加拦截器组件:拦截所有请求
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new CartInterceptor()).addPathPatterns("/**");
    }
}
```

5、修改原先的前端代码，打通前端代码的页面跳转逻辑。

### 购物项添加

cart服务中主体接收请求逻辑实现：

```java
/**
 * CartController:添加商品到购物车
 * @return 页面跳转
 */
@GetMapping("/addToCart")
public String addToCart(@RequestParam("skuId") Long skuId,
                        @RequestParam("skuNum") Integer skuNum,
                        RedirectAttributes redirectAttributes) throws ExecutionException, InterruptedException {
    cartService.addToCart(skuId, skuNum);
    redirectAttributes.addAttribute("skuId", skuId);
    return "redirect:http://cart.moonshop.com/addToCartSuccess.html";
}

//采用重定向的方式避免重复提交：京东也是这种方式，相当于不是重复提交更新，而是重复查询而已
@GetMapping("/addToCartSuccess.html")
public String addToCartSuccessPage(@RequestParam("skuId") Long skuId, Model model){
    //重定向时采用再查询一次而不是不停提交的方式
    CartItem cartItem = cartService.getCartItem(skuId);
    model.addAttribute("item", cartItem);
    return "success";
}

/**
 * CartServiceImpl：实现购物车内购物项的添加，需要区分原来的购物车中是否已经存在该商品
 * @param skuId 商品id
 * @param skuNum 商品数量
 * @return 添加的购物项
 */
@Override
public CartItem addToCart(Long skuId, Integer skuNum) throws ExecutionException, InterruptedException {
    //1.获取要操作的购物车 redis-hash
    BoundHashOperations<String, Object, Object> redisHashOperations = getRedisHashOperations();
    String res = (String) redisHashOperations.get(skuId.toString());
    if (StringUtils.isEmpty(res)) {     //购物车当前没有这个商品
        CartItem cartItem = new CartItem();
        //2.任务一：调用远程 product 服务，查询商品信息封装到返回结果集
        CompletableFuture<Void> skuInfoFuture = CompletableFuture.runAsync(() -> {
            R skuInfoStatus = productFeignService.info(skuId);
            SkuInfoTo skuInfo = skuInfoStatus.getData("skuInfo", new TypeReference<SkuInfoTo>() {
            });
            cartItem.setCheck(true);
            cartItem.setCount(skuNum);
            cartItem.setImage(skuInfo.getSkuDefaultImg());
            cartItem.setPrice(skuInfo.getPrice());
            cartItem.setTitle(skuInfo.getSkuTitle());
            cartItem.setSkuId(skuId);
        }, threadPool);

        //3.任务二：调用远程 product 服务，查询属性信息封装到返回结果集
        CompletableFuture<Void> skuAttrValuesFuture = CompletableFuture.runAsync(() -> {
            List<String> skuSaleAttrs = productFeignService.getSkuSaleAttrValues(skuId);
            cartItem.setSkuAttr(skuSaleAttrs);
        });

        CompletableFuture.allOf(skuInfoFuture, skuAttrValuesFuture).get();

        //4.将购物车信息存入 Redis,值采用 Json 序列化方式
        redisHashOperations.put(skuId.toString(), JSON.toJSONString(cartItem));
        return cartItem;
    } else {    //购物车当前已经有这个商品，修改数量即可
        CartItem cartItem = JSON.parseObject(res, CartItem.class);
        cartItem.setCount(cartItem.getCount() + skuNum);
        redisHashOperations.put(skuId.toString(), JSON.toJSONString(cartItem));
        return cartItem;
    }
}

@Override   //获取购物车中的某个购物项
public CartItem getCartItem(Long skuId) {
    BoundHashOperations<String, Object, Object> redisHashOperations = getRedisHashOperations();
    String cartItemString = (String) redisHashOperations.get(skuId.toString());
    return JSON.parseObject(cartItemString, CartItem.class);
}

//controller 内部方法：获取到我们要操作的购物车
public BoundHashOperations<String, Object, Object> getRedisHashOperations(){
    //1.得到用户信息，从而判断该商品应该放入哪个购物车（离线？在线？）
    UserInfoTo currentUser = CartInterceptor.threadLocal.get();
    String cartKey = "";
    if (currentUser.getUserId() != null) {
        //在线购物车: moonshop:cart:1
        cartKey = CartConstant.CART_PREFIX + currentUser.getUserId();
    } else {
        //临时购物车: moonshop:cart:user-key
        cartKey = CartConstant.CART_PREFIX + currentUser.getUserKey();
    }
    //2.判断当前购物车是否有该商品，以此判断更新还是新增
    BoundHashOperations<String, Object, Object> operations = redisTemplate.boundHashOps(cartKey);//绑定当前key
    return operations;
}
```

1）增加购物车常量表示：

```java
//配置常量表示购物车商品前缀，用来表示临时？在线？购物车
public static final String CART_PREFIX = "moonshop:cart:";
```

2）封装临时 skuInfo 信息的To，实际就是原来的 SkuInfoEntity 实体类。

```java
@Data
@ToString
public class SkuInfoTo {
    private Long skuId;
    private Long spuId;
    private String skuName;
    private String skuDesc;
    private Long catalogId;
    private Long brandId;
    private String skuDefaultImg;
    private String skuTitle;
    private String skuSubtitle;
    private BigDecimal price;
    private Long saleCount;
}
```

3）考虑到需要连续多个远程调用，那么就考虑使用异步线程编排，就需要配置线程池相关：

```java
@Configuration
public class ShopThreadConfig {

    @Bean
    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {
        return new ThreadPoolExecutor(pool.getCoreSize(), pool.getMaxSize(), pool.getKeepAliveTime(),
                                      TimeUnit.SECONDS,
                                      new LinkedBlockingDeque<>(100000), 
                                      Executors.defaultThreadFactory(),
                                      new ThreadPoolExecutor.AbortPolicy());
    }
}
```

```java
//动态配置线程池
@ConfigurationProperties(prefix = "shop.thread")
@Component
@Data
@Primary    //@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的 Bean 将作为首选者，否则将抛出异常。
public class ThreadPoolConfigProperties {
    private Integer coreSize;
    private Integer maxSize;
    private Integer keepAliveTime;
}
```

```yml
shop: 
  thread: 
    core-size: 20
    max-size: 200
    keep-alive-time: 10
```

4）远程调用 product 内部的方法：

```java
@FeignClient("shop-product")
public interface ProductFeignService {

    @RequestMapping("/product/skuinfo/info/{skuId}")
    R info(@PathVariable("skuId") Long skuId);

    @GetMapping("/product/skusaleattrvalue/stringList/{skuId}")
    List<String> getSkuSaleAttrValues(@PathVariable("skuId") Long skuId);
}
```

```java
@GetMapping("/stringList/{skuId}")  //得到销售属性并以字符串形式存储
public List<String> getSkuSaleAttrValues(@PathVariable("skuId") Long skuId) {
    return skuSaleAttrValueService.getSkuSaleAttrValuesAsStringList(skuId);
}

@Override
public List<String> getSkuSaleAttrValuesAsStringList(Long skuId) {
    return this.baseMapper.getSkuSaleAttrValuesAsStringList(skuId);;
}

List<String> getSkuSaleAttrValuesAsStringList(@Param("skuId") Long skuId);
```

```xml
<select id="getSkuSaleAttrValuesAsStringList" resultType="java.lang.String">
    select concat(attr_name, ":", attr_value)
    from pms_sku_sale_attr_value
    where sku_id = #{skuId}
</select>
```

### 购物项列表

```java
@GetMapping("/cartList.html")
public String cartListPage(Model model) throws ExecutionException, InterruptedException {
    Cart cart = cartService.getCart();
    model.addAttribute("cart", cart);
    return "cartList";
}

@Override
public Cart getCart() throws ExecutionException, InterruptedException {
    Cart cart = new Cart();
    //1.判断当前是在线还是离线购物车
    UserInfoTo currentUser = CartInterceptor.threadLocal.get();
    if (currentUser.getUserId() != null) {
        //登陆状态：在线购物车，需要将离线购物车中的内容合并到在线购物车
        String cartKey = CartConstant.CART_PREFIX + currentUser.getUserId();
        List<CartItem> tempCartItems = getCartItems(CartConstant.CART_PREFIX + currentUser.getUserKey());
        if (tempCartItems != null) {    //获取临时购物车数据进行合并到登录用户的购物车
            for (CartItem tempCartItem : tempCartItems) {
                this.addToCart(tempCartItem.getSkuId(), tempCartItem.getCount());
            }
            //清除离线购物车中的数据项
            this.clearCart(CartConstant.CART_PREFIX + currentUser.getUserKey());
        }
        //获取登陆后的购物项添加到 Redis 购物车选项
        List<CartItem> cartItems = this.getCartItems(cartKey);
        cart.setItems(cartItems);
    } else {
        //未登陆状态：离线购物车(获取临时购物车的购物项)
        String cartKey = CartConstant.CART_PREFIX + currentUser.getUserKey();
        List<CartItem> cartItems = this.getCartItems(cartKey);
        cart.setItems(cartItems);
    }
    return cart;
}

//获取购物车里面的购物项
public List<CartItem> getCartItems(String cartKey) {
    BoundHashOperations<String, Object, Object> operations = redisTemplate.boundHashOps(cartKey);
    List<Object> values = operations.values();
    List<CartItem> cartItemList = new ArrayList<>();
    if (values != null && values.size() > 0) {
        cartItemList = values.stream().map((obj) -> {
            return JSON.parseObject((String) obj, CartItem.class);
        }).collect(Collectors.toList());
    }
    return cartItemList;
}

@Override
public void clearCart(String cartKey){
    redisTemplate.delete(cartKey);
}
```

### 购物项更新

购物车列表涉及到购物项的数量和选中状态的更新，也是需要发送请求到 redis 进行修改：

```java
/**
 * CartController:勾选购物项状态的修改
 * @return 页面跳转
 */
@GetMapping("/checkItem")
public String checkItem(@RequestParam("skuId") Long skuId,
                        @RequestParam("check") Integer check) {
    cartService.checkItem(skuId, check);
    return "redirect:http://cart.moonshop.com/cartList.html";
}

@Override
public void checkItem(Long skuId, Integer check) {
    BoundHashOperations<String, Object, Object> redisHashOperations = this.getRedisHashOperations();
    CartItem cartItem = this.getCartItem(skuId);
    cartItem.setCheck(check == 1);
    redisHashOperations.put(skuId.toString(), JSON.toJSONString(cartItem));
}

/**
 * CartController:控制某个购物项的增减
 * @param skuId skuId
 * @param skuNum skuNum
 * @return 页面跳转
 */
@GetMapping("/countItem")
public String countItem(@RequestParam("skuId") Long skuId,
                        @RequestParam("skuNum") Integer skuNum) {
    cartService.changeItemCount(skuId, skuNum);
    return "redirect:http://cart.moonshop.com/cartList.html";
}

@Override
public void changeItemCount(Long skuId, Integer skuNum) {
    BoundHashOperations<String, Object, Object> redisHashOperations = this.getRedisHashOperations();
    CartItem cartItem = this.getCartItem(skuId);
    cartItem.setCount(skuNum);
    redisHashOperations.put(skuId.toString(), JSON.toJSONString(cartItem));
}
```

### 购物项删除

```java
@GetMapping("/deleteItem")
public String deleteItem(@RequestParam("skuId") Long deleteId) {
    cartService.deleteItem(deleteId);
    return "redirect:http://cart.moonshop.com/cartList.html";
}

@Override
public void deleteItem(Long deleteId) {
    BoundHashOperations<String, Object, Object> redisHashOperations = this.getRedisHashOperations();
    redisHashOperations.delete(deleteId.toString());
}
```
