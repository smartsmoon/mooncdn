---
title: 谷粒商城-前端开发技术
type:
comments:
tags: 
  - 分布式
  - 微服务
  - 前端技术
  - Vue
  - Node
categories: 
  - 项目练习
description: 
keywords: 前端技术
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## ES6 基本语法

​	`ECMAScript 6.0`（以下简称ES6，ECMAScript 是一种由Ecma国际通过ECMA-262标准化的脚本），是 JavaScript 语言的一代标准，2015年6月正式发布，从 ES6 开始的版本号采用年号，如 ES2015，就是 ES6。ES2016 就是 ES7。ECMAScript 是浏览器脚本语言的规范，JS 的规范的具体实现。

### let 和 const 使用

1、var 声明的变量往往会越域，let 声明的变量有严格局部作用域。

```js
{
    var a = 1;
    let b = 2;
}
console.log(a);  // 正常输出 1
console.log(b);  // 报错：ReferenceError: b is not defined
```

2、var 可以声明多次，let 只能声明一次。

```js
var m = 1
var m = 2
let n = 3
let n = 4
console.log(m)  // 正常输出 2
console.log(n)  // 报错：Identifier 'n' has already been declared
```

3、var 存在变量提升，let 不存在变量提升。

```js
console.log(x);  //不会报错，而是打印 undefined
var x = 10;
console.log(y);   //直接报错：ReferenceError: y is not defined
let y = 20;
```

4、const 声明变量之后不允许改变，同时一但声明必须初始化，否则会报错。

```js
const a = 1;
a = 3; //报错 Uncaught TypeError: Assignment to constant variable.
```

### 解构表达式

数组解构：

```js
let arr = [1,2,3];
//原来的方式
let a = arr[0];
let b = arr[1];
let c = arr[2];
//数组解构的方式写法
let [a,b,c] = arr;
console.log(a,b,c)
```

对象解构：

```js
const person = {
    name: "jack",
    age: 21,
    language: ['java', 'js', 'css']
}
// 原来的写法
const name = person.name;
const age = person.age;
const language = person.language;

// 对象解构写法
const { name, age, language } = person;
const { name: abc, age, language } = person;
console.log(name, age, language)
console.log(abc, age, language)
```

### 字符串扩展

字符串扩展的 API：

```js
let str = "hello.vue";
console.log(str.startsWith("hello"));	//true
console.log(str.endsWith(".vue"));	//true
console.log(str.includes("e"));	//true
console.log(str.includes("hello"));	//true
```

字符串模板使用：多行字符串的使用，拒绝拼串。

```js
let ss = `<div>
              <span>hello world<span>
          </div>`;
console.log(ss);
```

字符串插入变量和表达式：变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。

```js
function fun() {
    return "这是一个函数";
}
let info = `我是${name}，今年${age + 10}了, 我想说： ${fun()}`;
console.log(info);
```

### 函数优化

默认值设置优化：

```js
//在 ES6 以前，我们无法给一个函数参数设置默认值，只能采用变通写法：
function add(a, b) {
    // 判断b是否为空，为空就给默认值 1
    b = b || 1;
    return a + b;
}
// 传一个参数
console.log(add(10));

//ES6 之后可以这么写：直接给参数写上默认值，没传就会自动使用默认值
function add2(a, b = 1) {
    return a + b;
}
console.log(add2(20));
```

函数不定参数优化：

```js
function fun(...values) {
    console.log(values.length)
}
fun(1, 2)      //2
fun(1, 2, 3, 4)  //4
```

箭头函数使用：

```js
// 以前声明一个方法
var print = function (obj) {
    console.log(obj);
}
//箭头函数写法
var print = obj => console.log(obj);
print("hello");

//多个参数的情况
var sum2 = (a, b) => a + b;
console.log(sum2(11, 12));

//方法体多行的情况
var sum3 = (a, b) => {
    c = a + b;
    return a + c;
}
console.log(sum3(10, 20))

//箭头函数+解构表达式的情况
var hello2 = ({name}) => console.log("hello," +name);
hello2(person);
```

### 对象优化

新增的对象 API ：

```js
const person = {
    name: "jack",
    age: 21,
    language: ['java', 'js', 'css']
}

//获取 key 数组
console.log(Object.keys(person));	//["name", "age", "language"]
//获取 value 数组
console.log(Object.values(person));	//["jack", 21, Array(3)]
//获取 key:value 数组
console.log(Object.entries(person));	//[Array(2), Array(2), Array(2)]

const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
//assign方法用于合并对象，{a:1,b:2,c:3}
Object.assign(target, source1, source2);
```

声明对象的简写方式：

```js
const age = 23
const name = "张三"
// 传统方式声明对象
const person1 = { age: age, name: name }
// 声明对象简写方式：如果属性名和变量名一致那么就可以简写
const person2 = { age, name }
console.log(person2);

// 对象的函数属性简写
let person3 = {
    name: "jack",
    // 传统方式定义对象内函数：
    eat: function (food) {
        console.log(this.name + "在吃" + food);
    },
    // 箭头函数中 this 不能使用，主要是因为this指代对象发生变化，应该使用 对象.属性 方式来取值
    eat2: food => console.log(person3.name + "在吃" + food),
    // 简写方式来定义函数
    eat3(food) {
        console.log(this.name + "在吃" + food);
    }
}
person3.eat("香蕉");
person3.eat2("苹果")
person3.eat3("橘子");
```

对象的扩展运算符：

```js
//  ... 用于拷贝对象（深拷贝）
let p1 = { name: "Amy", age: 15 }
let someone = { ...p1 }
console.log(someone)  	//{name: "Amy", age: 15}

//  ... 用于合并多个对象，后面定义的值会覆盖之前的值
let age1 = { age: 15 }
let name1 = { name: "Amy" }
let p2 = {name:"zhangsan"}
p2 = { ...age1, ...name1 } 
console.log(p2)
```

### Map 和 Reduce

​	数组新增 map 和 reduce 的方法，其中 `map()` 用于接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回；`reduce()` 用于为数组中的每一个元素依次执行回调函数（也就是说可以用到上一步的处理结果），不包括数组中被删除或从未被赋值的元素。

```js
// map 方法：
arr = arr.map((item)=>{
    return item*2
});
console.log(arr);
arr = arr.map(item=> item*2);
console.log(arr);

/* reduce 方法语法：arr.reduce(callback,[initialValue])
reduce 的回调函数的四个可选参数：
1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
2、currentValue （数组中当前被处理的元素）
3、index （当前元素在数组中的索引）
4、array （调用 reduce 的数组）
*/
let result = arr.reduce((a,b)=>{
    console.log("上一次处理后："+a);
    console.log("当前正在处理："+b);
    return a + b;
},100);
console.log(result)
```

### Promise 处理

​	Promise 主要是为了优化异步请求处理（`封装异步操作`），特别体现在 ajax 的嵌套使用上的优化。

Promise 初始化语法：

```js
let promise = new Promise((resolve, reject) => {
    //成功了调用 resolve 将数据返回给 promise，从而继续进行操作
    //失败了调用 reject 将失败信息返回给 promise，从而继续进行操作
})
//如果成功了调用了 resolve，那么就会调用 then，而参数就是 resolve 传递过来的参数,失败了就会调用 catch，参数是 reject 传递过来的参数
p.then((data) => {

}).catch((error) => {

})
```

`[案例]` 嵌套查询案例举例：查出当前用户信息，再按照当前用户的 id 查出他的课程，再按照当前课程 id 查出分数。

1、模拟数据：三个 json 文件用来模拟 ajax 请求的数据。

```json
course_score_10.json 得分
{
    "id": 100,
    "score": 90
}

user.json 用户
{
    "id": 1,
    "name": "zhangsan",
    "password": "123456"
}

user_course_1.json 课程
{
    "id": 10,
    "name": "chinese"
}
```

2、利用 ajax 模拟请求数据：

1）原始嵌套方法：

```js
<script>
    $.ajax({
        url: "mock/user.json",
        success(data) {
            console.log("查询用户：", data);
            $.ajax({
                url: `mock/user_course_${data.id}.json`,
                success(data) {
                    console.log("查询到课程：", data);
                    $.ajax({
                        url: `mock/course_score_${data.id}.json`,
                        success(data) {
                            console.log("查询到分数：", data);
                        },
                        error(error) {
                            console.log("出现异常了：" + error);
                        }
                    });
                },
                error(error) {
                    console.log("出现异常了：" + error);
                }
            });
        },
        error(error) {
            console.log("出现异常了：" + error);
        }
    });
</script> 
```

2）使用 Promise 进行异步请求。

```js
<script>
    let p = new Promise((resolve, reject) => { //传入成功解析，失败拒绝
        //1、异步操作
        $.ajax({
            url: "mock/user.json",
            success: function (data) {
                console.log("查询用户成功:", data)
                resolve(data);
            },
            error: function (err) {
                reject(err);
            }
        });
    });

    //成功以后做什么
    p.then((obj) => { 
        //继续封装一个 Promise 对象返回，方便后面继续利用
        return new Promise((resolve, reject) => {
            $.ajax({
                url: `mock/user_course_${obj.id}.json`,
                success: function (data) {
                    console.log("查询用户课程成功:", data)
                    resolve(data);
                },
                error: function (err) {
                    reject(err)
                }
            });
        })
    }).then((data) => { 
        //成功以后干什么，最后一步结果就不需要封装 Promise 对象了
        console.log("上一步的结果", data)
        $.ajax({
            url: `mock/course_score_${data.id}.json`,
            success: function (data) {
                console.log("查询课程得分成功:", data)
            },
            error: function (err) {
            }
        });
    })
</script>
```

3）进一步优化：继续抽取一个方法，用于发起请求

```js
<script>
    function get(url, data) {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: url,
                data: data,
                success: function (data) {
                    resolve(data);
                },
                error: function (err) {
                    reject(err)
                }
            })
        });
	}
	get("mock/user.json")
        .then((data) => {
            console.log("用户查询成功~~~:", data)
            return get(`mock/user_course_${data.id}.json`);
    	})
        .then((data) => {
            console.log("课程查询成功~~~:", data)
            return get(`mock/course_score_${data.id}.json`);
    	})
        .then((data)=>{
        	console.log("课程成绩查询成功~~~:", data)
    	})
        .catch((err)=>{ 
        	console.log("出现异常",err)
    	});
</script>
```

### 模块化

​	模块化就是把代码进行拆分，方便重复利用，类似于 Java 中的导包， 而 JS 换了个概念，是导模块，模块功能主要由两个命令构成：`export` 和 `import` 。

1）export 用于规定模块的对外接口（导出）：`export`不仅可以导出对象，一切 JS 变量都可以导出，比如：基本类型变量、函数、数组、对象。

2）import 用于导入其他模块提供的功能（导入）

`[案例]` 想在 main.js 中使用 hello.js 中的东西。

1）hello.js 导出：

```js
var name = "jack"
var age = 21
const util = {
    sum(a, b) {
        return a + b;
    }
}
export {util, name, age}
//也可以直接简写
export default {
    sum(a, b) {
        return a + b;
    }
}
```

2）main.js 导入：

```js
import {util, name, age} from "./hello.js"
```

## Vue 回顾

Vue 的核心就是 `MVVM 思想`：M 就是 Model 包括数据和一些基本操作，V 就是 View 视图，主要是页面渲染结果，VM 就是 View-model，模型与视图间的双向操作（这部分无需开发人员干涉，内部实现）。视图和数据通过 VM 绑定起来，model 里有变化会自动地通过 Directives 填写到视 view 中，视图表单中添加了内容也会自动地通过 DOM Listeners 保存到模型中。

### 基础案例

1、创建文件夹 VUE2，通过 VsCode 打开，在此文件夹下打开终端，执行 `npm init -y` 出现 `package.json` 文件，表示初始化了一个 npm 项目。

2、终端执行 `npm install vue@2.6.12` 安装 vue。

3、基本使用：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <!-- v-model 双向绑定 -->
        <input type="text" v-model="num">
        <!-- 声明式渲染 -->
        <h1>{{name}}, 非常帅,{{num}} 点赞</h1>
        <!-- v-xx 就是指令 -->
        <button v-on:click="num++">点赞</button>
        <button v-on:click="cancelClick">取消点赞</button>
    </div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        // 创建 vue 实例，关联到页面的模板
        let vm = new Vue({
            el: "#app",
            data: {
                name: "张三",
                num: 1
            },
            methods: {
                cancelClick(){
                    console.log("取消点赞");
                    this.num--;
                }
            },
        })
    </script>
</body>
</html>
```

### 基本指令

1、v-html 和 v-text 的区别：`v-html` 会解析标签，而不会进行转义为字符串输出。`v-text` 会进行转义，原样字符串输出。

2、插值表达式：必须有一个返回值，可以直接使用定义好的变量值，甚至函数也可以直接调用，但`插值表达式只能使用在标签体`。

3、v-bind 单向绑定：用于给属性绑定值。

```html
<!-- class,style  {class名：加上？}-->
<span 
      v-bind:class="{active:isActive,'text-danger':hasError}" 
      :style="{color: color1,fontSize: size}">
    你好
</span>
```

4、v-model 双向绑定：数据区和绑定的位置同时变化。

```html
<div id="app">
    精通的语言：
    <input type="checkbox" v-model="language" value="Java"> java<br/>
    <input type="checkbox" v-model="language" value="PHP"> PHP<br/>
    <input type="checkbox" v-model="language" value="Python"> Python<br/>
    选中了 {{language.join(",")}}
</div>
```

5、v-on 绑定事件：

```html
<div id="app">
    <!--事件中直接写js片段-->
    <button v-on:click="num++">点赞</button>
    <!--事件指定一个回调函数，必须是Vue实例中定义的函数-->
    <button @click="cancel">取消</button>
    <!--  -->
    <h1>有{{num}}个赞</h1>
</div>
```

为了`防止事件冒泡`，vue 还具有`事件修饰符机制`：也就是调用在点击事件的后面加上修饰符。

1）`stop`：阻止事件冒泡到父元素。

2）`prevent`：阻止默认事件发生。

3）`capture`：使用事件捕获模式。

4）`self`：只有元素自身触发才执行，也就是说冒泡或捕获的都不执行。

5）`once`：只执行一次。

```html
<div style="border: 1px solid red;padding: 20px;" v-on:click.once="hello">
    大div
    <div style="border: 1px solid blue;padding: 20px;" @click.stop="hello">
        小div <br />
        <a href="http://www.baidu.com" @click.prevent.stop="hello">去百度</a>
    </div>
</div>
```

同时针对键盘的操作，vue 也提供了`按键修饰符`，并支持多建操作。

```html
<input type="text" v-model="num" v-on:keyup.up="num+=2" @keyup.down="num-=2" @click.ctrl="num=10">
```

6、v-for 用于遍历循环，一般就是用于表格或菜单这种情况的数据遍历显示。

```html
<body>

    <div id="app">
        <ul>
            <li v-for="(user,index) in users" :key="user.name">
                <!-- 1、显示user信息：v-for="item in items" -->
               当前索引：{{index}} ==> {{user.name}}  ==>   {{user.gender}} ==>{{user.age}} <br>
                <!-- 2、获取数组下标：v-for="(item,index) in items" -->
                <!-- 3、遍历对象：
                        v-for="value in object"
                        v-for="(value,key) in object"
                        v-for="(value,key,index) in object" 
                -->
                对象信息：
                <span v-for="(v,k,i) in user">{{k}}=={{v}}=={{i}}；</span>
                <!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 -->
            </li> 
        </ul>
        <ul>
            <!-- 利用索引进行区分 -->
            <li v-for="(num,index) in nums" :key="index"></li>
        </ul>
    </div>
    <script src="../node_modules/vue/dist/vue.js"></script>
    <script>         
        let app = new Vue({
            el: "#app",
            data: {
                users: [{ name: '柳岩', gender: '女', age: 21 },
                { name: '张三', gender: '男', age: 18 },
                { name: '范冰冰', gender: '女', age: 24 },
                { name: '刘亦菲', gender: '女', age: 18 },
                { name: '古力娜扎', gender: '女', age: 25 }],
                nums: [1,2,3,4,4]
            },
        })
    </script>
</body>
```

7、v-if 和 v-show：都是用于条件判断，v-if 是结果为 true 时，所在的元素才会被渲染。而 v-show 是结果为 true 时，所在的元素才会被显示，其不显示的情况实际是利用 `display=none` 来实现，也就是说 v-show 的元素即使不显示这个元素也是存在的。

```html
<div id="app">
    <button v-on:click="show = !show">点我呀</button>
    <!-- 1、使用v-if显示 -->
    <h1 v-if="show">if=看到我....</h1>
    <!-- 2、使用v-show显示 -->
    <h1 v-show="show">show=看到我</h1>
</div>
```

v-else 和 v-else-if 是和 v-if 一起使用，用于连续判断条件。

### 计算属性和监听器

`[案例]` 模拟购物车计算总价。

```html
<body>
    <div id="app">
        <!-- 某些结果是基于之前数据实时计算出来的，我们可以利用计算属性。来完成 -->
        <ul>
            <li>西游记； 价格：{{xyjPrice}}，数量：<input type="number" v-model="xyjNum"> </li>
            <li>水浒传； 价格：{{shzPrice}}，数量：<input type="number" v-model="shzNum"> </li> 
            <li>总价：{{totalPrice}}</li>
            {{msg}}
        </ul>
    </div>
    <script src="../node_modules/vue/dist/vue.js"></script>

    <script>
        new Vue({
            el: "#app",
            data: {
                xyjPrice: 99.98,
                shzPrice: 98.00,
                xyjNum: 1,
                shzNum: 1,
                msg: ""
            }
        })
    </script>

</body>
```

1）计算总价使用计算属性：使用 computed 表示动态计算属性，但是一般需要声明成一个方法。

```js
computed: {
    totalPrice(){
        return this.xyjPrice * this.xyjNum + this.shzPrice * this.shzNum
    }
},
```

2）监听数量使用监听器：使用 watch 可以监控某个属性，当发生变化时就会触发监听器。

```js
watch: {
    xyjNum(newVal,oldVal){
        if(newVal >= 3){
            this.msg = "库存超出限制";
            this.xyjNum = 3
        }else{
            this.msg = "";
        }
    }
},
```

### 过滤器

过滤器常用来处理文本格式化的操作，可以用在两个地方：`双花括号插值表达式`和 `v-bind 表达式`中。

```html
<body>
    <!-- 过滤器常用来处理文本格式化的操作。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 -->
    <div id="app">
        <ul>
            <li v-for="user in userList">
                <!-- 原始方法：使用三元运算符 -->
                {{user.id}} ==> {{user.name}} ==> {{user.gender == 1?"男":"女"}} 
                =============
                <!-- 使用局部过滤器 -->
                {{user.gender | genderFilter}} 
                ============= 
                <!-- 使用全局过滤器 -->
                {{user.gender | gFilter}}
            </li>
        </ul>
    </div>
    <script src="../node_modules/vue/dist/vue.js"></script>
    <script>
	   // 全局过滤器
        Vue.filter("gFilter", function (val) {
            if (val == 1) {
                return "男~~~";
            } else {
                return "女~~~";
            }
        })

        let vm = new Vue({
            el: "#app",
            data: {
                userList: [
                    { id: 1, name: 'jacky', gender: 1 },
                    { id: 2, name: 'peter', gender: 0 }
                ]
            },
            filters: {
                // filters 定义局部过滤器，只可以在当前 vue 实例中使用
                genderFilter(val) {
                    if (val == 1) {
                        return "男";
                    } else {
                        return "女";
                    }
                }
            }
        })
    </script>
</body>
```

### 组件化

​	在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分，例如可能会有相同的头部导航。但是如果每个页面都自开发，这无疑增加了我们开发的成本。所以我们会把页面的相同部分拆分成组件，然后在不同页面就可以共享这些组件，避免重复开发。

​	在 vue 里，所有的 vue 实例都是组件，组件其实也是一个 vue 实例，因此它在定义时也会接收：data、methods、生命周期函等，不同的是`组件不会与页面的元素綁定`，否则就无法复用了，因此`没有 el 属性`。但是`组件渲染需要 html 模板，所以增加了 template 属性`，值就是 HTML 模板，全局组件定义完毕，任何 vue 实例都可以直接在 HTML 中通过组件名称来使用组件，

注意： `data 必须是一个函数，不再是一个对象`。

```html
<body>
    <div id="app">
        <button v-on:click="count++">我被点击了 {{count}} 次</button>
        
        <counter></counter>
        <counter></counter>
        <counter></counter>
        <counter></counter>
        <counter></counter>
        <button-counter></button-counter>
    </div>
    <script src="../node_modules/vue/dist/vue.js"></script>
    <script>
        //1、全局声明注册一个组件
        Vue.component("counter", {
            template: `<button v-on:click="count++">我被点击了 {{count}} 次</button>`,
            data() {
                return {
                    count: 1
                }
            }
        });

        //2、局部声明一个组件，其实就是一个常规对象，只需要放入 components 属性中就定义了局部组件
        const buttonCounter = {
            template: `<button v-on:click="count++">我被点击了 {{count}} 次~~~</button>`,
            data() {
                return {
                    count: 1
                }
            }
        };

        new Vue({
            el: "#app",
            data: {
                count: 1
            },
            components: {
                'button-counter': buttonCounter
            }
        })
    </script>
</body>
```

### 生命周期和钩子函数

​	生命周期实际就是 vue 对象的过程，在这个过程中不同阶段会触发不同的函数。

![](https://ask.qcloudimg.com/http-save/yehe-1690162/7kz1zfx9yo.png?imageView2/2/w/1620)

生命周期和钩子函数不同阶段触发案例：

```html
<body>
    <div id="app">
        <span id="num">{{num}}</span>
        <button @click="num++">赞！</button>
        <h2>{{name}}，有{{num}}个人点赞</h2>
    </div>

    <script src="../node_modules/vue/dist/vue.js"></script>
    
    <script>
        let app = new Vue({
            el: "#app",
            data: {
                name: "张三",
                num: 100
            },
            methods: {
                show() {
                    return this.name;
                },
                add() {
                    this.num++;
                }
            },
            beforeCreate() {
                console.log("=========beforeCreate=============");
                console.log("数据模型未加载：" + this.name, this.num);
                console.log("方法未加载：" + this.show());
                console.log("html模板未加载：" + document.getElementById("num"));
            },
            created: function () {
                console.log("=========created=============");
                console.log("数据模型已加载：" + this.name, this.num);
                console.log("方法已加载：" + this.show());
                console.log("html模板已加载：" + document.getElementById("num"));
                console.log("html模板未渲染：" + document.getElementById("num").innerText);
            },
            beforeMount() {
                console.log("=========beforeMount=============");
                console.log("html模板未渲染：" + document.getElementById("num").innerText);
            },
            mounted() {
                console.log("=========mounted=============");
                console.log("html模板已渲染：" + document.getElementById("num").innerText);
            },
            beforeUpdate() {
                console.log("=========beforeUpdate=============");
                console.log("数据模型已更新：" + this.num);
                console.log("html模板未更新：" + document.getElementById("num").innerText);
            },
            updated() {
                console.log("=========updated=============");
                console.log("数据模型已更新：" + this.num);
                console.log("html模板已更新：" + document.getElementById("num").innerText);
            }
        });
    </script>
</body>
```

























