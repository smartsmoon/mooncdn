---
title: 谷粒商城-订单服务实现
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringCloud
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## 消息队列简述

消息队列主要作用：异步通信、应用解耦、流量控制(流量削峰)，本次项目采用 `RabbitMQ 消息队列` ，可实现单播、组播、广播模式。

> 马晓飞(腾讯云)服务器：IP：124.221.230.10   	user：maxiaofei 		密码：19971005mxf

Docker 安装 RabbitMQ 消息队列：

```shell
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management
docker update rabbitmq --restart=always		# 设置自动重启
```

`15672` 端口就是 web 可视化服务端口，访问 `124.221.230.10:15672` ，默认账号和密码都是 `guest` 。

1、引入 amqp 场景依赖，就会给容器中自动配置：`CachingConnectionFactory(连接工厂)`、`RabbitTemplate(rabbit 操作模板)`、`AmqpAdmin（amqp管理组件）` 以及 `RabbitMessagingTemplate`。

```xml
<!-- 引入 amqp 场景 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

2、配置文件配置 RabbitMQ 的连接信息，所有属性都是可以从源码发现如何配置：

```java
@ConfigurationProperties(prefix = "spring.rabbitmq")
public class RabbitProperties{......}
```

也就是需要配置 `spring.rabbitmq`  开头的属性，而具体的可配置项都是从 `RabbitProperties` 中寻找。

```yml
spring: 
    rabbitmq:
        host: 124.221.230.10
        port: 5672  # amqp连接端口，也就是客户端连接的端口
        virtual-host: /   # 指定虚拟主机
```

3、启动类添加 `@EnableRabbit` 注解开启 RabbitMQ 功能。

4、测试创建 Exchange、Queue、Binding 关系，使用 `AmqpAdmin` 操作。

```java
@Autowired
AmqpAdmin amqpAdmin;

@Test   //利用全属性构造器创建直接交换机 Exchange
public void createExchange() {
    //public DirectExchange(String name, boolean durable, boolean autoDelete, Map<String, Object> arguments)
    DirectExchange directExchange = new DirectExchange("hello-java-exchange", true, false, null);
    amqpAdmin.declareExchange(directExchange);
    log.warn("Exchange [{}]创建完成", directExchange);
}


@Test   //利用全属性构造器创建队列
public void createQueue() {
    //public Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments)
    Queue queue = new Queue("hello-java-queue", true, false, false, null);
    amqpAdmin.declareQueue(queue);
    log.warn("Queue [{}]创建完成", queue);
}

@Test   //利用全属性构造器创建Binding
public void createBinding() {
    //public Binding(   将交换机绑定到指定的 destination 交换机/队列上
    //      String destination,     目的地
    //      DestinationType destinationType,    目的地类型(交换机-交换机/队列)
    //      String exchange,    交换机
    //      String routingKey,  路由键
    //      Map<String, Object> arguments   携带自定义参数
    // )
    Binding binding = new Binding("hello-java-queue", Binding.DestinationType.QUEUE, "hello-java-exchange", "hello.java", null);
    amqpAdmin.declareBinding(binding);
    log.warn("绑定{}完成", binding);
}
```

5、测试 RabbitMQ 发送消息，使用 RabbitTemplate 进行操作。

```java
@Autowired
RabbitTemplate rabbitTemplate;

@Test   //测试发送消息
public void sendMessageTest() {
    //void convertAndSend(String exchange, String routingKey, Object message)
    rabbitTemplate.convertAndSend("hello-java-exchange", "hello.java", "hello,world");
    log.warn("消息发送成功......");
}
```

由于发送消息为对象时发现是乱码，实际上这是由于序列化的问题，使用 JDK 自带的序列化并不优秀，考虑使用 Json 序列化方式，因此需要配置：

```java
@Configuration
public class MyRabbitMQConfig {

    @Bean   //消息转换器替代原本的JDK自带序列化方式
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
}
```

6、测试 RabbitMQ 接收消息，实际上就是使用 `@RabbitListener` 注解监听队列的消息。

```java
@Service("orderService")
@RabbitListener(queues = {"hello-java-queue"})
public class OrderServiceImpl extends ServiceImpl<OrderDao, OrderEntity> implements OrderService {

    /**
     * @RabbitListener(queues = {"hello-java-queue"}) 关联需要监听的队列，可标注于 class、method 上。
     * @param message 原生的消息详细信息，包括消息头+消息体
     * @param content 类型为 T ，表示发送消息的类型，content 可以直接表示消息体
     * @param channel 客户端当前传输连接通道，同一个 connection 连接里面的某一个通道
     *
     * 问题：如果有很多个 order 服务都监听了某一个 Queue，那么消息发送后，哪个 order 服务会接收到消息呢？
     * 答案：同一个消息只会被一个客户端收到，当前客户端处理完毕一个消息后才会开始接收下一个消息
     * @RabbitHandler 注解只能标注于 method 上，实际上也能够监听队列，进行消息的接收，但是使用 RabbitHandler 可以用于方法重载来区分不同的消息类型
     * 因此一般将 RabbitListener 标注于类上，RabbitHandler 标注于方法上来一起使用。
     */
    @RabbitHandler
    public void receiveMessage(Object message,
                               OrderReturnReasonEntity content,
                               Channel channel) {
        System.out.println("message = " + message);
        System.out.println("message.getClass() = " + message.getClass());
    }

    @RabbitHandler
    public void receiveMessage(Object message,
                               OrderEntity content,
                               Channel channel) {
        System.out.println("message = " + message);
        System.out.println("message.getClass() = " + message.getClass());
    }
}
```

7、消息的可靠投递从 `发送端` 进行处理：

1）product -> (Broker) Exchange 端时使用 `confirmCallback` 回调函数来`确认消息抵达`交换机时触发。

配置文件中配置，开启发送端确认：

```yml
spring:
  rabbitmq:
    publisher-confirms: true    # 开启消息成功回调
```

定制化 RabbitTemplate ，设置消息成功回调：

```java
@PostConstruct   //定制 RabbitTemplate
public void initRabbitTemplate(){
    
    //设置确认回调机制
    rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
        /**
         * 消息正确抵达 Broker 后就会触发这个回调
         * @param correlationData 当前消息关联的唯一关联数据(消息的唯一id)
         * @param ack 消息是否成功收到
         * @param cause 消息投递失败原因
         */
        @Override
        public void confirm(CorrelationData correlationData, boolean ack, String cause) {
            System.out.println("ConfirmCallback 触发====>correlationData:" + correlationData + "===> ack:" + ack + "===> cause:" + cause);
        }
    });
}
```

`注`：只要消息能够成功抵达 Broker (RabbitMQ 服务器)，那么 ack 就会是 true，表示此阶段消息投递成功。

2）Exchange -> Queue 端时使用 `returnCallback` 回调函数会在`消息未投递到队列`时触发。

配置文件中配置，开启发送端消息抵达队列确认回调：

```yml
spring:
  rabbitmq:
    publisher-returns: true # 开启发送端消息抵达队列回调确认
    template:
      mandatory: true # 只要抵达队列就会以异步方式优先回调 returnConfirm 回调
```

定制化 RabbitTemplate ，设置消息抵达队列确认回调：

```java
@PostConstruct   //定制 RabbitTemplate
public void initRabbitTemplate(){
    
    //设置消息抵达队列失败确认回调机制
    rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
        /**
         * 消息没有抵达指定的队列就会触发这个失败回调
         * @param message 投递失败的消息的详细信息
         * @param replyCode RabbitMQ服务器回复状态码
         * @param replyText RabbitMQ服务器回复的错误信息
         * @param exchange 错误消息发送的指定交换机
         * @param routingKey 错误消息发送的指定路由键
         */
        @Override
        public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
            System.out.println("Fail message = " + message);
        }
    });
}
```

`注`：只要消息能够成功抵达 Broker (RabbitMQ 服务器)，那么 ack 就会是 true，表示此阶段消息投递成功。

8、消息的可靠投递从 `消费端` 进行处理：实际就是通过 `ack 确认机制` 。

默认是自动确认的，确认后就会将消息从队列中移除，这也就导致了当还未成功消费消息时，消息已经直接从队列中移除，因此需要设置 `手动确认机制`：

配置文件设置手动确认开启：

```yml
spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: manual  # 手动确认机制开启
```

而手动确认 ACK 方式就是使用 `channel.basicAck()` 通过通道来实现，同时可以选择批量还是非批量确认，拒绝确认可以使用 `channel.basicNack()` 或是使用 `channel.basicReject()` 来拒绝，<u>都支持设置重新入队</u>，但是 Reject 不能设置批量拒绝。 

## 订单服务

完成静态资源导入，配置 host 域名映射 `order.moonshop.com` ，并按照之前配置进行 SpringSession 相关设置、线程池相关配置、网关相关配置等前置操作。

### 订单确认页面

![在这里插入图片描述](https://img-blog.csdnimg.cn/ba9a7483e16a4c0da6de59ce0653289b.png)

1、由于所有的页面都是需要登陆后才能进行访问的，因此还需要设置登录拦截器（避免 `未登录状态下进行结算`）：

```java
@Component
public class LoginUserInterceptor implements HandlerInterceptor {

    public static ThreadLocal<MemberRespVo> threadLocal = new ThreadLocal<>();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        MemberRespVo loginUser = (MemberRespVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER);
        if (loginUser != null) {
            threadLocal.set(loginUser);
            return true;
        } else {
            request.getSession().setAttribute("msg", "请先进行登录");
            response.sendRedirect("http://auth.moonshop.com/login.html");
            return false;
        }
    }
}
```

```java
@Configuration
public class OrderWebConfig implements WebMvcConfigurer {

    @Autowired
    LoginUserInterceptor loginUserInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginUserInterceptor);
    }
}
```

2、实体类信息封装：

1）页面确认消息的显示实体封装 OrderConfirmVo。

```java
public class OrderConfirmVo {
    //收货地址列表
    @Getter @Setter
    List<MemberAddressVo> address;
    //所有选中的购物项
    @Getter @Setter
    List<OrderItemVo> items;

    //发票记录信息......此处不实现

    //优惠券信息、金豆信息，此处只用积分演示
    @Getter @Setter
    Integer integration;

    //网络过慢情况下防止订单重复提交令牌
    @Getter @Setter
    String orderToken;

    //库存信息字典
    @Getter @Setter
    Map<Long, Boolean> stockMap;

    //获取当前订单商品总额
    public BigDecimal getOrderTotalPrice() {
        BigDecimal sum = new BigDecimal("0");
        if (this.items != null) {
            for (OrderItemVo item : items) {
                sum = sum.add(item.getPrice().multiply(new BigDecimal(item.getCount())));
            }
        }
        return sum;
    }

    //获取当前订单商品应付总额
    public BigDecimal getPayTotalPrice() {
        return this.getOrderTotalPrice();   //没有优惠
    }

    //获取商品总数量
    public Integer getProductCount(){
        Integer sum = 0;
        if (this.items != null) {
            for (OrderItemVo item : items) {
                sum += item.getCount();
            }
        }
        return sum;
    }
}
```

2）内部用户收货信息的列表，实际就是 member 服务中的 MemberReceiveAddressEntity 实体类。

```java
@Data 
public class MemberAddressVo {
    private Long id;
    private Long memberId;
    private String name;
    private String phone;
    private String postCode;
    private String province;
    private String city;
    private String region;
    private String detailAddress;
    private String areacode;
    private Integer defaultStatus;
}
```

3）内部购物项信息的封装，实际就是 cart 服务中的 CartItem 实体类。

```java
@Data
public class OrderItemVo {
    private Long skuId;
    private String title;
    private String image;
    private List<String> skuAttr;
    private BigDecimal price;
    private Integer count;
    private BigDecimal totalPrice;

    //TODO: 查询库存系统获取重量
    private BigDecimal weight;
}
```

3、order 服务负责接收跳转页面请求，并进行订单数据的显示：

```java
@GetMapping("/toTrade") //跳转到订单确认页面
public String toTrade(Model model) throws ExecutionException, InterruptedException {
    OrderConfirmVo orderConfirmVo = orderService.confirmOrder();
    model.addAttribute("orderConfirmData", orderConfirmVo);
    return "confirm";
}

/**
  * 查询订单确认页面需要使用的数据
  * 实际上应该使用 CompletableFuture 异步编排方式来实现，并使用 get() 方法进行阻塞等待
  */
@Override
public OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException {
    OrderConfirmVo orderConfirm = new OrderConfirmVo();
    MemberRespVo loginUser = LoginUserInterceptor.threadLocal.get();
    //获取原请求，临时存储用于下面进行设置共享（具体原因下面[问题]解释）
    RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
    //1.根据用户id远程查询member服务获取用户的收货地址列表
    CompletableFuture<Void> addressFuture = CompletableFuture.runAsync(() -> {
        RequestContextHolder.setRequestAttributes(requestAttributes);   //重新设置，让新线程内的请求得到对应资源
        List<MemberAddressVo> address = memberFeignService.getAddress(loginUser.getId());
        orderConfirm.setAddress(address);
    }, threadPoolExecutor);

    //2.根据用户id远程查询cart服务获取当前登录用户的购物车中的购物项列表
    CompletableFuture<Void> cartFuture = CompletableFuture.runAsync(() -> {
        RequestContextHolder.setRequestAttributes(requestAttributes);   //重新设置，让新线程内的请求得到对应资源
        List<OrderItemVo> currentUserCartItems = cartFeignService.getCurrentUserCartItems();
        orderConfirm.setItems(currentUserCartItems);
    }, threadPoolExecutor).thenRunAsync(() -> {
        List<OrderItemVo> items = orderConfirm.getItems();
        List<Long> skuIds = items.stream().map(item -> item.getSkuId()).collect(Collectors.toList());
        //调用远程库存 ware 服务，查询库存情况
        List<SkuHasStockVo> skusHasStock = wareFeignService.getSkusHasStock(skuIds);
        if (skusHasStock != null) {
            Map<Long, Boolean> stockMap = skusHasStock.stream().collect(Collectors.toMap(SkuHasStockVo::getSkuId, SkuHasStockVo::isHasStock));
            orderConfirm.setStockMap(stockMap);
        }
    }, threadPoolExecutor);

    //3.查询用户积分信息
    CompletableFuture<Void> integrationFuture = CompletableFuture.runAsync(() -> {
        RequestContextHolder.setRequestAttributes(requestAttributes);   //重新设置，让新线程内的请求得到对应资源
        orderConfirm.setIntegration(loginUser.getIntegration());
    }, threadPoolExecutor);

    //TODO:4.其他数据实体类内自动计算获得（本系统不实现）

    //5.防重令牌设置用于解决幂等性问题（下面会进行说明）
    String token = UUID.randomUUID().toString().replace("-", "");
    //后端的请求token放入redis进行保存，用于后续防重对比
    redisTemplate.opsForValue().set("order:token:" + loginUser.getId(), token, 30, TimeUnit.MINUTES);
    orderConfirm.setOrderToken(token);      //给前端页面的 token

    CompletableFuture.allOf(addressFuture, cartFuture, integrationFuture).get();
    return orderConfirm;
}
```

1）根据用户 id 获取用户的地址列表远程调用 member 服务：

```java
@FeignClient("shop-member")
public interface MemberFeignService {

    @GetMapping("/member/memberreceiveaddress/addresses/{memberId}")
    List<MemberAddressVo> getAddress(@PathVariable("memberId") Long memberId);
}

//member 服务逻辑的实现
@GetMapping("/addresses/{memberId}")
public List<MemberReceiveAddressEntity> getAddress(@PathVariable("memberId") Long memberId){
    return memberReceiveAddressService.getAddress(memberId);
}

@Override
public List<MemberReceiveAddressEntity> getAddress(Long memberId) {
    QueryWrapper<MemberReceiveAddressEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("member_id", memberId);
    return this.list(wrapper);
}
```

2）根据用户 id 获取购物项远程调用 cart 服务：

```java
@FeignClient("shop-cart")
public interface CartFeignService {

    @GetMapping("/currentUserCartItems")
    List<OrderItemVo> getCurrentUserCartItems();
}

//cart 服务逻辑的实现
@GetMapping("/currentUserCartItems")
@ResponseBody
public List<CartItem> getCurrentUserCartItems() {
    return cartService.getCurrentUserCartItems();
}

@Override
public List<CartItem> getCurrentUserCartItems() {
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    if (userInfoTo.getUserId() == null)
        return null;
    else {
        String cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId();
        List<CartItem> cartItems = this.getCartItems(cartKey);
        List<CartItem> cartItemList = cartItems.stream()
            .filter(cartItem -> cartItem.getCheck())    //过滤出被选中的购物项
            .map(cartItem -> {
                //购物车(redis)中商品当前的价格并不一定是最新价格，因此还需要单独远程调用product服务查询最新价格
                R currentPriceStatus = productFeignService.getCurrentPrice(cartItem.getSkuId());
                if (currentPriceStatus.getCode() == 0) {
                    cartItem.setPrice(new BigDecimal((String)currentPriceStatus.get("data")));
                }
                return cartItem;
            })
            .collect(Collectors.toList());
        return cartItemList;
    }
}

//远程调用 product 获取商品最新价格
@GetMapping("/product/skuinfo/currentPrice/{skuId}")
R getCurrentPrice(@PathVariable("skuId") Long skuId);

@GetMapping("/currentPrice/{skuId}")
public R getCurrentPrice(@PathVariable("skuId") Long skuId) {
    return R.ok().setData(skuInfoService.getById(skuId).getPrice().toString());
}
```

3）远程调用 ware 服务查询每个购物项的库存情况：

```java
@FeignClient("shop-ware")
public interface WareFeignService {

    @PostMapping("/ware/waresku/hasStock")
    List<SkuHasStockVo> getSkusHasStock(@RequestBody List<Long> skuIds);
}

@Data
public class SkuHasStockVo {
    private Long skuId;
    private boolean hasStock;
}

/**
 * WareSkuController
 * 查询一些商品(sku)是否有库存
 * @return 返回商品库存状态信息
 * 注：此处将 R 加上泛型再来返回实际上更好 R<T> 更有利于数据统一返回
 */
@PostMapping("/hasStock")
public List<SkuHasStockVo> getSkusHasStock(@RequestBody List<Long> skuIds){
    return wareSkuService.getSkusHasStock(skuIds);
}

@Override
public List<SkuHasStockVo> getSkusHasStock(List<Long> skuIds) {
    return skuIds.stream().map(skuId -> {
        SkuHasStockVo skuHasStockVo = new SkuHasStockVo();
        //查询当前 sku 的总库存量（多个仓库的库存之和）,单个仓库的库存还得减去锁定的库存量
        Long sumStock = this.baseMapper.getSkuSumStock(skuId);
        skuHasStockVo.setHasStock(sumStock == null ? false : (sumStock > 0));
        skuHasStockVo.setSkuId(skuId);
        return skuHasStockVo;
    }).collect(Collectors.toList());
}
```



`[问题]` Feign 远程调用时会创建新的 Request 对象，并经过默认的拦截器，这也就会导致 `丢失请求头` (也就是没有携带 cookie/session 信息)，此时远程调用时就会导致 cart 服务认为这个请求是出于没有登录的状态，那么说明就需要设置自己的拦截器：`Feign 远程调用的拦截器将构建的 Request 拦截设置请求头` 。

```java
@Configuration
public class MyFeignConfig {

    @Bean("requestInterceptor")
    public RequestInterceptor requestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate requestTemplate) {
                System.out.println("Feign 远程调用之前被拦截器捕获进行处理......");
                //1.使用 RequestContextHolder 拿到刚进来的请求信息，也就能够获取到当前请求对象
                ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                HttpServletRequest oldRequest = requestAttributes.getRequest();
                if (oldRequest != null) {
                    //2.同步老请求的请求头信息（手动设置请求头），主要就是 cookie 信息:内部包括公共session信息
                    requestTemplate.header("Cookie", oldRequest.getHeader("Cookie"));
                }
            }
        };
    }
}
```

`[问题]` 在异步编排的模式下，发现 order 内部拦截器出现 NullPointException 空指针异常，这是由于 `RequestContextHolder 底层是通过 ThreadLocal 来获取请求` 信息，采用顺序执行时始终都在同一个线程中(同步远程 Feign 调用)，但是如果采用异步编排的方式，那么此时就不是同一个线程，而是线程池内的不同线程，那么原来能够利用的在同一个线程内资源共享的 ThreadLocal 就没办法使用对应的资源，也就会出现 `NullPointException` 异常。

`[问题]` 如果当前网速过慢或者系统响应过慢，导致用户提交多次，可能就会导致数据库插入多次，也就是说需要订单的防重复提交。（`接口幂等性问题`）

> `接口幂等性`：就是用户对统一操作发起的一次请求或者多次请求的结果都是一致的，需要防止幂等性失效的场景主要有：
>
> 1）用户多次点击同一按钮；
>
> 2）用户页面回退再次提交造成多次提交；
>
> 3）微服务相互调用（Feign 的重试机制导致多次请求调用）. . . . . .

此系统中使用 `token 令牌机制` 来解决幂等性问题。

### 订单提交实现

![file](http://digtime.cn/uploads/images/202009/14/1/15PnuBZcgL.png)

1、封装一些需要使用的数据实体vo或to：

1）封装页面上订单需要提交的数据：

```java
@Data   //封装订单提交的数据
public class OrderSubmitVo {
    private Long addrId;        //收货地址id
    private Integer payType;    //支付方式(此项目只使用支付宝的三方支付方式测试，因此前端不提交)
    //根据京东的场景发现，京东实际提交的是购物车中勾选的商品，而不是结算页面的商品，因此此处不封装订单中的购物项
    //TODO：优惠、发票等等功能提交数据

    private String orderToken;  //前端的订单防重令牌
    private BigDecimal payPrice;    //用于验证价格(不实现)
    private String note;        //订单备注(不实现)
}
```

2）封装订单状态枚举类：

```java
public enum OrderStatusEnum {
    CREATE_NEW(0, "待付款"),
    PAYED(1, "已付款"),
    DELIVERED(2, "已发货"),
    RECEIVED(3, "已完成"),
    CANCELED(4, "已取消"),
    SERVICING(5, "售后中"),
    SERVICED(6, "售后完成");
    private final Integer code;
    private final String msg;

    OrderStatusEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
```

3）订单提交返回结果集封装：

```java
@Data @ToString
public class OrderSubmitRespVo {
    private OrderEntity order;
    private Integer code;   //订单提交状态码,0 代表成功
}
```

4）订单创建的网络流通实体类 OrderCreateTo：

```java
@Data
public class OrderCreateTo {
    private OrderEntity order;      //订单实体类
    private List<OrderItemEntity> items;    //整个订单内部的订单项列表
    private BigDecimal payPrice;    //应付金额，用于后续的价格校验
    private BigDecimal fare;        //运费信息
}
```

5）查询到的 spu 信息的封装 SpuInfoTo ：

```java
@Data
public class SpuInfoTo implements Serializable {
	private Long id;
	private String spuName;
	private String spuDescription;
	private Long catalogId;
	private Long brandId;
	private BigDecimal weight;
	private Integer publishStatus;
	private Date createTime;
	private Date updateTime;
}
```

6）库存锁定信息实体类：

```java
@Data
public class WareSkuLockTo {
    private String orderSn; //订单号
    private List<OrderItemVo> locks;    //需要锁定的所有商品信息
}
```

2、order 服务 controller 接收请求，调用业务层：

```java
/**
 * OrderWebController
 * 下单功能的实现:创建订单、验证令牌、验证价格、所库存等等
 * @param orderSubmit 前端传递的需要提交的数据
 * @return 下单成功来到支付选择页面，下单失败回到订单确认页
 */
@PostMapping("/submitOrder")
public String submitOrder(OrderSubmitVo orderSubmit, Model model, RedirectAttributes redirectAttributes){
    try {
        OrderSubmitRespVo orderSubmitResp = orderService.submitOrder(orderSubmit);
        log.warn("orderSubmitResp = " + orderSubmitResp);
        if (orderSubmitResp.getCode() == 0) {
            model.addAttribute("submitOrderResp", orderSubmitResp);
            return "pay";
        } else {
            Integer code = orderSubmitResp.getCode();
            String msg = "";
            switch (code) {
                case 1:
                    msg = "[下单失败] 令牌校验失败,请刷新重新提交!";
                    break;
                case 2:
                    msg = "[下单失败] 订单商品价格发生变化，请确认后重新提交!";
                    break;
                case 3:
                    msg = "[下单失败] 商品库存锁定失败，商品库存不足!";
                    break;
            }
            redirectAttributes.addFlashAttribute("msg", msg);
            return "redirect:http://order.moonshop.com/toTrade";
        }
    } catch (Exception e) {
        if (e instanceof NoStockException) {
            String msg = ((NoStockException)e).getMessage();
            redirectAttributes.addFlashAttribute("msg", msg);
        }
        return "redirect:http://order.moonshop.com/toTrade";
    }
}
```

此处的 NoStockException 异常类位于 common 模块，方便远程调用时公共使用：

```java
@Getter @Setter
public class NoStockException extends RuntimeException{
    private Long skuId;
    public NoStockException(Long skuId) {
        super("id= [" + skuId + "] 商品没有库存了");
    }

    public NoStockException(String msg) {
        super(msg);
    }
}
```

3、order 的 service 层进行真正的逻辑处理，`整个过程是一个事务处理`，方便事务的回滚问题。

```java
/**
 * OrderServiceImpl: 进行订单的数据提交（创建订单、验证令牌、验证价格、所库存等等）
 * @param orderSubmit 前端提交订单的封装数据
 * @return 提交订单的结果集
 */
@Transactional
@Override
public OrderSubmitRespVo submitOrder(OrderSubmitVo orderSubmit) {
    OrderSubmitRespVo orderSubmitResp = new OrderSubmitRespVo();
    orderSubmitResp.setCode(0);     //设置默认状态码
    MemberRespVo loginUser = LoginUserInterceptor.threadLocal.get();	//获取当前登录用户信息（拦截器中插入到 threadlocal）
    //注：orderToken 机制可以防止重复提交，但是没办法防止同时进入的多个请求同时提交出现问题，因此需要使用 Redis + Lua 方案
    //1.验证 orderToken 令牌，为了防止同一个时间多个请求同时提交 =====> 原子性操作 ====> Lua 脚本操作(0代表令牌失败，1代表删除成功)
    String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
    String orderToken = orderSubmit.getOrderToken(); //获取前端页面上的orderToken
    String redisOrderTokenKey = "order:token:" + loginUser.getId();
    Long result = redisTemplate.execute(
        new DefaultRedisScript<Long>(script, Long.class),
        Arrays.asList(redisOrderTokenKey),
        orderToken);
    if (result == 0L) {     //令牌校验失败
        orderSubmitResp.setCode(1);
        return orderSubmitResp;
    } else {
        //2.令牌校验成功后，创建订单信息,进行验价操作等
        OrderCreateTo order = this.createOrder(orderSubmit);	// 标注（1）创建订单 createOrder 内部封装方法
        BigDecimal payAmount = order.getOrder().getPayAmount(); //订单项计算的结果
        BigDecimal payPrice = orderSubmit.getPayPrice();    //前端提交的价格
        //3.进行验价进而保存订单以及订单项数据
        if (payAmount.subtract(payPrice).abs().doubleValue() < 0.01) {      // 金额对比容错成功
            //3.保存订单
            this.saveOrder(order);		// 标注（2）保存订单和订单项到数据库中，也就是持久化
            //4.远程调用 ware 锁定库存，有异常就回滚，因此需要标记Transactional注解
            WareSkuLockTo wareSkuLockVo = new WareSkuLockTo();
            wareSkuLockVo.setOrderSn(order.getOrder().getOrderSn());
            wareSkuLockVo.setLocks(order.getItems().stream().map(item -> {  //封装信息进行远程调用锁定库存
                OrderItemVo orderItemVo = new OrderItemVo();
                orderItemVo.setSkuId(item.getSkuId());
                orderItemVo.setCount(item.getSkuQuantity());
                return orderItemVo;
            }).collect(Collectors.toList()));
            // 远程锁库存
            R orderLockStockStatus = wareFeignService.orderLockStock(wareSkuLockVo);	//标注（3）调用远程 ware 服务进行库存锁定
            log.warn("远程调用 ware 服务 orderLockStockStatus = {}", orderLockStockStatus);
            if (orderLockStockStatus.getCode() == 0) {  //锁定成功
                orderSubmitResp.setOrder(order.getOrder());
                return orderSubmitResp;
            } else {        //锁定失败:为了确保锁库存失败后，订单和订单项也能回滚，需要抛出异常
                throw new NoStockException(BizCode.NO_STOCK_EXCEPTION.getMessage());
            }
        } else {        // 金额对比容错失败
            orderSubmitResp.setCode(2);
            return orderSubmitResp;
        }
    }
}
```

（1）创建订单 createOrder 内部封装方法：

```java
//构建订单实体并设置基本属性
private OrderCreateTo createOrder(OrderSubmitVo orderSubmit) {
    OrderCreateTo orderCreateTo = new OrderCreateTo();
    //1.构建订单实体：利用时间戳来充当订单号
    String orderSn = IdWorker.getTimeId();
    OrderEntity orderEntity = this.buildOrder(orderSn, orderSubmit);	//1.1）buildOrder 方法构建订单实体信息
    orderCreateTo.setOrder(orderEntity);
    //2.远程调用cart服务获取所有的订单项信息
    List<OrderItemEntity> orderItemList = this.buildOrderItems(orderSn);	//1.2) buildOrderItems 方法构建订单购物项列表
    orderCreateTo.setItems(orderItemList);
    //3.验证前端提交价格和后端查询价格对比,需要根据实际的价格计算订单的总价格
    this.computePrice(orderEntity, orderItemList);		//1.3) computePrice 方法用于计算真实应付的提交订单的总金额
    return orderCreateTo;
}
```

1.1）`buildOrder` 方法构建订单实体信息：

```java
//构建订单实体信息
private OrderEntity buildOrder(String orderSn, OrderSubmitVo orderSubmit) {
    MemberRespVo memberRespVo = LoginUserInterceptor.threadLocal.get();
    OrderEntity orderEntity = new OrderEntity();		//其他基本信息都可以在这里设置
    orderEntity.setOrderSn(orderSn);
    orderEntity.setMemberId(memberRespVo.getId());
    //2.远程调用 ware 服务获取收货地址信息和运费等信息
    R fareStatus = wareFeignService.getFare(orderSubmit.getAddrId());
    if (fareStatus.getCode() == 0) {
        FareRespTo fareResp = fareStatus.getData(new TypeReference<FareRespTo>() {});
        //设置订单的基本信息
        orderEntity.setFreightAmount(fareResp.getFare());
        orderEntity.setReceiverCity(fareResp.getAddress().getCity());
        orderEntity.setReceiverDetailAddress(fareResp.getAddress().getDetailAddress());
        orderEntity.setReceiverName(fareResp.getAddress().getName());
        orderEntity.setReceiverPhone(fareResp.getAddress().getPhone());
        orderEntity.setReceiverPostCode(fareResp.getAddress().getPostCode());
        orderEntity.setReceiverProvince(fareResp.getAddress().getProvince());
        orderEntity.setReceiverRegion(fareResp.getAddress().getRegion());
        //设置订单的状态信息、物流自动确认信息
        orderEntity.setStatus(OrderStatusEnum.CREATE_NEW.getCode());
        orderEntity.setAutoConfirmDay(7);	//自动确认收货7d
    } else {
        log.error("远程调用出错::wareFeignService.getFare");
    }
    return orderEntity;
}
```

远程调用 ware 服务获取收货地址信息和运费等信息：

```java
// Feign：shop-ware
@GetMapping("/ware/wareinfo/fare")
R getFare(@RequestParam("addrId") Long addrId);

//ware服务：WareInfoController
@GetMapping("/fare")
public R getFare(@RequestParam("addrId") Long addrId){
    FareRespVo fareRespVo = wareInfoService.getFare(addrId);
    return R.ok().setData(fareRespVo);
}

/**
 * ware服务：WareInfoServiceImpl
 * 根据用户地址id计算运费信息
 * @param addrId 地址id
 * @return 运费信息
 */
@Override
public FareRespVo getFare(Long addrId) {
    FareRespVo fareRespVo = new FareRespVo();
    //远程调用 member 服务查询地址信息
    R addrInfo = memberFeignService.addrInfo(addrId);
    MemberAddressVo memberAddress = addrInfo.getData("memberReceiveAddress", new TypeReference<MemberAddressVo>(){});
    if (memberAddress != null) {
        //TODO:此处实际上可以使用开放的API来实现计算运费
        String phone = memberAddress.getPhone();        //手机号最后两位算作运费
        fareRespVo.setFare(new BigDecimal(phone.substring(phone.length() - 2)));
        fareRespVo.setAddress(memberAddress);
        return fareRespVo;
    }
    return null;
}
```

远程调用 member 服务查询地址信息：

```java
//Feign:shop-member
@RequestMapping("/member/memberreceiveaddress/info/{id}")
R addrInfo(@PathVariable("id") Long id);

//member 服务：MemberReceiveAddressController 自动生成方法
@RequestMapping("/info/{id}")
public R info(@PathVariable("id") Long id){
    MemberReceiveAddressEntity memberReceiveAddress = memberReceiveAddressService.getById(id);

    return R.ok().put("memberReceiveAddress", memberReceiveAddress);
}
```

1.2）`buildOrderItems` 方法构建订单购物项列表：

```java
//构建订单项实体列表
private List<OrderItemEntity> buildOrderItems(String orderSn) {
    //远程调用 cart 服务，获取当前用户购物车中勾选的商品
    List<OrderItemVo> currentUserCartItems = cartFeignService.getCurrentUserCartItems();
    List<OrderItemEntity> orderItemEntityList = new ArrayList<>();
    if (currentUserCartItems != null && currentUserCartItems.size() > 0) {
        orderItemEntityList = currentUserCartItems.stream().map(cartItem -> {
            //构建每一个订单项
            return this.buildOrderItem(cartItem, orderSn);
        }).collect(Collectors.toList());
    } else {
        log.error("远程调用出错或查询为空::cartFeignService.getCurrentUserCartItems");
    }
    return orderItemEntityList;
}
```

远程调用 cart 服务，获取当前用户的购物车中勾选选项，避免有的提交之前临时新开浏览器页面添加勾选新的购物项。

```java
//Feign：shop-cart 服务
@GetMapping("/currentUserCartItems")
List<OrderItemVo> getCurrentUserCartItems();

//cart 服务：CartController 
@GetMapping("/currentUserCartItems")
@ResponseBody
public List<CartItem> getCurrentUserCartItems() {
    return cartService.getCurrentUserCartItems();
}

//cart 服务：CartServiceImpl 从 Redis 中查询
@Override
public List<CartItem> getCurrentUserCartItems() {
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    if (userInfoTo.getUserId() == null)
        return null;
    else {
        String cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId();
        List<CartItem> cartItems = this.getCartItems(cartKey);
        List<CartItem> cartItemList = cartItems.stream()
            .filter(cartItem -> cartItem.getCheck())    //过滤出被选中的购物项
            .map(cartItem -> {
                //购物车(redis)中商品当前的价格并不一定是最新价格，因此还需要单独远程调用product服务查询最新价格
                R currentPriceStatus = productFeignService.getCurrentPrice(cartItem.getSkuId());
                if (currentPriceStatus.getCode() == 0) {
                    cartItem.setPrice(new BigDecimal((String)currentPriceStatus.get("data")));
                }
                return cartItem;
            }).collect(Collectors.toList());
        return cartItemList;
    }
}
```

构建单个购物项信息，主要包括基本信息和每个商品的实际应付金额：

```java
//构建单个的订单项信息
private OrderItemEntity buildOrderItem(OrderItemVo cartItem, String orderSn) {
    OrderItemEntity orderItem = new OrderItemEntity();
    //1.订单信息：订单号
    orderItem.setOrderSn(orderSn);
    //2.商品spu信息
    Long skuId = cartItem.getSkuId();
    //远程调用 product 服务根据 skuId 获取spu信息（数据库表提交信息的需要）
    R spuInfoStatus = productFeignService.getSpuInfoBySkuId(skuId);
    if (spuInfoStatus.getCode() == 0) {
        SpuInfoTo spuInfo = spuInfoStatus.getData(new TypeReference<SpuInfoTo>() {});
        orderItem.setSpuId(spuInfo.getId());
        orderItem.setSpuBrand(spuInfo.getBrandId().toString());
        orderItem.setSpuName(spuInfo.getSpuName());
        orderItem.setCategoryId(spuInfo.getCatalogId());
    } else {
        log.error("远程调用出错::productFeignService.getSpuInfoBySkuId");
    }
    //3.商品sku信息
    orderItem.setSkuId(skuId);
    orderItem.setSkuName(cartItem.getTitle());
    orderItem.setSkuPic(cartItem.getImage());
    orderItem.setSkuPrice(cartItem.getPrice());
    String skuAttr = StringUtils.collectionToDelimitedString(cartItem.getSkuAttr(), ";");
    orderItem.setSkuAttrsVals(skuAttr);
    orderItem.setSkuQuantity(cartItem.getCount());
    //4.优惠信息(目前忽略)

    //5.积分信息:积分信息直接简单设置(TODO:实际上应该远程调用 product 获取上架商品时的设置或是调用 member 服务获取会员积分档次)
    orderItem.setGiftGrowth(cartItem.getPrice().multiply(BigDecimal.valueOf(cartItem.getCount())).intValue());
    orderItem.setGiftIntegration(cartItem.getPrice().multiply(BigDecimal.valueOf(cartItem.getCount())).intValue());

    //6.订单项的价格信息
    orderItem.setPromotionAmount(BigDecimal.ZERO);  //促销金额
    orderItem.setCouponAmount(BigDecimal.ZERO);     //优惠券金额
    orderItem.setIntegrationAmount(BigDecimal.ZERO);//积分优惠金额
    //当前订单项的原来的实际金额，再剔除优惠金额(TODO:实际应该远程查询优惠金额)
    BigDecimal originPrice = orderItem.getSkuPrice().multiply(BigDecimal.valueOf(orderItem.getSkuQuantity()));
    BigDecimal subtract = originPrice
        .subtract(orderItem.getCouponAmount())
        .subtract(orderItem.getPromotionAmount())
        .subtract(orderItem.getIntegrationAmount());
    orderItem.setRealAmount(subtract);  //设置最后的真实金额

    return orderItem;
}
```

远程调用 product 服务根据 skuId 获取spu信息（数据库表提交信息的需要）：

```java
//Feign:shop-product 服务
@GetMapping("/product/spuinfo/spuInfo/{skuId}")
R getSpuInfoBySkuId (@PathVariable("skuId") Long skuId);

//product 服务：SpuInfoController
@GetMapping("/spuInfo/{skuId}")
public R getSpuInfoBySkuId (@PathVariable("skuId") Long skuId) {
    SpuInfoEntity spuInfo = spuInfoService.getSpuInfoBySkuId(skuId);
    return R.ok().setData(spuInfo);
}

//product 服务：SpuInfoServiceImpl
@Override
public SpuInfoEntity getSpuInfoBySkuId(Long skuId) {
    SkuInfoEntity skuInfoEntity = skuInfoService.getById(skuId);
    return this.getById(skuInfoEntity.getSpuId());
}
```

1.3) `computePrice` 方法用于计算真实应付的提交订单的总金额，实际就是一个简单多个优惠的计算过程：

```java
private void computePrice(OrderEntity orderEntity, List<OrderItemEntity> orderItemList) {
    BigDecimal total = BigDecimal.ZERO;
    BigDecimal couponAmount = BigDecimal.ZERO;
    BigDecimal integrationAmount = BigDecimal.ZERO;
    BigDecimal promotionAmount = BigDecimal.ZERO;
    Integer giftGrowth = 0;
    Integer giftIntegration = 0;
    for (OrderItemEntity orderItem : orderItemList) {
        couponAmount = couponAmount.add(orderItem.getCouponAmount());
        integrationAmount = integrationAmount.add(orderItem.getIntegrationAmount());
        promotionAmount = promotionAmount.add(orderItem.getPromotionAmount());
        total = total.add(orderItem.getRealAmount());
        giftGrowth += orderItem.getGiftGrowth();
        giftIntegration += orderItem.getGiftIntegration();
    }
    orderEntity.setTotalAmount(total); // 商品总价（未减免）
    orderEntity.setPayAmount(total.add(orderEntity.getFreightAmount())); // 应付总价
    orderEntity.setPromotionAmount(promotionAmount); // 阶梯价减免
    orderEntity.setCouponAmount(couponAmount);  // 优惠券减免价
    orderEntity.setIntegrationAmount(integrationAmount); // 积分减免价
    orderEntity.setIntegration(giftIntegration); // 设置购物积分
    orderEntity.setGrowth(giftGrowth); // 设置成长积分
    orderEntity.setDeleteStatus(0); // 订单是否删除:0代表未删除
}
```

（2）`saveOrder` 方法保存订单和订单项到数据库中，也就是持久化：

```java
//保存订单数据
private void saveOrder(OrderCreateTo order) {
    //1.保存订单实体数据
    OrderEntity orderEntity = order.getOrder();
    orderEntity.setModifyTime(new Date());
    this.save(orderEntity);

    //2.保存订单项数据
    List<OrderItemEntity> orderItems = order.getItems();
    orderItemService.saveBatch(orderItems);
}
```

（3）调用远程 ware 服务进行库存锁定：

```java
//Feign:shop-ware 服务
@PostMapping("/ware/waresku/lock/order")
R orderLockStock(@RequestBody WareSkuLockTo wareSkuLock);

//shop-ware 服务：WareSkuController
@PostMapping("/lock/order")
public R orderLockStock(@RequestBody WareSkuLockTo wareSkuLock) {
    try {
        wareSkuService.orderLockStock(wareSkuLock);
        return R.ok();
    } catch (NoStockException e) {
        return R.error(BizCode.NO_STOCK_EXCEPTION.getCode(), BizCode.NO_STOCK_EXCEPTION.getMessage());
    }
}

/**
 * shop-ware 服务：WareSkuServiceImpl
 * 锁定库存服务
 * @param wareSkuLock 需要锁定库存的商品信息
 * @return 库存锁定结果集
 */
@Transactional(rollbackFor = NoStockException.class)
@Override
public Boolean orderLockStock(WareSkuLockTo wareSkuLock) {
    //TODO:按照下单的收货地址找到就近仓库，锁定库存(此处简单实现)
    //此处直接在每个仓库寻找是否有库存进行锁定
    List<OrderItemVo> locks = wareSkuLock.getLocks();
    List<SkuWareHasStock> skuWareHasStockList = locks.stream().map(lock -> {
        SkuWareHasStock skuWareHasStock = new SkuWareHasStock();
        Long skuId = lock.getSkuId();
        skuWareHasStock.setSkuId(skuId);
        skuWareHasStock.setLockNum(lock.getCount());
        //获取当前商品在那些仓库有库存
        List<Long> wareIds = wareSkuDao.listWareIdHasStock(skuId);		// 3.1） 获取当前商品在哪些仓库有合适的库存
        skuWareHasStock.setWareIds(wareIds);
        return skuWareHasStock;
    }).collect(Collectors.toList());

    for (SkuWareHasStock skuWareHasStock : skuWareHasStockList) {
        Boolean currentLockFlag = false;
        Long skuId = skuWareHasStock.getSkuId();
        List<Long> wareIds = skuWareHasStock.getWareIds();
        if (wareIds == null || wareIds.size() == 0) {
            throw new NoStockException(skuId);
        }
        //遍历锁定库存
        for (Long wareId : wareIds) {
            int affectedLine = wareSkuDao.lockSkuStock(skuId, wareId, skuWareHasStock.getLockNum());	// 3.2）锁定库存
            if (affectedLine == 0) {
                currentLockFlag = true;
                break;  //当前sku锁定成功，不需要再尝试其他仓库
            }
        }
        //如果某一个商品没有锁定，那么说明整个订单都锁定失败
        log.error("currentLockFlag:{}", currentLockFlag);
        if (currentLockFlag) {
            throw new NoStockException(skuId);
        }
    }
    return true;
}

@Data
static class SkuWareHasStock {
    private Long skuId;     //商品skuId
    private Integer lockNum;    //锁定多少件
    private List<Long> wareIds;  //仓库地址
}
```

3.1） 获取当前商品在哪些仓库有合适的库存：

```java
List<Long> listWareIdHasStock(@Param("skuId") Long skuId);
```

```xml
<select id="listWareIdHasStock" resultType="java.lang.Long">
    select ware_id from wms_ware_sku where sku_id = #{skuId} and stock - stock_locked > 0
</select>
```

3.2）锁定库存（实际就是更新 stock_locked 字段）：

```java
int lockSkuStock(@Param("skuId") Long skuId, @Param("wareId") Long wareId, @Param("lockNum") Integer lockNum);
```

```xml
<update id="lockSkuStock">
    update wms_ware_sku set stock_locked = (stock_locked + #{lockNum})
    where sku_id = #{skuId} and ware_id = #{wareId} and (stock-stock_locked) >= #{lockNum}
</update>
```

注：整个过程实际就是创建订单项和订单实体并保存，同时锁定数据库中的库存数据的过程，而 `事务的回滚采用的是抛出异常导致回滚的方式` 来实现 (后续完善) 。

> 如果前端 pay 页面数据回显时出现问题，可能是 orderSn 过长导致，需要修改数据库中对应表的 orderSn 字段长度为 63 (原先为 32)。

### 分布式事务需要

上面采用的是本地的事务方案，可以通过`抛出异常来让事务回滚`（远程出错回滚，本地感知异常也会回滚），但是实际上可能会发生错误回滚，因此实际上还是存在一些远程调用上的事务相关场景问题：

- `远程服务假失败`：远程调用成功，但网络或是机器原因没有返回远程调用的结果，Feign 的超时机制启动也会抛出异常，但实际上是调用成功的，这也就会导致远程服务成功不会回滚，而本地的服务则出现异常会回滚。
- `本地失败而远程不回滚`：多个远程调用时，或是远程调用下还有其他逻辑代码发生异常时，此时远程服务事务并不会回滚，本地事务回滚。

解决方案：分布式系统下不能使用本地事务，而应该使用 `分布式事务（）` 。

在分布式系统中，存在 `CAP` 原则和 BASE 理论：

1）CAP 原则（CAP 定理）：一致性、可用性、分区容错性。

> CAP 原则指的是三个要素最多同时满足两个，`不可能三者兼顾` ，但一定保证分区容错性，因此就是只有 CP 或是 `AP`（可用性和分区容错）。
>
> 参考动画演示Raft一致性算法演示：[Raft一致性算法](http://thesecretlivesofdata.com/raft/) 

2）BASE 理论：对 CAP 的延申，保证 AP 的前提下，保证弱一性(`最终一致性`) 。====> `柔性事务` 遵循 BASE 理论

### 分布式事务解决方案

1）`2PC 提交模式（XA 事务协议）`：第一阶段是事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。第二阶段是事务协调器要求每个数据库提交数据。如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。

![](https://pic.imgdb.cn/item/637612f216f2c2beb15e32aa.png)

2）`3PC 提交模式`：2PC 基础上引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）

3）`柔性事务-TCC 事务补偿型方案`：刚性事务是遵循 ACID 原则保证强一致性，柔性事务是遵循 BASE 理论保证最终一致性即可。一阶段 prepare 行为：调用自定义的 prepare 逻辑。二阶段 commit 行为：调用自定义的 commit 逻辑。二阶段 rollback 行为：调用自定义的 rollback 逻辑。

> 所谓 `TCC` 模式：是指支持把自定义的分支事务纳入到全局事务的管理中。

![](https://pic.imgdb.cn/item/6376136a16f2c2beb15eaf39.png)

4）`柔性事务-最大努力通知型方案`：按规律进行通知，`不保证数据一定能通知成功，但会提供可查询操作接口进行核对` 。这种方案主要用在与第三方系统通讯时，例如在调用微信或支付宝支付后的支付结果通知时，这种方案也是结合 MQ 消息队列来进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数，达到通知次数后即不再通知。

5）`柔性事务-可靠消息 + 最终一致性方案（异步确保型）方案`：同样是利用消息队列来实现，业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。

## Seata 分布式事务方案

![image](https://user-images.githubusercontent.com/68344696/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png)

`TC (Transaction Coordinator) `：事务协调者（协调全局），类似于 TransactionManager，用于维护全局和分支事务的状态，驱动全局事务提交或回滚。

`TM (Transaction Manager)` ：事务管理器（大事务范围控制），用于定义全局事务的范围，开始全局事务、提交或回滚全局事务。

`RM (Resource Manager)`：资源管理器（数据库交互，类似于单体应用下的 Transaction ），用于管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

> 默认 AT 模式，类似于 2PC 模式。

## RabbitMQ 事务方案

如果使用 seata 的默认 AT 模式，类似于 2PC 方案，但是在高并发场景下，实际上并不实用(AT 模式会加锁串行化执行)，此时就应该考虑 `使用消息队列来解决服务出现问题时发送消息来回滚数据，或者直接例如库存服务本身使用自动解锁模式（利用延迟队列来做定时任务）` 。

> Spring 的 schedule 定时任务来轮询数据库会严重消耗系统内存，增加数据库压力，还存在较大的时间误差 (时效性问题)。
>

实现方式主要可以分为：

设置队列过期时间实现延迟队列（`推荐方式`）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/7d3922c77a5a4d75ac3f106a4ace1511.png)

设置消息过期时间实现延迟队列（RabbitMQ 采用惰性检查机制，后面即使过期时间短的消息仍然会等待其前面先进入队列的消息拿出后才会被拿出）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a5cb94e4a4e24116ad25c6a195cffca1.png)

1、订单服务的消息队列设置业务实现的流程：order-event-exchange 表示对应 order 服务自己的正常交换机。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f7d039e78c6495f97cb0b6c58c69c72.png)

配置 MQ 配置类，将对应需要的组件加入到 Bean 容器中进行测试：

```java
@Configuration  //RabbitMQ 的相关队列、交换机、bing关系的注入
public class MyMQConfig {

    @Bean
    public Queue orderDelayQueue() {
        //死信相关设置 argument
        Map<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "order-event-exchange");  //死信路由交换机
        arguments.put("x-dead-letter-routing-key", "order.release.order");  //死信路由键
        arguments.put("x-message-ttl", 60000);   //消息过期时间 1min
        //new Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments)
        return new Queue("order.delay.queue", true, false, false, arguments);
    }

    @Bean
    public Queue orderReleaseQueue() {
        return new Queue("order.release.order.queue", true, false, false, null);
    }

    @Bean
    public Exchange orderEventExchange() {
        //public TopicExchange(String name, boolean durable, boolean autoDelete, Map<String, Object> arguments)
        return new TopicExchange("order-event-exchange", true, false, null);
    }

    @Bean
    public Binding orderCreateOrderBinding() {
        //public Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey, Map<String, Object> arguments)
        return new Binding("order.delay.queue", Binding.DestinationType.QUEUE,
                "order-event-exchange", "order.create.order", null);
    }

    @Bean
    public Binding orderReleaseOrderBinding() {
        return new Binding("order.release.order.queue", Binding.DestinationType.QUEUE,
                "order-event-exchange", "order.release.order", null);
    }
}
```

2、库存服务引入 RabbitMQ，并配置 Rabbit 配置类，进行相关逻辑的设置。

1）RabbitMQ 的配置信息如下，同时按照流程图设置交换机队列等信息

![img](https://img-blog.csdnimg.cn/2bf6339930194591a76d2e81f768206e.png)

```java
@EnableRabbit
@Configuration
public class MyRabbitMQConfig {

    @Autowired
    RabbitTemplate rabbitTemplate;

    @Bean   //消息转换器替代原本的JDK自带序列化方式
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
    
    @Bean
    public Exchange stockEventExchange() {
        return new TopicExchange("stock-event-exchange", true, false);
    }

    @Bean
    public Queue stockReleaseStockQueue() {
        return new Queue("stock.release.stock.queue", true, false, false, null);
    }

    @Bean
    public Queue stockDelayQueue() {
        Map<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "stock-event-exchange");  //死信路由交换机
        arguments.put("x-dead-letter-routing-key", "stock.release");  //死信路由键
        arguments.put("x-message-ttl", 2*60000);   //消息过期时间 2min
        return new Queue("stock.delay.queue", true, false, false, arguments);
    }

    @Bean
    public Binding stockReleaseBinding() {
        return new Binding("stock.release.stock.queue",
                Binding.DestinationType.QUEUE,
                "stock-event-exchange",
                "stock.release.#",
                null);
    }

    @Bean
    public Binding stockLockedBinding() {
        return new Binding("stock.delay.queue",
                Binding.DestinationType.QUEUE,
                "stock-event-exchange",
                "stock.locked",
                null);
    }
}
```

3）库存服务实现自动解锁：

```java

```





































