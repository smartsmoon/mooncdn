---
title: 谷粒商城-商品服务模块
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringBoot
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## 分类维护模块

​	电商产品基本都是三级分类的形式，例如 图书----- 电子书刊------网络原创 这种层级。

> 关闭语法检查：`build/webpack.base.conf.js` 文件下：
>
> ```js
> const createLintingRule = () => ({
>   // test: /\.(js|vue)$/,
>   // loader: 'eslint-loader',
>   // enforce: 'pre',
>   // include: [resolve('src'), resolve('test')],
>   // options: {
>   //   formatter: require('eslint-friendly-formatter'),
>   //   emitWarning: !config.dev.showEslintErrorsInOverlay
>   // }
> })
> ```

### 菜单显示

实现效果如下：

![](https://pic1.imgdb.cn/item/634a58c416f2c2beb1105dbf.png)

1、导入分类数据，此处分类过多，暂不做 sql 语句的展示，可参考谷粒商城的电商项目 sql 语句。

> 此时就可以在子项目 `shop-product` 中的 `CategoryController` 控制器根据需求修改原来的逆向工程生成的代码。

2、修改 CategoryEntity 实体类，添加属性 Children，表示子分类。

```java
//子分类:在数据表中不存在，标注为 false
@TableField(exist = false)
@JsonInclude(JsonInclude.Include.NON_EMPTY)		// 表示当结果为 null 时不设置
private List<CategoryEntity> children;
```

3、由于我采用的高版本的 nacos，就必须配置 nacos 服务发现（目前不明白为什么，猜测`可能是版本的原因`），并且需要开启 nacos-server 单机版，如果不开启虽然能够正常查询数据，但是 Spring会提前停止。

```properties
spring: 
    cloud:
        nacos:
          discovery:
            server-addr: 127.0.0.1:8848
    application:
        name: shop-product
```

4、CategoryController 添加请求用于查询所有分类并以树形结构组装起来。

```java
//查出所有分类以及子分类，以树形结构组装起来
@RequestMapping("/list/tree")
public R listTree(){
    List<CategoryEntity> treeList = categoryService.listWithTree();
    return R.ok().put("data", treeList);
}
```

5、CategoryService 添加方法 `listWithTree` 提供给 Controller 使用。

```java
// CategoryService 接口：
List<CategoryEntity> listWithTree();

// CategoryServiceImpl 实现：
@Override
public List<CategoryEntity> listWithTree() {
    //1 查出所有分类
    List<CategoryEntity> categoryEntities = baseMapper.selectList(null);
    //2 组装成树形结构
    //2.1 找到一级分类：pid = 0
    List<CategoryEntity> levelMenus = categoryEntities.stream()
        .filter((categoryEntity) -> {
            return categoryEntity.getParentCid() == 0;
        }).map((menu) -> {
        menu.setChildren(getChildren(menu, categoryEntities));
        return menu;
    }).sorted((menu1, menu2) -> {
        return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
    }).collect(Collectors.toList());
    return levelMenus;
}

//递归查找所有菜单的子菜单
private List<CategoryEntity> getChildren(CategoryEntity root, List<CategoryEntity> menuList){
    List<CategoryEntity> children =
        menuList.stream().filter((categoryEntity) -> {
        return categoryEntity.getParentCid().longValue() == root.getCatId().longValue();
    }).map((categoryEntity) -> {
        //递归遍历寻找子菜单，将每一个菜单的子菜单都进行递归寻找放入
        categoryEntity.setChildren(getChildren(categoryEntity, menuList));
        return categoryEntity;
    }).sorted((menu1, menu2) -> {
        //菜单的排序
        return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
    }).collect(Collectors.toList());
    return children;
}
```

6、启动后端项目 renren-fast，再启动前端项目 renren-fast-vue 项目，进入项目发现，实际上这个项目的路由和 vue 模板文件时对应的，所有的菜单页面都在 `views/modules` 目录下，sys 菜单配置都在 sys 目录下，因此我们在前端页面中添加菜单后，只需要创建新目录然后实现代码即可。

1）登录前端系统，选择系统管理下的菜单管理，添加菜单：`商品系统`，选择合适图标即可。

![](https://pic1.imgdb.cn/item/63427daf16f2c2beb177d2ee.png)

2）继续添加菜单：`分类维护`，添加到商品系统下，菜单路由设置：`product/category` 。

3）在前端项目的 view/modules 目录下新建目录 product，新建 `category.vue` 组件，实现分类的展示。

```vue
<template>
    <el-tree :data="menus" :props="defaultProps"></el-tree>
</template>

<script>
export default {
    data() {
        return {
            menus: [],
            defaultProps: {
                children: "children",	//子菜单选项
                label: "name"	//name 属性是显示的菜单名称
            }
        };
    },

    mounted() {
        this.getMenus();
    },

    methods: {
        getMenus () {
            this.$http({
                url: this.$http.adornUrl('/product/category/list/tree'),
                method: 'get'
            }).then(data => {
                console.log("菜单数据：",data);
            })
      }
    },
};
</script>
```

4）此时测试前端页面，发现请求是给 8080 发送请求，而实际上应该给 10000 端口的商品服务发送请求，那么应该怎么办呢？

同时考虑到如果我们修改成 10000 端口，那么以后其他请求也是没办法实现转发的，因此肯定是需要给网关发送请求的，让网关 88 来统一管理转发所有的请求。

修改前端项目的默认 api 请求地址：`static/config/index.js` ，此处的 api 后缀用于后面网关的匹配断言。

```js
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88/api';
```

此时会发现前端网页会直接跳转登录页，同时验证码请求失败，这是因为验证码是在 renren-fast 项目服务中，那么此时就可以将renren-fast 也注册到注册中心，然后让网关将请求都转发到 renren-fast 服务中。

5）将 renren-fast 注入到注册中心中。

修改原来的 boot 版本，引入 common 工程，同时配置 cloud 的版本限制：

```xml
<!-- 修改 boot 版本同其他子项目对应 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.2.4.RELEASE</version>
</parent>

<!-- 由于没有自动引用，需要手动添加 cloud 版本控制 -->
<spring-cloud.version>Greenwich.SR3</spring-cloud.version>

<!-- 引入 common 工程 -->
<dependency>
    <groupId>com.example</groupId>
    <artifactId>shop-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>

<!-- 由于没有自动引用，需要手动添加 cloud 版本依赖控制 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

修改 application.yml 配置文件修改注册到注册中心中：

```yml
spring: 
    application:
        name: renren-fast
      cloud:
        nacos:
          discovery:
            server-addr: 172.0.0.1:8848
```

添加 bootstrap.yml 配置文件配置中心信息，避免警告信息（如果 product 项目没有 `bootstrap.yml` 配置文件同样也需要添加）：

```yml
spring:
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
  application:
    name: renren-fast
```

主启动类添加 `@EnableDiscoveryClient` 注解开启服务注册和发现。

> 此时就发现需要引入 `shop-common` 模块，但是发现 cloud 版本和 boot 版本不匹配，项目无法成功启动，因此需要修改为 boot 版本和 cloud 版本。

6）启动 gateway、renren-fast、product 项目，进入 nacos 客户端查看项目注册情况，发现都能成功注册到 nacos 注册中心。

![](https://pic1.imgdb.cn/item/6343e29316f2c2beb10419c5.png)

7）网关配置路由规则，进行断言判断。

```yml
spring:
  cloud:
    gateway:
      routes:
        - id: admin_route
          uri: lb://renren-fast		# lb 表示负载均衡
          predicates: # 规定前端项目的路由都带有 api 前缀
            - Path=/api/**
```

8）再重新启动网关项目，但是此时 F12 再看验证码请求会发现，请求路径是：`http://localhost:88/api/captcha.jpg?uuid=xxx`，由于实际上 renren-fast 访问时还会有项目名：

```yml
server: 
    servlet:
        context-path: /renren-fast
```

因此实际上我们应该让网关能将 URL 转化成 `http://localhost:8080/renren-fast/captcha.jpg?uuid=xxx` 才能实现正确访问，那么就需要网关的 filter 的路径重写功能，也就是在网关项目的 application.yml 中添加 `filters` 的路径重写配置：

```yml
filters:
	- RewritePath=/api/(?<segment>.*),/renren-fast/$\{segment}
```

9）同时还应该想到登陆时前端项目是 8001 端口，访问的是 88 端口，也就会产生跨域问题 `Cors Policy`，那么就需要使用网关统一配置跨域。

> `跨域`是指浏览器不能执行其他网站的脚本，是由浏览器的同源策略造成的，是`浏览器对 javascript 施加的安全限制`（例如发送 ajax 请求获取数据）。 
>
> `同源策略`是指协议，域名，端囗都要相同，其中有一个不同就会产生跨域。
>
> 解决办法：
>
> 1）使用 Nginx 部署为同域，统一使用 Nginx 服务。
>
> 2）配置当前请求允许跨域：`Access-Control-Allow-Origin/Methods/Credentials` 本地项目使用此种方式，且是在网关中统一配置。

gateway 项目添加 config 包，编写 `CorsConfiguration` 跨域配置类：

```java
@Configuration
public class MyCorsConfiguration {

    @Bean
    public CorsWebFilter corsWebFilter(){
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        //配置跨域的设置
        corsConfiguration.addAllowedHeader("*");    //允许哪些请求头
        corsConfiguration.addAllowedMethod("*");    //允许哪些请求方式
        corsConfiguration.addAllowedOrigin("*");    //允许哪些请求来源
        corsConfiguration.setAllowCredentials(true);    //是否允许携带 cookie 进行跨域
        source.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```

但此时还是有问题的，因为 renren-fast 内部自己也设置了跨域，此时就需要将 renren-fast 项目内部的 CrosConfig 跨域设置注释掉，避免重复配置为 mutli。

此时再重启 gateway 项目，进行登录测试，发现能够成功登录到系统。

10）网关配置新增路由，将 `/api/product` 请求都转发给 `shop-product` 服务。（`注意需要将精确的路由放在前面，否则会被模糊的路由提前拦截`）

```yml
- id: product_route
  uri: lb://shop-product
  predicates: # 规定前端项目的路由都带有 /api/product/ 前缀
  	- Path=/api/product/**
  filters:
  	- RewritePath=/api/(?<segment>.*),/$\{segment}
```

同时需要将 product 项目注册到 nacos 注册中心，同时也配置 nacos 配置中心相关信息。

此时前端控制台已经可以看到菜单信息，后面就需要在 getMenu 方法中将菜单数据装入到页面的元素中：

```js
getMenus () {
    this.$http({
    	url: this.$http.adornUrl('/product/category/list/tree'),
    	method: 'get'
    }).then(({data}) => {
    	//将返回数据中的 data 解构出来
    	this.menus = data.data;
    	console.log("菜单数据：",data);
    })
}
```

### 菜单删除

实现三级分类菜单删除功能需要注意 product 服务中实现 `逻辑删除`，因为在实际开发中并不会真实删除数据。

1、在 product 的 `application.yml` 配置文件中加入 mp 的全局逻辑删除规则的配置：

```yml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 1   # 1 表示已删除
      logic-not-delete-value: 0   # 0 表示未删除
```

2、在实体类上添加 `@TableLogic` 注解：

```java
@TableLogic(value = "1", delval = "0")
private Integer showStatus;
```

3、可以调整日志级别，查看删除操作时的 sql 语句：

```yml
logging:
  level:
    com.example.shop: debug
```

4、后端 Controller 请求的实现逻辑：

1）CategoryController 层：

```java
/**
 * 删除菜单的选项（目前只完成一半）
 * RequestBody 注解用于获取请求体的内容（json）进行封装成对应的对象，但是也说明只能使用在 Post 请求
 * @param catIds 待删除的菜单项 id
 * @return 请求结果
 */
@RequestMapping("/delete")
public R delete(@RequestBody Long[] catIds){
    categoryService.removeMenuByIds(Arrays.asList(catIds));
    return R.ok();
}
```

2）CategoryServiceImpl 层：

```java
@Override
public void removeMenuByIds(List<Long> ids) {
    //TODO:检查当前删除的菜单是否被别的地方引用
    baseMapper.deleteBatchIds(ids);
}
```

5、前端项目使用 el-tree 的 `scoped slot` 函数功能添加删除按钮操作，同时添加多选框等实现逻辑，并且应该具有友好的提示框。

```vue
<template>
  <el-tree :data="menus" :props="defaultProps" :expand-on-click-node="false" :show-checkbox="true" node-key="catId" :default-expanded-keys="expendedKey">
    <!-- expand-on-click-node = false 设置只有点击菜单箭头时才会展开，避免影响操作体验 -->
    <!-- show-checkbox 用于多选, node-key 用于表示树节点的唯一 id,default-checked-keys用于设置删除菜单后默认展开的菜单，增加用户体验 -->
    <span class="custom-tree-node" slot-scope="{ node, data }">
      <span>{{ node.label }}</span>
      <span>
        <!-- 设置只有当叶子菜单才显示 delete，其他菜单显示 append 按钮 -->
        <el-button v-if="node.childNodes.length == 0" type="text" size="mini" @click="() => remove(node, data)" > Delete </el-button>
      </span>
    </span>
  </el-tree>
</template>

<script>
export default {
  data() {
    return {
      menus: [],
      defaultProps: {
        children: "children",
        label: "name",
      },
      expendedKey:[]
    };
  },

  mounted() {
    this.getMenus();
  },

  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
      }).then(({ data }) => {
        //将返回数据中的 data 解构出来
        this.menus = data.data;
        console.log("菜单数据：", data);
      });
    },
    //node 为当前节点的值（包括是否展开、层级属性等等），data 为节点代表的菜单项真正内容
    remove(node, data){
        //设置友好的弹窗，避免误操作
        this.$confirm(`是否删除${data.name}菜单项?`, "提示", {
            confirmButtonText: "确认",
            cancelButtonText: "取消",
            type: "warning"
        }).then(() => {
            var ids = [data.catId]
            //实际发送请求删除菜单项
            this.$http({
                url: this.$http.adornUrl("/product/category/delete"),
                method: "post",
                data: this.$http.adornData(ids, false)
            }).then(({ data }) => {
                this.$message({
                    message: "已成功删除菜单项",
                    type: 'success'
                })
                //刷新出新的菜单
                this.getMenus();
                //设置默认要展开的菜单，也就是刚删除菜单的父节点
                this.expendedKey = [node.parent.data.catId];
            });
        }).catch(() => {
            this.$message({
                message: `已取消删除${data.name}菜单项`,
                type: 'warning'
            }) 
        })
        
    }
  },
};
</script>
```

### 菜单添加

菜单添加则希望能够点击 append 按钮，弹出一个对话框，在对话框中输入子分类的信息后发送请求添加到数据库中，实现菜单添加功能。

1、后端保存方法直接使用逆向工程的 save 代码：

```java
@RequestMapping("/save")
public R save(@RequestBody CategoryEntity category){
    categoryService.save(category);
    return R.ok();
}
```

2、前端需要使用对话框表单提交的方式：

```vue
<template>
<div>
  <el-tree :data="menus" :props="defaultProps" :expand-on-click-node="false" :show-checkbox="true" node-key="catId" :default-expanded-keys="expendedKey">
    <!-- expand-on-click-node = false 设置只有点击菜单箭头时才会展开，避免影响操作体验 -->
    <!-- show-checkbox 用于多选, node-key 用于表示树节点的唯一 id,default-checked-keys用于设置删除菜单后默认展开的菜单，增加用户体验 -->
    <span class="custom-tree-node" slot-scope="{ node, data }">
      <span>{{ node.label }}</span>
      <span>
        <!-- 设置只有当叶子菜单才显示 delete，其他菜单显示 append 按钮 -->
        <el-button v-if="node.level <= 2" type="text" size="mini" @click="() => append(data)"> Append </el-button>
        <el-button v-if="node.childNodes.length == 0" type="text" size="mini" @click="() => remove(node, data)" > Delete </el-button>
      </span>
    </span>
  </el-tree>
  <el-dialog title="" :visible.sync="dialogVisible" width="30%" :before-close="canceSave">
    <el-form :model="category">
        <el-form-item label="分类名称">
            <el-input v-model="category.name" auto-complete="off"></el-input>
        </el-form-item>
    </el-form>
    <span slot="footer">
        <el-button @click="canceSave">取消</el-button>
        <el-button type="primary" @click="addCategory">确认</el-button>
    </span>
  </el-dialog>
</div>
</template>

<script>
export default {
  data() {
    return {
      menus: [],
      defaultProps: {
        children: "children",
        label: "name",
      },
      expendedKey:[],
      dialogVisible: false,
      category: {
        name: "",
        parentCid: 0,
        cateLevel: 0,
        showStatus: 1,
        sort: 0
      }
    };
  },

  mounted() {
    this.getMenus();
  },

  methods: {
    getMenus() {
      // 见之前以实现的对应功能
    },
    append(data){
        console.log(data);
        this.dialogVisible = true;
        this.category.parentCid = data.catId;
        this.category.cateLevel = data.cateLevel + 1;
    },
    //添加三级分类数据
    addCategory(){
        this.$confirm(`是否确认添加 【${this.category.name}】 子菜单项?`, "提示", {
            confirmButtonText: "确认",
            cancelButtonText: "取消",
            type: "warning"
        }).then(() => {
            this.$http({
                url: this.$http.adornUrl('/product/category/save'),
                method: 'post',
                data: this.$http.adornData(this.category, false)
            }).then(({data}) => {
                this.$message({
                    message: "成功添加子菜单",
                    type: 'success'
                })
                this.dialogVisible = false;
                this.category.name = "";
                this.getMenus();
                this.expendedKey = [this.category.parentCid];
            })
        }).catch(() => {
            this.dialogVisible = false;
            this.category.name = "";
            this.$message({
                message: `已取消添加${this.category.name}菜单项`,
                type: 'warning'
            }) 
        })
    },
    //用于清空取消添加时的表单中的残留数据
    canceSave(){
        this.dialogVisible = false;
        this.category.name = "";
    },
    remove(node, data){		// 见之前以实现的对应功能
    }
  },
};
</script>
```

### 菜单修改

菜单修改需要在原先的基础上再加一个 edit 按钮，点击按钮需要弹出对话框，需要完成数据的回显，并实现数据修改后的提交。

1、修改菜单的后端逻辑的实现：

```java
/**
 * 修改分类的相关信息，实际上是利用 catId 来选择分类进行修改
 * @param category 修改后的分类信息
 * @return 修改请求的结果
 */
@RequestMapping("/update")
public R update(@RequestBody CategoryEntity category){
    categoryService.updateById(category);
    return R.ok();
}

/**
 * 根据 id 查询分类信息
 * @param catId 分类 id
 * @return 查询到的分类信息
 */
@RequestMapping("/info/{catId}")
public R info(@PathVariable("catId") Long catId){
    CategoryEntity category = categoryService.getById(catId);
    //TODO：后续还要做冗余表中字段的更新
    return R.ok().put("data", category);
}
```

2、修改菜单的前端逻辑实现，前端需要公用一个对话框，需要修改对话框内部原来的提交函数。

```vue
<template>
<div>
  <el-tree :data="menus" :props="defaultProps" :expand-on-click-node="false" :show-checkbox="true" node-key="catId" :default-expanded-keys="expendedKey">
    <!-- expand-on-click-node = false 设置只有点击菜单箭头时才会展开，避免影响操作体验 -->
    <!-- show-checkbox 用于多选, node-key 用于表示树节点的唯一 id,default-checked-keys用于设置删除菜单后默认展开的菜单，增加用户体验 -->
    <span class="custom-tree-node" slot-scope="{ node, data }">
      <span>{{ node.label }}</span>
      <span>
        <!-- 设置只有当叶子菜单才显示 delete，其他菜单显示 append 按钮 -->
        <el-button v-if="node.level <= 2" type="text" size="mini" @click="() => append(data)"> Append </el-button>
        <el-button type="text" size="mini" @click="() => edit(data)"> edit </el-button>
        <el-button v-if="node.childNodes.length == 0" type="text" size="mini" @click="() => remove(node, data)" > Delete </el-button>
      </span>
    </span>
  </el-tree>
  <el-dialog :title="title" :visible.sync="dialogVisible" width="30%" :before-close="canceSave">
    <el-form :model="category">
        <el-form-item label="分类名称">
            <el-input v-model="category.name" auto-complete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
            <el-input v-model="category.icon" auto-complete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
            <el-input v-model="category.productUnit" auto-complete="off"></el-input>
        </el-form-item>
    </el-form>
    <span slot="footer">
        <el-button @click="canceSave">取消</el-button>
        <el-button type="primary" @click="submitData">确认</el-button>
    </span>
  </el-dialog>
</div>
</template>

<script>
export default {
  data() {
    return {
      menus: [],
      defaultProps: {
        children: "children",
        label: "name",
      },
      expendedKey:[],
      dialogVisible: false,
      dialogType: "", //edit,add
      title: "",
      category: {
        catId: null,
        name: "",
        parentCid: 0,
        cateLevel: 0,
        showStatus: 1,
        sort: 0,
        productUnit: "",
        icon: ""
      }
    };
  },

  mounted() {
    this.getMenus();
  },

  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
      }).then(({ data }) => {
        //将返回数据中的 data 解构出来
        this.menus = data.data;
        console.log("菜单数据：", data);
      });
    },
    //对话框提交数据
    submitData(){
      if(this.dialogType == "add"){
        this.addCategory();
      }
      if(this.dialogType == "edit"){
        this.editCategory();
      }
    },
    append(data){
      this.dialogType = "add";
      this.title = "添加分类";
      console.log(data);
      this.dialogVisible = true;
      this.category.parentCid = data.catId;
      this.category.cateLevel = data.cateLevel + 1;
        
    },
    //添加三级分类数据
    addCategory(){
        this.$confirm(`是否确认添加 【${this.category.name}】 子菜单项?`, "提示", {
            confirmButtonText: "确认",
            cancelButtonText: "取消",
            type: "warning"
        }).then(() => {
            this.$http({
                url: this.$http.adornUrl('/product/category/save'),
                method: 'post',
                data: this.$http.adornData(this.category, false)
            }).then(({data}) => {
                this.$message({
                    message: "成功添加子菜单",
                    type: 'success'
                })
                this.dialogVisible = false;
                this.category.name = "";
                this.getMenus();
                this.expendedKey = [this.category.parentCid];
            })
        }).catch(() => {
            this.dialogVisible = false;
            this.category.name = "";
            this.$message({
                message: `已取消添加${this.category.name}菜单项`,
                type: 'warning'
            }) 
        })
    },
    //用于清空取消添加时的表单中的残留数据
    canceSave(){
        this.dialogVisible = false;
        this.category.name = "";
    },
    //弹出修改对话框
    edit(data){
        this.dialogType = "edit";
        this.title = "修改分类";
        this.dialogVisible = true;
        //需要发起请求获取回显数据，而不应该是直接使用点击的数据，因为可能会多个操作人员进行操作
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get'
        }).then(({data}) => {
          //请求成功进行数据回显
          this.category.name = data.data.name;
          this.category.catId = data.data.catId;
          this.category.icon = data.data.icon;
          this.category.productUnit = data.data.productUnit;
          this.category.parentCid = data.data.parentCid;
        })
        
    },
    //修改菜单信息,只修改基本信息，sort、parentId 等信息不修改（后续会拖拽修改），因此需要抽取某些字段发送到后端，而不能将所有信息发送到后端导致覆盖
    editCategory(){
      var {catId, name, icon, productUnit} = this.category;
      this.$http({
        url: this.$http.adornUrl('/product/category/update'),
        method: 'post',
        data: this.$http.adornData({catId, name, icon, productUnit}, false)
      }).then(({data}) => {
        this.$message({
            message: `菜单修改成功`,
            type: 'success'
        });
        this.dialogVisible = false;
        this.getMenus();
        this.expendedKey = [this.category.parentCid];
      })
    },
    //node 为当前节点的值（包括是否展开、层级属性等等），data 为节点代表的菜单项真正内容
    remove(node, data){
        //设置友好的弹窗，避免误操作
        this.$confirm(`是否删除${data.name}菜单项?`, "提示", {
            confirmButtonText: "确认",
            cancelButtonText: "取消",
            type: "warning"
        }).then(() => {
            var ids = [data.catId]
            //实际发送请求删除菜单项
            this.$http({
                url: this.$http.adornUrl("/product/category/delete"),
                method: "post",
                data: this.$http.adornData(ids, false)
            }).then(({ data }) => {
                this.$message({
                    message: "已成功删除菜单项",
                    type: 'success'
                })
                //刷新出新的菜单
                this.getMenus();
                //设置默认要展开的菜单，也就是刚删除菜单的父节点
                this.expendedKey = [node.parent.data.catId];
            });
        }).catch(() => {
            this.$message({
                message: `已取消删除${data.name}菜单项`,
                type: 'warning'
            }) 
        })
    }
  },
};
</script>
```

### 拖拽功能

设置 el-tree 的 `draggable` 属性，表示可拖拽节点，`allow-drop` 属性则是指定一个函数，表示节点是否可以放在某个位置的判断。

1、后端提供批量更新的接口，更新拖拽菜单的集合信息。

```java
/**
 * 根据前端的拖拽信息修改数据库信息
 * @param categories 要修改菜单的集合
 * @return 更新请求结果
 */
@RequestMapping("/update/sort")
public R updateSort(@RequestBody CategoryEntity[] categories){
    categoryService.updateBatchById(Arrays.asList(categories));
    return R.ok();
}
```

2、前端实现页面（此部分页面可能会有问题，但是更专注于后端即可）：

```vue
<template>
<div>
  <el-switch v-model="draggable" active-text="开启拖拽" inactive-text="关闭拖拽"></el-switch>
  <el-button type="primary" size="mini" v-if="draggable" @click="batchSave">批量保存</el-button>
  <el-button type="danger" size="mini" @click="batchDelete">批量删除</el-button>
  <el-tree :data="menus" :props="defaultProps" :draggable="draggable" :expand-on-click-node="false" ref="menuTree"
    :show-checkbox="true" node-key="catId" :default-expanded-keys="expendedKey" :allow-drop="allowDrop" @node-drop="handleDrop">
    <!-- expand-on-click-node = false 设置只有点击菜单箭头时才会展开，避免影响操作体验 -->
    <!-- show-checkbox 用于多选, node-key 用于表示树节点的唯一 id,default-checked-keys用于设置删除菜单后默认展开的菜单，增加用户体验 -->
    <!-- draggable 开启拖拽功能，allow-drop 用于指定拖拽可放位置的设定函数 -->
    <!-- node-drop 监听事件，表示拖拽成功时触发的事件，四个参数：被拖拽节点Node、拖拽进入的节点、放置位置、事件 event -->
    <!-- ref 相当于用于 js 的选择器，用于后续调用组件的方法 -->
    <span class="custom-tree-node" slot-scope="{ node, data }">
      <span>{{ node.label }}</span>
      <span>
        <!-- 设置只有当叶子菜单才显示 delete，其他菜单显示 append 按钮 -->
        <el-button v-if="node.level <= 2" type="text" size="mini" @click="() => append(data)"> Append </el-button>
        <el-button type="text" size="mini" @click="() => edit(data)"> edit </el-button>
        <el-button v-if="node.childNodes.length == 0" type="text" size="mini" @click="() => remove(node, data)" > Delete </el-button>
      </span>
    </span>
  </el-tree>
  <!-- 之前代码不做赘述 -->
</div>
</template>

<script>
export default {
  data() {
    return {
      //之前代码不做赘述
      maxLevel: 0,
      pCid: [],
      updateNodes: []
    };
  },

  mounted() {
    this.getMenus();
  },

  methods: {
    //之前代码不做赘述
    batchSave(){
      //此时需要修改的节点整理完毕，点击按钮就需要发送请求到后端进行实际的修改
      this.$http({
        url: this.$http.adornUrl('/product/category/update/sort'),
        method: 'post',
        data: this.$http.adornData(this.updateNodes, false)
      }).then(({data}) => {
        this.$message({
            message: "菜单更新成功!",
            type: 'success'
        })
        this.getMenus();
        this.expendedKey = this.pCid;
        //清空状态，避免 updateNodes 内部数据重复更新
        this.updateNodes = [];
        this.maxLevel = 0;
      })
    },
    //拖拽实现的位置判断函数，draggingNode表示当前节点，dropNode 表示放到哪些节点的 type 位置（next、prev、inner三种 type）。
    allowDrop(draggingNode, dropNode, type){
      console.log("allowDrop:", draggingNode, dropNode, type);
      //判断总层数不能大于 3
      this.countNodeLevel(draggingNode.data);
      //当前拖拽的节点+所在的父节点的层级不大于3就可以放置
      let deep = Math.abs(this.maxLevel - draggingNode.level) + 1;
      if(type == "inner"){
        return (deep + dropNode.level) <= 3;
      }else {
        return (deep + dropNode.parent.level) <= 3;
      }
    },
    //统计当前节点的最大深度
    countNodeLevel(node){
      if(node.childNodes != null && node.childNodes.length > 0){
          for (let i = 0; i < node.childNodes.length; i++){
            if(node.childNodes[i].level > this.maxLevel){
              this.maxLevel = node.childNodes[i].catLevel;
            }
            //递归查找
            this.countNodeLevel(node.childNodes[i]);
          }
      }
    },
    //拖拽成功的回调函数
    handleDrop(draggingNode, dropNode, dropType, event){
      let pCid = 0;
      let brotherNodes = null;
      //1.当前节点的最新父节点的 id
      if(dropType == "before" || dropType == "after"){
        pCid = dropNode.parent.data.catId == undefined ? 0 : dropNode.parent.data.catId;
        brotherNodes = dropNode.parent.childNodes;
      }else {
        pCid = dropNode.data.catId;
        brotherNodes = dropNode.childNodes;
      }
      this.pCid.push(pCid);
      //2.当前拖拽节点的最新顺序
      for(let i = 0; i < brotherNodes.length; i++){
        if(brotherNodes[i].data.catId == dropNode.data.catId){
          //如果遍历到当前拖拽的节点，那么就需要添加新的父id
          //3.判断当前拖拽节点的最新层级
          let catLevel = draggingNode.level;
          if(brotherNodes[i].level != draggingNode.level){
            //当前节点的层级发生变化
            catLevel = brotherNodes[i].level;
            //修改子节点的层级
            this.updateChildNodeLevel(brotherNodes[i])
          }
          this.updateNodes.push({catId:brotherNodes[i].data.catId, sort: i, parentCId: pCid, catLevel: catLevel})
          
        }else {
          //兄弟元素只更改顺序
          this.updateNodes.push({catId:brotherNodes[i].data.catId, sort: i})
        }
      }
    },
    //修改子节点的层级
    updateChildNodeLevel(node){
      if(node.childNodes.length > 0){
        for(let i = 0; i < node.childNodes.length; i++){
          var cNode = node.childNodes[i].data;
          this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
          this.updateChildNodeLevel(node.childNodes[i]);
        }
      }
    }
  },
};
</script>
```

### 批量删除

批量删除实际上就是借用 el-tree 的方法来发送请求删除数据，delete 批量方法就使用原来的请求接口 `delete` 即可。

```js
<!-- ref 相当于用于 js 的选择器，用于后续调用组件的方法 -->
1、el-tree 添加 ref 属性
2、添加批量删除按钮
<el-button type="danger" size="mini" @click="batchDelete">批量删除</el-button>
3、实现 batchDelete 功能
batchDelete(){
    let catIds = [];
    let checkedNodes = this.$refs.menuTree.getCheckedNodes();
    for(let i = 0; i < checkedNodes.length; i++){
    	catIds.push(checkedNodes[i].catId);
    }
    this.$confirm(`是否确认批量删除菜单项?`, "提示", {
        confirmButtonText: "确认",
        cancelButtonText: "取消",
        type: "warning"
    }).then(() => {
    	this.$http({
    		url: this.$http.adornUrl('/product/category/delete'),
    		method: 'post',
    		data: this.$http.adornData(catIds, false)
    	}).then(({data}) => {
    		this.$message({
   				message: "成功批量删除子菜单",
    			type: 'success'
    		})
    		this.getMenus();
    	})
    }).catch(() => {
    	this.$message({
    		message: `已取消删除菜单项`,
    		type: 'warning'
    	}) 
    })
}
```

## 品牌管理模块

和分类维护类似，在商品系统下创建一个子菜单：品牌管理，将之前逆向生成的代码中的 `brand.vue 和 brand-add-or-update.vue` 页面加入到 product 目录下。

但是能够发现前端页面中按钮是具有权限设置的：

```vue
<el-button v-if="isAuth('product:brand:save')" type="primary" @click="addOrUpdateHandle()">新增</el-button>
<el-button v-if="isAuth('product:brand:delete')" type="danger" @click="deleteHandle()" 
           :disabled="dataListSelections.length <= 0">批量删除</el-button>
```

注释掉权限判断的相关方法，也就是 `utils/index.js` 里面的权限判断：

```js
// 权限判断
export function isAuth (key) {
  // return JSON.parse(sessionStorage.getItem('permissions') || '[]').indexOf(key) !== -1 || false
  return true
}
```

此时新增和批量删除的按钮已经显示，同时功能都是完好的，我们在此基础上只需要进行效果的优化即可。

### 配置分页插件

根据官方提示，配置分页插件需要编写配置类，引入 `MybatisPlusInterceptor` 后即可使用。

```java
@Configuration
@EnableTransactionManagement
@MapperScan("com.example.product.dao")
public class MyBatisConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        PaginationInnerInterceptor interceptor1 = new PaginationInnerInterceptor(DbType.H2);
        interceptor1.setMaxLimit(1000L);	//限制最大条数
        interceptor1.setOverflow(true);		//超出跳转到第一页
        interceptor.addInnerInterceptor(interceptor1);
        return interceptor;
    }

    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> configuration.setUseDeprecatedExecutor(false);
    }
}
```

### 显示状态优化

原本的显示状态为 0/1，需要将 0 和 1 显示优化成使用 `slot` 的开关显示效果，同时也需要修改新增对话框的 01 显示效果，前端页面样式变化，但是还是需要像后端发请求使数据真实修改，通过 `change` 事件来实现：

```vue
<!-- brand.vue -->
<el-table-column prop="showStatus" header-align="center" align="center" label="显示状态">
    <template slot-scope="scope">
		<el-switch v-model="scope.row.showStatus" active-color="#13ce66" inactive-color="#ff4949" 
                   @change="updateBrandStatus(scope.row)" :active-value="1" :inactive-value="0">
        </el-switch>
    </template>
</el-table-column>

<!-- brand-add-or-update.vue -->
<!-- 修改 label-width 宽度 -->
<el-form :model="dataForm" :rules="dataRule" ref="dataForm" @keyup.enter.native="dataFormSubmit()" label-width="140px">
<el-form-item label="显示状态" prop="showStatus">
    <el-switch v-model="dataForm.showStatus" active-color="#13ce66" inactive-color="#ff4949" :active-value="1" :inactive-value="0">
    </el-switch>
</el-form-item>

<!-- 实际的 updateBrandStatus 请求方法 -->
updateBrandStatus(data){
    console.log("最新信息", data);
    let {brandId, showStatus} = data;
    this.$http({
    	url: this.$http.adornUrl('/product/brand/update'),
    	method: 'post',
    	data: this.$http.adornData({brandId, showStatus}, false)
    }).then(({data}) => {
    	this.$message({
    		type: "success",
    		message: "状态更新成功"
    	})
    })
},
```

后端的逻辑位于 `BrandController` 中的 update 请求：

```java
/**
 * 根据 id 修改 Brand 品牌
 * @param brand 想要修改后的数据
 * @return 请求状态
 */
@RequestMapping("/update")
public R update(@RequestBody BrandEntity brand){
    brandService.updateById(brand);
    //TODO:需要更新关联表
    return R.ok();
}
```

### 查询品牌列表

前端代码使用逆向工程生成的代码，但是并未做模糊匹配的搜索，因此需要修改原来的 service，添加查询条件的限制：

```java
@Override
public PageUtils queryPage(Map<String, Object> params) {
    String searchKey = (String) params.get("key");
    QueryWrapper<BrandEntity> wrapper = new QueryWrapper<>();
    if (！StringUtils.isEmpty(searchKey)){
        wrapper.eq("brand_id", searchKey).or().like("name", searchKey);
    }
    IPage<BrandEntity> page = this.page(new Query<BrandEntity>().getPage(params),wrapper);
    return new PageUtils(page);
}
```

![](https://pic1.imgdb.cn/item/634a586816f2c2beb10fca16.png)

### 关联分类实现

将谷粒商城提供的代码 common 和 product 里面的文件替换掉原来自己编写的 `view/modules` 下面的文件（前端代码不重点写），方便之后根据前端确定的接口文档编写后端 api 接口。

> 注意：前端抽取组件和主页面的通信采用的是 Pubsub.js 实现，因此需要导入 Pubsub.js：
>
> 1）命令行执行：npm install --save pubsub-js --registry=https://registry.npm.taobao.org --force
>
> 2）src 目录下的 main 添加引入：
>
> ```js
> import PubSub from 'pubsub-js'
> Vue.prototype.PubSub = PubSub
> ```

![](https://pic1.imgdb.cn/item/634a594216f2c2beb1113bec.png)

`关联分类`是指一个品牌可以关联到多个分类，而一个分类也可以关联到多个品牌，因此品牌和分类是 `多对多` 的关系，因此数据库中也就会存在一个中间表，也就是 `pms_category_brand_relation` 表，用于维持二者的关系。

1、根据提供的代码会发现需要两个请求：

CategoryBrandRelationController 捕获请求逻辑：

```java
/**
 * 获取某个品牌关联的所有分类
 * @param brandId 品牌id
 * @return 关联分类信息
 */
@RequestMapping(value = "/catelog/list", method = RequestMethod.GET)
public R list(@RequestParam("brandId") Long brandId){
    QueryWrapper<CategoryBrandRelationEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("brand_id", brandId);
    List<CategoryBrandRelationEntity> data = categoryBrandRelationService.list(wrapper);
    return R.ok().put("data", data);
}


/**
 * 关系信息的保存，此处前端传递信息并不包括某些字段，需要完成字段的填充
 * @param categoryBrandRelation 参数只包括 brandId 和 catelogId
 * @return 保存关联关系的结果
 */
@RequestMapping("/save")
public R save(@RequestBody CategoryBrandRelationEntity categoryBrandRelation){
    categoryBrandRelationService.saveDetail(categoryBrandRelation);
    return R.ok();
}
```

CategoryBrandRelationServiceImpl 逻辑实现：

```java
@Override
public void saveDetail(CategoryBrandRelationEntity categoryBrandRelation) {
    Long brandId = categoryBrandRelation.getBrandId();
    Long catelogId = categoryBrandRelation.getCatelogId();
    //查询详细品牌和分类名称填充到该对应关系中
    categoryBrandRelation.setBrandName(brandDao.selectById(brandId).getName());
    categoryBrandRelation.setCatelogName(categoryDao.selectById(catelogId).getName());
    //保存数据信息到中间表
    this.save(categoryBrandRelation);
}
```

2、因此实际上更新品牌时需要更新冗余表信息（品牌分类关联表），使用 mybatis-plus 现有方法实现。

```java
/**
 * BrandController 
 * 根据 id 修改 Brand 品牌，但是需要注意的是还需要更新冗余字段（其他表中的数据）中的数据
 * @param brand 想要修改后的数据
 * @return 请求状态
 */
@RequestMapping("/update")
public R update(@RequestBody BrandEntity brand){
    brandService.updateDetail(brand);
    return R.ok();
}

/**
 * BrandServiceImpl
 * 封装关联表对象用来更新关联表信息
 * @param brand
 */
@Transactional
@Override
public void updateDetail(BrandEntity brand) {
    //需要保证其他表（品牌分类关联表）中的冗余字段的数据一致性
    this.updateById(brand);
    if (!StringUtils.isEmpty(brand.getName())){
        //同步更新其他表(品牌分类关联表)中的数据，里面就两个冗余字段
        categoryBrandRelationService.updateBrand(brand.getBrandId(), brand.getName());
        //TODO:后续可能还需要更新其他表的关联信息
    }
}

/**
 * CategoryBrandRelationServiceImpl
 * 更新冗余表（关联表）的字段
 * @param brandId 品牌id
 * @param brandName 品牌名
 */
@Override
public void updateBrand(Long brandId, String brandName) {
    CategoryBrandRelationEntity relationEntity = new CategoryBrandRelationEntity();
    relationEntity.setBrandId(brandId);
    relationEntity.setBrandName(brandName);
    UpdateWrapper<CategoryBrandRelationEntity> wrapper = new UpdateWrapper<>();
    wrapper.eq("brand_id", brandId);
    this.update(relationEntity, wrapper);
}
```

3、同样的，当更新分类表时，也需要更新冗余表信息（品牌分类关联表），使用自定义的 sql 语句实现。

```java
/**
 * CategoryController
 * 修改分类的相关信息，实际上是利用 catId 来选择分类进行修改，还需要修改荣誉表字段
 * @param category 修改后的分类信息
 * @return 修改请求的结果
 */
@RequestMapping("/update")
public R update(@RequestBody CategoryEntity category){
    categoryService.updateDetail(category);
    return R.ok();
}

/**
 * CategoryServiceImpl
 * 更新时更新冗余表中相同字段
 * @param category 更新数据
 */
@Transactional
@Override
public void updateDetail(CategoryEntity category) {
    this.updateById(category);
    categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());
}

/**
 * CategoryBrandRelationServiceImpl
 * 更新冗余表（关联表）的字段
 * @param catId 分类id
 * @param catName 分类名称
 */
@Override
public void updateCategory(Long catId, String catName) {
    this.baseMapper.updateCategory(catId, catName);
}

// CategoryBrandRelationDao
void updateCategory(Long catId, String catName);

// CategoryBrandRelationDao.xml
<update id="updateCategory">
    update pms_category_brand_relation set catalog_name = #{catName} where catlog_id = #{catId}
</update>
```

### 上传图片OSS

`[问题]` 增加对话框的品牌 logo 地址应该是上传图片，那么文件上传应该怎么实现呢？

原来单体应用下，可以使用服务器本地存储，保存在项目的某个文件夹下，但是在分布式负载均衡条件下，每次路由都不同，那么就需要一个统一的文件存储系统，在本项目中使用`阿里云对象存储 OSS 服务` 这种海量存储的公共存储服务。

- 普通上传方式：用户发送请求到自己的服务器 gateway，而后由后端用账号密码向 OSS 存储系统发送。

- 前端直接上传方式：前端在 JS 内部携带账号密码直接向 OSS 存储系统发送。

- `服务端签名后直传`方式：用户向应用服务器请求上传 Policy(由账号密码生成的防伪签名)，前端拿到 Policy 后直接上传数据到 OSS 存储系统。

![](https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/0747006361/p139016.png)

考虑到后续还有短信服务等等第三方服务，因此抽取出来单独创建一个负责第三方服务的项目 `shop-thirdservice`，添加 web 和 openFeign 的 starter，同时并引入 common 服务（但是`需要排除 mybatis-starter`），引入 cloud 依赖，并将对象存储的相关依赖放入 thirdservice 服务中。

1、在 thirdservice 服务中引入，本来应该导入 `aliyun-sdk-oss` ，但是可以直接使用 SpringCloud Alibaba OSS 解决方案（可以省去自己编写代码的步骤）。

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alicloud-oss</artifactId>
</dependency>
```

2、在阿里云中登录进入控制台，进入 OSS 对象存储，进入 AccessKey 管理，创建`子用户 AccessKey`，创建用户 shop，并对其授权 `AliyunOSSFullAcess` 权限。

同时还需要修改 bucket 支持 CORS 跨域：基础设置 ----> 跨域访问 -----> 创建规则：`来源设置 * ，head 设置 * ，请求方式选择 Post`。

3、创建 bootstrap.yml 配置文件，并配置相关信息，主要配置使用 nacos 进行管理：

1）nacos 创建 thirdservice 命名空间。

2）该命名空间下创建配置文件 oss.yml：配置对应的 OSS 信息，配置子用户的 access-key、secret-key 以及 oss.endpoint 信息。

```yml
spring: 
    cloud: 
        alicloud: 
            access-key: LTAI5tDmdjBFiyUo5L7we1SB
            secret-key: A1lu08kqzQs0qkhY1OVr8uON7iOYpN
            oss: 
                endpoint: oss-cn-nanjing.aliyuncs.com
                bucket: cloud-shop-bucket		# 临时变量
```

3）bootstrap 配置文件内容指明具体的配置中心和配置信息：

```yml
spring:
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        namespace: thirdservice-id
        ext-config[0]:
          data-id: oss.yml
          group: DEFAULT_GROUP
          refresh: true
```

4、创建 application.yml 配置文件，配置注册中心，并在主启动类上添加注解 `@EnableDiscoveryClient` 开启服务注册和发现。

```yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  application:
    name: shop-thirdservice
server:
  port: 30000
```

5、编写 OssController 实现 Oss 服务的签名回传到前端(可以从阿里云官方文档复制)。

```java
@RestController
public class OssController {

    @Autowired
    OSS ossClient;

    @Value("${spring.cloud.alicloud.oss.endpoint}")
    private String endPoint;

    @Value("${spring.cloud.alicloud.oss.bucket}")
    private String bucket;

    @Value("${spring.cloud.alicloud.access-key}")
    private String accessId;

    @RequestMapping("/oss/policy")
    public R policy(){

        //实际的访问地址
        String host = "https://" + bucket + "." + endPoint;
        //设置上传到OSS文件的前缀，此处按日期分配目录
        String date = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
        String dir = date + "/";
        Map<String, String> respMap = null;
        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);
            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes("utf-8");
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);
            respMap = new LinkedHashMap<>();
            respMap.put("accessId", accessId);
            respMap.put("policy", encodedPolicy);
            respMap.put("signature", postSignature);
            respMap.put("dir", dir);
            respMap.put("host", host);
            respMap.put("expire", String.valueOf(expireEndTime / 1000));
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return R.ok().put("data", respMap);
    }
}
```

6、网关配置路由转发规则，放在 admin_route 路由前面：

```yml
- id: thirdservice_route
  uri: lb://shop-thirdservice
  predicates: # 规定前端项目的路由都带有 /api/thirdservice/ 前缀
    - Path=/api/thirdservice/**
  filters:
    - RewritePath=/api/thirdservice/(?<segment>.*),/$\{segment}
```

启动 gateway 和 thirdservice 服务，测试发送请求 `http://localhost:88/api/thirdservice/oss/policy` ：

![](https://pic1.imgdb.cn/item/6346d00b16f2c2beb1217043.png)

7、将网上谷粒商城项目的 upload 文件夹(`代码地址 https://gitee.com/blizzard0409/gulimall`)放入 `/src/components` 目录下，修改每个文件上传组件的 action 地址，检查 policy.js 里面的请求地址是不是配置的网关转发地址即可。

8、修改 brand-add-or-update.vue 文件，修改品牌地址的设置：

```vue
<!-- 3.更换组件 -->
<el-form-item label="品牌logo地址" prop="logo">
    <SingleUpload v-model="dataForm.logo"></SingleUpload>
</el-form-item>
<!-- 1.导入组件 -->
import SingleUpload from "@/components/upload/singleUpload"
<!-- 2.添加组件到 vue -->
components:{
	SingleUpload: SingleUpload
},
```

9、测试发起请求：因此实际上是发送了两个请求，第一个请求是向自己服务器请求签名信息，第二个请求才是根据签名信息向阿里云 OSS 对象存储系统发送存储请求，并实现数据与页面的双向绑定。

![](https://img-blog.csdnimg.cn/img_convert/f584c09f867a09be2b95191d2bc8748f.png)

> 注：如果报错 accessKey 不存在可以检查一下前端的取数据部分的写法问题。

### 前端表单校验

1、表格 logo 能够成功上传，但是此时显示的却是 logo 图片的地址，并不是直接显示图片，因此还需要定义 slot 将表格中的地址转化为图片。并且需要注意的是renren-fast-vue 并没有导入 el-image 组件，因此还需要在 `src/components/element-ui/index.js` 中导入 `Image` 组件（此处我的代码中无法使用 el-image 标签成功全图显示，因此还是使用的原生 image 标签），并 use 引入。

```vue
<el-table-column prop="logo" header-align="center" align="center" label="品牌logo地址">
    <template slot-scope="scope">
		<!-- <el-image style="width: 100px; height: 80px" :src="scope.row.logo" fit="scale-down"></el-image> -->
		<img :src="scope.row.logo" style="width: 100px; height: 80px">
    </template>
</el-table-column>
```

2、表单验证使用 ElementUI 的原生方式，通过 rules 传入校验规则即可，主要是对 firstLetter 和 sort 做特殊校验。

```js
firstLetter: [
    { validator: (rule, value, callback) => {
        if (value === "") callback(new Error('检索首字母必须填写'));
        else if (!/^[a-zA-Z]$/.test(value)){
            callback(new Error('检索首字母必须必须是a-z或A-Z之间'));
        }else {
            callback();
        }
    }, trigger: 'blur' }
],
sort: [
    { validator: (rule, value, callback) => {
        if (value === "") {
            callback(new Error('排序字段必须填写'));
        }else if(!Number.isInteger(value) || value < 0) {
            callback(new Error('排序字段必须是大于等于0的整数'));
        }else {
            callback();
        }
    }, trigger: 'blur' }
]
```

3、后台也是需要进行校验，因为可能攻击者恶意通过直接发送请求的方式 (Postman) 方式来进行发送请求。后台采用 JSR303 来进行数据校验。

1）给 Bean 添加校验注解，并定义自己的校验提示，其他字段暂不说明：

```java
@NotBlank(message = "brandName can‘t be null")
private String name;

@URL(message = "logo need to be a url")
@NotEmpty(message = "logo can't be null")
private String logo;

@Pattern(regexp = "^[a-zA-Z]$", message = "firstLetter must is a-z or A-Z")
@NotEmpty(message = "firstLetter can't be null")
private String firstLetter;

@Min(value = 0, message = "sort must >= 0")
@NotNull(message = "sort can't be null")
private Integer sort;
```

2）给对应的请求 Controller 标上校验注解，并且使用 `BindingResult` 记录校验结果并返回：

```java
/**
 * 新增品牌信息
 * @param brand 需要新增的品牌信息
 * @param result  参数校验结果封装
 * @return 请求结果封装
 */
@RequestMapping("/save")
public R save(@Valid @RequestBody BrandEntity brand, BindingResult result){
    if (result.hasErrors()) {
        Map<String, String> resultMap = new HashMap<>();
        result.getFieldErrors().forEach(item -> {
            //错误提示消息
            String errorMessage = item.getDefaultMessage();
            //获取校验错误的属性名称
            String field = item.getField();
            resultMap.put(field, errorMessage);
        });
        return R.error(400, "提交数据不合法").put("data", resultMap);
    }else {
        brandService.save(brand);
    }
    return R.ok();
}
```

### 统一异常处理

使用上面的 JSR303进行校验已经是比较良好了，但是每个提交的 controller 都需要写重复性的校验结果注入，过于麻烦，因此考虑使用 SpringMVC 提供的统一异常处理方案 `ControllerAdivce` 来实现。

> 针对实际的开发，请求状态码可以作为判断问题的类型，用于快速排错，因此请求状态码十分重要，此处规定错误的请求状态码使用 5 位数字来表示：`10` 表示通用错误（`001 格式校验错误`），`11` 表示商品模块错误，`12` 表示订单模块错误，`13` 表示购物车模块错误，`14` 表示物流模块错误。

1）公共模块 common 编写 exception 包，编写请求状态码枚举类：

```java
@Getter
public enum BizCode {
    UNKNOWN_EXCEPTION(10000, "系统未知异常"),
    VALID_EXCEPTION(10001, "参数格式校验失败");

    private int code;
    private String message;
    BizCode(int code, String message){
        this.code = code;
        this.message = message;
    }
}
```

2）抽取异常处理类 `ShopExceptionControllerAdvice` ，用于全局异常管理。

```java
//集中处理异常，并使用日志记录
@Slf4j
@RestControllerAdvice(basePackages = "com.example.product.controller")
public class ShopExceptionControllerAdvice {

    //指定异常处理器，并同时指定处理哪些种类的异常,此处是处理数据校验异常
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public R handlerValidException(MethodArgumentNotValidException e){
        log.error("数据校验出现，异常类型：{}，异常问题：{}", e.getClass(), e.getMessage());
        BindingResult result = e.getBindingResult();
        Map<String, String> errorMap = new HashMap<>();
        result.getFieldErrors().forEach(item -> {
            //错误提示消息
            String errorMessage = item.getDefaultMessage();
            //获取校验错误的属性名称
            String field = item.getField();
            errorMap.put(field, errorMessage);
        });
        return R.error(BizCode.VALID_EXCEPTION.getCode(), BizCode.VALID_EXCEPTION.getMessage()).put("data", errorMap);
    }

    //整体异常处理逻辑
    @ExceptionHandler(value = Throwable.class)
    public R handlerException(Throwable throwable){
        return R.error(BizCode.UNKNOWN_EXCEPTION.getCode(), BizCode.UNKNOWN_EXCEPTION.getMessage());
    }
}
```

`[拓展用法]`  分组校验（`多场景的复杂校验`）：新增和修改的情况下校验规则可能不同，例如修改时 brandId 不变（必须为 Null 表示不修改），但是新增时 hrandId 就必须填写（必须不为 Null ），那么就可以使用`分组校验` 。（需要注意的是分组校验的 group 属性需要传递接口类）		`[本系统不使用分组校验]`

在 common 项目下新建 valid 包，创建 AddGroup 接口，创建 UpdateGroup 接口，里面不需要写什么具体内容，只是一个标识。而后就可以在注解中添加 `groups` 属性，指明什么情况下需要进行校验，而后使用 `@Validated` 注解取代原来的 `@Valid` 注解，就可以指明校验分组。

> `注意`：使用校验分组后，如果没有标注分组，那么校验注解不起做用。

```java
@TableId
@NotNull(message = "修改时不能指定品牌 id" ,groups = {UpdateGroup.class})
@Null(message = "新增时不能指定品牌 id" ,groups = {AddGroup.class})
private Long brandId;

@NotBlank(message = "brandName can‘t be null", groups = {UpdateGroup.class, AddGroup.class})
private String name;

@RequestMapping("/save")
public R save(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand){
    brandService.save(brand);
    return R.ok();
}
```

`[拓展用法]`  自定义校验：有时候可能正则表达式都无法满足校验的需求，那么就可以使用自定义的校验方式（都位于 common 项目）。

导入对应的 validation 依赖：

```xml
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
```

编写自定义的校验注解，实际就是自定义特别的注解，并于下面的校验器进行关联：

```java
//自定义校验器注解
@Documented
@Constraint(validatedBy = {EnumValueConstraintValidator.class})     //将校验器和校验注解进行关联，可以指定多个类型的校验器
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
public @interface EnumValue {
    String message() default "{com.example.common.EnumValue.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    int[] values() default {};
}
```

编写对应的配置文件：

```properties
com.example.common.EnumValue.message=必须提交指定的值
```

编写自定义的校验器：

```java
//自定义校验器
public class EnumValueConstraintValidator implements ConstraintValidator<EnumValue, Integer> {
    private Set<Integer> valueSet = new HashSet<>();

    //初始化方法
    @Override
    public void initialize(EnumValue constraintAnnotation) {
        //获取注解上标注的可能值，装入 Set 中
        int[] values = constraintAnnotation.values();
        for (int value : values) {
            valueSet.add(value);
        }
    }

    /**
     * 判断是否校验成功
     * @param integer 需要校验的值
     * @param constraintValidatorContext 校验器上下文
     * @return 返回校验结果
     */
    @Override
    public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) {
        return valueSet.contains(integer);
    }
}
```

具体使用在 showStatus 上：

```java
@EnumValue(values = {0, 1})
private Integer showStatus;
```

## 平台属性模块

SPU：标准化产品单元，是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。（类似于 类）

SKU：库存量单位，是指 SPU 的具体的某个商品。（类似于 对象）

> 使用资料里面的 `sys_menus.sql` 文件在 shop-admin 数据库中运行生成所有的菜单目录，实际就是添加记录，sql 语句如下：
>
> ```sql
> insert  into `sys_menu`(`menu_id`,`parent_id`,`name`,`url`,`perms`,`type`,`icon`,`order_num`) values (37,31,'平台属性','','',0,'system',0),(38,37,'属性分组','product/attrgroup','',1,'tubiao',0),(39,37,'规格参数','product/baseattr','',1,'log',0),(40,37,'销售属性','product/saleattr','',1,'zonghe',0),(41,31,'商品维护','product/spu','',0,'zonghe',0),(42,0,'优惠营销','','',0,'mudedi',0),(43,0,'库存系统','','',0,'shouye',0),(44,0,'订单系统','','',0,'config',0),(45,0,'用户系统','','',0,'admin',0),(46,0,'内容管理','','',0,'sousuo',0),(47,42,'优惠券管理','coupon/coupon','',1,'zhedie',0),(48,42,'发放记录','coupon/history','',1,'sql',0),(49,42,'专题活动','coupon/subject','',1,'tixing',0),(50,42,'秒杀活动','coupon/seckill','',1,'daohang',0),(51,42,'积分维护','coupon/bounds','',1,'geren',0),(52,42,'满减折扣','coupon/full','',1,'shoucang',0),(53,43,'仓库维护','ware/wareinfo','',1,'shouye',0),(54,43,'库存工作单','ware/task','',1,'log',0),(55,43,'商品库存','ware/sku','',1,'jiesuo',0),(56,44,'订单查询','order/order','',1,'zhedie',0),(57,44,'退货单处理','order/return','',1,'shanchu',0),(58,44,'等级规则','order/settings','',1,'system',0),(59,44,'支付流水查询','order/payment','',1,'job',0),(60,44,'退款流水查询','order/refund','',1,'mudedi',0),(61,45,'会员列表','member/member','',1,'geren',0),(62,45,'会员等级','member/level','',1,'tubiao',0),(63,45,'积分变化','member/growth','',1,'bianji',0),(64,45,'统计信息','member/statistics','',1,'sql',0),(65,46,'首页推荐','content/index','',1,'shouye',0),(66,46,'分类热门','content/category','',1,'zhedie',0),(67,46,'评论管理','content/comments','',1,'pinglun',0),(68,41,'spu管理','product/spu','',1,'config',0),(69,41,'发布商品','product/spuadd','',1,'bianji',0),(70,43,'采购单维护','','',0,'tubiao',0),(71,70,'采购需求','ware/purchaseitem','',1,'editor',0),(72,70,'采购单','ware/purchase','',1,'menu',0),(73,41,'商品管理','product/manager','',1,'zonghe',0),(74,42,'会员价格','coupon/memberprice','',1,'admin',0),(75,42,'每日秒杀','coupon/seckillsession','',1,'job',0);
> ```

### 属性分组

#### 属性分组查询

![](https://pic1.imgdb.cn/item/634a598516f2c2beb111bec9.png)

> 从此开始，前端代码会缩减显示，基本使用谷粒学院项目资料的前端代码。

product 目录下添加 attrgroup.vue 文件和 attrgroup-add-or-update.vue 组件，表示属性分组。

1、抽取公共部分放于 `modules/common/category.vue` ，里面存放公共使用的分类树形菜单：

```vue
<template>
    <div>
        <el-tree :data="menus" :props="defaultProps" node-key="catId" ref="menuTree"></el-tree>
    </div>
</template>

<script>
export default {
    name: 'RenrenFastVueCategory',
    data() {
        return {
            menus:[],
            defaultProps: {
                children: "children",
                label: "name"
            }
        };
    },
    created() {
        this.getMenus();
    },
    methods: {
        getMenus() {
            this.$http({
                url: this.$http.adornUrl("/product/category/list/tree"),
                method: "get",
            }).then(({ data }) => {
                //将返回数据中的 data 解构出来
                this.menus = data.data;
                console.log("菜单数据：", data);
            });
        },
    },
};
</script>
```

`[知识简要]` 父子组件传递数据问题。

目前需要点击抽取出的公共类中的树形结构，右边表格显示不同的数据（对应分类的属性列表），那么如何实现他们之间数据的传递呢？

子组件给父组件传递数据使用`事件机制` ：子组件给父组件发送一个事件并且携带上数据。（目前此种情况）

```js
// el-tree 绑定 node-click 事件
<el-tree :data="menus" :props="defaultProps" node-key="catId" ref="menuTree" @node-click="nodeClick"></el-tree>

//子组件编写点击函数，并且利用 $emit 向父组件发送事件，事件名 tree-node-click（可以随便取）
nodeClick(data, node, component){
    //向父组件发送事件并携带数据
    this.$emit("tree-node-click", data, node, component);
}

//父组件绑定该事件，并且调用自己的函数进行处理
<categoryTree @tree-node-click="treenodeclick"></categoryTree>
treenodeclick(data, node, component) {
    console.log(`attrgroup 感知到tree的 [${data.name}] 分类被点击`);
},
```

2、后端编写对应的根据分类获取属性分组的请求 handler。

1）AttrGroupController：

```java
/**
 * 根据查询参数查询数据
 * @param params    查询参数（包括分页参数和查询关键字)
 * @param categoryId    三级分类id
 * @return  查询结果数据封装
 */
@RequestMapping("/list/{categoryId}")
public R list(@RequestParam Map<String, Object> params, @PathVariable("categoryId") Long categoryId){
    PageUtils page = attrGroupService.queryPage(params, categoryId);
    return R.ok().put("page", page);
}
```

2）AttrGroupServiceImpl：

```java
@Override
public PageUtils queryPage(Map<String, Object> params, Long categoryId) {
    String searchKey = (String) params.get("key");  //检索关键字用于模糊匹配
    QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<>();
    log.warn("else-categoryId:{}, searchKey:{}", categoryId, searchKey);
    if (!StringUtils.isEmpty(searchKey)){
        wrapper.and((obj) -> {
            // and (attr_group_id = searchKey or attr_group_name like '%searchKey%')
            obj.eq("attr_group_id", searchKey).or().like("attr_group_name", searchKey);
        });
    }
    //非三级分类,就查询所有属性
    if (categoryId == 0) {
        IPage<AttrGroupEntity> page = this.page(new Query<AttrGroupEntity>().getPage(params),wrapper);//封装查询参数
        return new PageUtils(page); //根据返回结果封装成需要的返回值类型
    }else {
        // catelog_id = categoryId
        wrapper.eq("catelog_id", categoryId);
        //封装查询参数，调用分页查询
        IPage<AttrGroupEntity> page = this.page(new Query<AttrGroupEntity>().getPage(params), wrapper);
        return new PageUtils(page); //根据返回结果封装成需要的返回值类型
    }
}
```

3、前端发送请求获取数据：

```js
// 获取数据列表
getDataList() {
    this.dataListLoading = true;
    this.$http({
        url: this.$http.adornUrl(`/product/attrgroup/list/${this.catId}`),
        method: "get",
        params: this.$http.adornParams({
            page: this.pageIndex,
            limit: this.pageSize,
            key: this.dataForm.key
        })
    }).then(({ data }) => {
        if (data && data.code === 0) {
            this.dataList = data.page.list;
            this.totalPage = data.page.totalCount;
        } else {
            this.dataList = [];
            this.totalPage = 0;
        }
        this.dataListLoading = false;
    });
},
    
//感知树节点被点击
treenodeclick(data, node, component) {
    console.log(`attrgroup感知到tree的 [${data.catId}-${data.name}] 分类被点击`);
    if (node.level == 3) {
        this.catId = data.catId;
        this.getDataList(); //重新查询
    }
},
```

#### 属性分组新增

1、新增框的分类选择使用级联选择器的形式，但是需要补充 cascaderProps 属性，并记录 catelogPath，而实际存入的是 catelogId：

> 注：需要注意将对话框在关闭时需要将表单数据清空，不然可能在下一次对话框打开时遗留历史的选择结果。

```js
<el-form-item label="所属分类" prop="catelogId">
    // filterable 表示设置可搜索的
    <el-cascader filterable placeholder="尝试搜索一下" v-model="dataForm.catelogPath" :options="categories" :props="cascaderProps">
    </el-cascader>
</el-form-item>

//data 数据域新增需要的数据定义
cascaderProps:{
    value: "catId",
    label: "name",
    children: "children"
},
dataForm: {
    attrGroupId: 0,
    attrGroupName: '',
    sort: '',
    descript: '',
    icon: '',
    catelogPath: [],   //包含子分类的一个 id 集合
    catelogId: 0,   //真实提交的id数据
},

dataFormSubmit () {
    this.$refs['dataForm'].validate((valid) => {
        if (valid) {
           this.$http({
              //适用于新增的提交，也适用于修改的提交，修改的仅仅是请求路径的区别
              url: this.$http.adornUrl(`/product/attrgroup/${!this.dataForm.attrGroupId ? 'save' : 'update'}`),
              method: 'post',
              //数据封装时并没有什么太大区别，修改时只需要将 attrGroupId 输入框隐藏即可实现固定
              data: this.$http.adornData({
                'attrGroupId': this.dataForm.attrGroupId || undefined,
                'attrGroupName': this.dataForm.attrGroupName,
                'sort': this.dataForm.sort,
                'descript': this.dataForm.descript,
                'icon': this.dataForm.icon,
                'catelogId': this.dataForm.catelogPath[this.dataForm.catelogPath.length - 1],
              })
            }).then(({data}) => {
              if (data && data.code === 0) {
                this.$message({
                  message: '操作成功',
                  type: 'success',
                  duration: 1500,
                  onClose: () => {
                    this.visible = false
                    this.$emit('refreshDataList')
                  }
                })
              } else {
                this.$message.error(data.msg)
              }
         })
   }
})
```

2、后端逻辑实现新增数据记录：

```java
/**
 * 用于前端提交保存新属性分组的记录请求处理
 * @param attrGroup 新的属性分组信息
 * @return 请求结果封装
 */
@RequestMapping("/save")
public R save(@RequestBody AttrGroupEntity attrGroup){
    attrGroupService.save(attrGroup);
    return R.ok();
}
```

#### 属性分组修改

1、数据回显问题：由于前端提交的是单个 id，但是表单是多级选择器，需要的是多级 id，也就是 id 的集合（包括其父 id），那么此时数据回显就会出现问题。

1）AttrGroupEntity 类新增属性 catelogPath 表示分类路径数组。

```java
@TableField(exist = false)
private Long[] catelogPath;
```

2）修改后端的获取信息的逻辑，将 catelogPath 返回给前端。

```java
/**
 * 找到某个 catId 的完整路径：父/子/孙
 * @param catelogId 分类 id
 * @return 完整路径结果
 */
@Override
public Long[] findCatelogPath(Long catelogId) {
    List<Long> path = new ArrayList<>();
    List<Long> parentPath = findParentPath(catelogId, path);
    Collections.reverse(parentPath);
    return parentPath.toArray(new Long[parentPath.size()]);
}

//递归查找某个分类的父id
private List<Long> findParentPath(Long catId, List<Long> path){
    path.add(catId);
    CategoryEntity catById = this.getById(catId);
    if (catById.getParentCid() != 0){
        findParentPath(catById.getParentCid(), path);
    }
    return path;
}
```

3）前端回显表单时将 catelogPath 也进行赋值就能够在前端得到分类信息的回显。

```js
this.dateForm.catelogPath = data.attrGroup.catelogPath;
```

#### 分组属性关联

一个属性分组可以关联多个属性。

1、获取数据分组的关联的所有属性：

```java
/**
 * AttrGroupController
 * 获取当前分组关联的所有属性
 * @param attrgroupId 分组id
 * @return  属性集合
 */
@GetMapping("/{attrgroupId}/attr/relation")
public R attrRelation(@PathVariable("attrgroupId") Long attrgroupId){
    //前端页面只需要展示属性名和可选值，那么久没必要单独封装 vo
    List<AttrEntity> attrEntities = attrService.getRelationAttr(attrgroupId);
    return R.ok().put("data", attrEntities);
}

/**
 * AttrServiceImpl
 * 根据分组id查找关联的规格属性（销售属性没有和分组关联）
 * @param attrgroupId 分组id
 * @return  规格属性集合
 */
@Override
public List<AttrEntity> getRelationAttr(Long attrgroupId) {
    List<AttrEntity> result = new ArrayList<>();
    QueryWrapper<AttrAttrgroupRelationEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("attr_group_id", attrgroupId);
    List<AttrAttrgroupRelationEntity> relationEntities = relationDao.selectList(wrapper);
    if (relationEntities.size() != 0){
        List<Long> attrIds = relationEntities.stream().map((relation) -> {
            return relation.getAttrId();
        }).collect(Collectors.toList());
        result = this.listByIds(attrIds);
    }
    return result;
}
```

2、删除属性和分组关联关系：

1）编写 vo 来封装前端传递过来的数据：

```java
@Data
public class AttrGroupRelationVo {
    private Long attrId;
    private Long attrGroupId;
}
```

2）实际逻辑的实现：

```java
/**
 * AttrGroupController
 * 根据前端传递的关联关系数组批量删除多个关联关系
 * @param relationVos 封装的前端传递过来的关联关系集合
 * @return 删除成功
 */
@PostMapping("/attr/relation/delete")
public R deleteRelation(@RequestBody AttrGroupRelationVo[] relationVos){
    attrService.deleteRelation(relationVos);
    return R.ok();
}

/**
 * AttrServiceImpl
 * 批量删除关联关系(一条语句实现)
 * @param relationVos 关联关系集合
 */
@Override
public void deleteRelation(AttrGroupRelationVo[] relationVos) {
    List<AttrAttrgroupRelationEntity> deleteRelationList = Arrays.asList(relationVos).stream().map((relationVo) -> {
        AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
        BeanUtils.copyProperties(relationVo, relationEntity);
        return relationEntity;
    }).collect(Collectors.toList());
    relationDao.deleteBatchRelation(deleteRelationList);
}

// AttrAttrgroupRelationDao
void deleteBatchRelation(@Param("deleteRelationList") List<AttrAttrgroupRelationEntity> deleteRelationList);

// AttrAttrgroupRelationDao.xml
<delete id="deleteBatchRelation">
    delete from pms_attr_attrgroup_relation where
    <foreach collection="deleteRelationList" item="relation" separator=" OR ">
    	(attr_id=#{relation.attrId} and attr_group_id=#{relation.attrGroupId})
    </foreach>
</delete>
```

3、新增属性关联：需要判断本分类下并且没有被其他分组关联的属性才能够关联。

1）查询属性分组没有关联的其他属性，并进行分页：

```java
/**
 * AttrGroupController
 * 查询当前分组没有关联的所有属性
 * @param params 分页参数封装
 * @param attrgroupId 分组id
 * @return 属性集合
 */
@GetMapping("/{attrgroupId}/noattr/relation")
public R attrNoRelation(@RequestParam Map<String, Object> params,
                        @PathVariable("attrgroupId") Long attrgroupId){
    PageUtils page = attrService.getNoRelationAttr(params, attrgroupId);
    return R.ok().put("page", page);
}

/**
 * AttrServiceImpl
 * 获取某个分组没有关联到的所有属性
 * @param params 分页参数
 * @param attrgroupId   分组id
 * @return 分页属性列表
 */
@Override
public PageUtils getNoRelationAttr(Map<String, Object> params, Long attrgroupId) {
    //1.当前分组只能关联自己所属的分类里面的属性
    AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupId);
    Long catelogId = attrGroupEntity.getCatelogId();
    //2.当前分组只能关联别的分组没有引用的属性
    //2.1 查询当前分类下的所有分组
    QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("catelog_id", catelogId);
    List<AttrGroupEntity> groups = attrGroupDao.selectList(wrapper);
    //2.2 查询这些分组关联的属性
    List<Long> groupIds = groups.stream().map(item -> {
        return item.getAttrGroupId();
    }).collect(Collectors.toList());
    QueryWrapper<AttrAttrgroupRelationEntity> relationWrapper = new QueryWrapper<>();
    relationWrapper.in("attr_group_id", groupIds);
    List<AttrAttrgroupRelationEntity> attrRelationList = relationDao.selectList(relationWrapper);
    List<Long> attrRelationIds = attrRelationList.stream().map(item -> {
        return item.getAttrId();
    }).collect(Collectors.toList());
    //2.3 从所有属性表中剔除这些已经被关联的属性
    QueryWrapper<AttrEntity> attrWrapper = new QueryWrapper<>();
    attrWrapper.eq("catelog_id", catelogId);
    attrWrapper.eq("attr_type", ProductConstant.AttrEnum.ATTR_TYPE_BASE.getValue());    //查询规则属性即可
    if (attrRelationIds != null && attrRelationIds.size() > 0){
        attrWrapper.notIn("attr_id", attrRelationIds);
    }
    //3.用于迷糊查询搜索 key
    String searchKey = (String) params.get("key");
    if (!StringUtils.isEmpty(searchKey)){
        attrWrapper.and((w) -> {
            w.eq("attr_id", searchKey).or().like("attr_name", searchKey);
        });
    }
    IPage<AttrEntity> page = this.page(new Query<AttrEntity>().getPage(params), attrWrapper);
    return new PageUtils(page);
}
```

4、添加属性和分组的关联关系：

```java
/**
 * AttrGroupController
 * 批量保存关联关系
 * @param relationVos 关联关系
 * @return 保存结果
 */
@PostMapping("/attr/relation")
public R addRelation(@RequestBody List<AttrGroupRelationVo> relationVos){
    relationService.saveBatchRelation(relationVos);
    return R.ok();
}

/**
 * AttrAttrgroupRelationServiceImpl
 * 批量保存关联关系
 * @param relationVos 关联关系
 */
@Override
public void saveBatchRelation(List<AttrGroupRelationVo> relationVos) {
    List<AttrAttrgroupRelationEntity> relationEntities = relationVos.stream().map((item) -> {
        AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
        BeanUtils.copyProperties(item, relationEntity);
        return relationEntity;
    }).collect(Collectors.toList());
    this.saveBatch(relationEntities);
}
```

5、需要注意的是，引入关联关系后，当`删除分组时需要将对应的关联关系进行删除`。

```java
/**
 * AttrGroupController
 * 删除属性分组和对应的关联关系
 * @param attrGroupIds 属性分组id集合
 * @return
 */
@RequestMapping("/delete")
public R delete(@RequestBody Long[] attrGroupIds){
    attrGroupService.remoGroupByIds(Arrays.asList(attrGroupIds));
    return R.ok();
}

@Override
public void remoGroupByIds(List<Long> asList) {
    this.removeByIds(asList);
    relationDao.deleteBatchRelationByGroupIds(asList);
}

<delete id="deleteBatchRelationByGroupIds">
    delete from pms_attr_attrgroup_relation where
    <foreach collection="groupIds" item="groupId" separator=" OR ">
    	(attr_group_id=#{groupId})
    </foreach>
</delete>
```

### 规则参数

#### 规则参数新增

使用逆向生成的代码进行保存时会发现能够请求成功，但实际上并不会修改冗余关联表，并且分类属性也保存的并不完整（`需要保存整个分类链`），因此原先的代码并不行，同时添加新字段的方式不使用原先的 `@TableField` 修饰的方式进行添加 attrGroupId 字段，但实际上这并`不规范`。

> 为了根据功能更清晰的划分实体类，将 JavaBean 划分为：
>
> 1）PO：持久对象，就是对应数据表中的记录，例如 BrandEntity。
>
> 2）DO：领域对象，就是从显示对象抽象出来的有形或无形的业务实体。
>
> 3）TO：数据传输对象，不同应用程序之间传输的对象，就是微服务之间传输的对象。
>
> 4）DTO：数据传输对象。
>
> 5）VO：值对象，也叫视图对象，用于`接受请求将请求的数据封装`，往往都不是数据库的完整记录信息，同时也是业务处理对象的封装。

1、在 pojo 包下编写 `/vo/AttrVo` 类：

```java
@Data
public class AttrVo {
    private Long attrId;
    private String attrName;
    private Integer searchType;
    private String icon;
    private Integer valueType;
    private String valueSelect;
    private Integer attrType;
    private Long enable;
    private Long catelogId;
    private Integer showDesc;
    private Long attrGroupId;
}
```

2、AttrController 编写添加方法，同时需要修改关联表数据信息：

```java
/**
 * AttrController
 * 根据前端传递的数据包装成 AttrVo 进行数据库信息的新增
 * @param attr 前端传递的属性数据
 * @return 新增结果
 */
@RequestMapping("/save")
public R save(@RequestBody AttrVo attr){
    attrService.saveAttr(attr);
    return R.ok();
}
/**
 * AttrServiceImpl
 * 进行两个数据表的新增操作
 * @param attr 前端传递的数据信息
 */
@Transactional
@Override
public void saveAttr(AttrVo attr) {
        AttrEntity attrEntity = new AttrEntity();
        // BeanUtils.copyProperties(Object source, Object target)
        BeanUtils.copyProperties(attr, attrEntity);
        this.save(attrEntity);  //1.属性表新增基本数据
    	//有分组信息的属性才能保存到关联表中
        if (attr.getAttrType() == ProductConstant.AttrEnum.ATTR_TYPE_BASE.getValue() && attr.getAttrGroupId() != null){
            //规则属性才需要保存分组关系
            AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
            relationEntity.setAttrGroupId(attr.getAttrGroupId());
            relationEntity.setAttrId(attrEntity.getAttrId());
            log.debug("relationEntity:{}", relationEntity);
            relationDao.insert(relationEntity); //2.关联表新增数据
        }
    }
```

#### 规则参数查询

![](https://pic1.imgdb.cn/item/634a59ba16f2c2beb11222f9.png)

根据前端的表格属性以及接口文档，可以发现需要所属分类和所属分组属性，那么就需要再封装一个 AttrRespVo 对象。

```java
@Data
@ToString
public class AttrRespVo extends AttrVo{
    private String catelogName;     //分类名称（实际是分类路径）
    private String groupName;       //所属分组名称
    
    private Long[] catelogPath;     //分组完整路径（后面数据回显会用，当前用不到）
}
```

编写查询方法，支持根据具体的分类 id 和关键字进行搜索查询。

> 实际上也可以直接联表查询，但是如果数据过多，联表查询就会因为笛卡尔积的原因产生过多的中间数据，非常影响效率。（此处使用查三次的方式）

```java
/**
 * AttrController
 * 查询基本属性列表，并支持根据具体分类id和关键字搜索
 * @param params 分页参数及关键字
 * @param categoryId 分类id
 * @return 分页数据
 */
@RequestMapping("/base/list/{categoryId}")
public R baseAttrList(@RequestParam Map<String, Object> params,
                      @PathVariable("categoryId") Long categoryId){
    PageUtils page = attrService.queryBaseAttrPage(params, categoryId);
    return R.ok().put("page", page);
}

/**
 * AttrServiceImpl
 * @param params 分页参数及关键字
 * @param categoryId 分类id
 * @return 分页信息
 */
@Override
public PageUtils queryBaseAttrPage(Map<String, Object> params, Long categoryId) {
    QueryWrapper<AttrEntity> wrapper = new QueryWrapper<>();
    if (categoryId != 0){   //传入了 categoryId
        wrapper.eq("catelog_id", categoryId);
    }
    String searchKey = (String) params.get("key");
    if (!StringUtils.isEmpty(searchKey)){
        wrapper.and((obj) -> {
            obj.eq("attr_id", searchKey).or().like("attr_name", searchKey);
        });
    }
    IPage<AttrEntity> page = this.page(new Query<AttrEntity>().getPage(params),wrapper);
    PageUtils pageUtils = new PageUtils(page);
    List<AttrEntity> records = page.getRecords();
    List<AttrRespVo> attrRespVoList = records.stream().map((attrEntity -> {
        AttrRespVo attrRespVo = new AttrRespVo();
        BeanUtils.copyProperties(attrEntity, attrRespVo);
        //根据分类 id 获取分类信息
        CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId());
        if (categoryEntity != null) {   //没有指定分类时，分类信息可能并没有
            attrRespVo.setCatelogName(categoryEntity.getName());
        }

        //根据属性 id 获取分组id，进而再获取分组name
        AttrAttrgroupRelationEntity attrRelation =
            relationDao.selectOne(new QueryWrapper<AttrAttrgroupRelationEntity>().eq("attr_id", attrEntity.getAttrId()));
        if (attrRelation != null && attrRelation.getAttrGroupId() != null) {  //没有指定分组时，关联关系可能是空的
            AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrRelation.getAttrGroupId());
            attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
        }

        return attrRespVo;
    })).collect(Collectors.toList());
    //设置最新的结果集为 attrRespVoList
    pageUtils.setList(attrRespVoList);
    return pageUtils;
}
```

#### 规格参数更新

1、数据回显：直接使用逆向生成代码会发现所属分类的完整路径和所属分组并未回显，这也是由于数据封装漏了的原因，需要进行补充。

```java
/**
 * AttrController
 * 用于数据回显的查询请求
 * @param attrId 属性id
 * @return 返回查询到的单条记录的属性信息（应该包括分类和分组信息）
 */
@GetMapping("/info/{attrId}")
public R info(@PathVariable("attrId") Long attrId){
    AttrRespVo attrRespVo = attrService.getInfo(attrId);
    return R.ok().put("attr", attrRespVo);
}

/**
 * AttrServiceImpl
 * 查询前端需要的所有数据，包括分类路径和分组信息
 * @param attrId 属性id
 * @return AttrRespVo 封装信息
 */
@Override
public AttrRespVo getInfo(Long attrId) {
    AttrEntity attrEntity = this.getById(attrId);
    AttrRespVo attrRespVo = new AttrRespVo();
    BeanUtils.copyProperties(attrEntity, attrRespVo);

    //设置分组信息
    AttrAttrgroupRelationEntity attrRelation =
        relationDao.selectOne(new QueryWrapper<AttrAttrgroupRelationEntity>().eq("attr_id", attrId));
    if (attrRelation != null) {  //没有指定分组时，关联关系可能是空的
        attrRespVo.setAttrGroupId(attrRelation.getAttrGroupId());
        AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrRelation.getAttrGroupId());
        if (attrGroupEntity != null) {
            attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
        }
    }

    //设置分类信息
    Long catelogId = attrEntity.getCatelogId();
    CategoryEntity categoryEntity = categoryDao.selectById(catelogId);
    Long[] catelogPath = categoryService.findCatelogPath(attrEntity.getCatelogId());
    attrRespVo.setCatelogPath(catelogPath);
    if (categoryEntity != null) {
        attrRespVo.setCatelogName(categoryEntity.getName());
    }
    return attrRespVo;
}
```

2、数据更新：

```java
/**
 * AttrController
 * 修改属性的提交请求
 * @param attrVo 提交的 attrVo 信息
 * @return 修改请求执行结果
 */
@PostMapping("/update")
public R update(@RequestBody AttrVo attrVo){
    attrService.updateAttr(attrVo);
    return R.ok();
}

/**
 * AttrServiceImpl
 * 进行属性的修改，需要修改中间表的信息
 * @param attrVo 接收到的页面的数据
 */
@Transactional
@Override
public void updateAttr(AttrVo attrVo) {
    AttrEntity attrEntity = new AttrEntity();
    BeanUtils.copyProperties(attrVo, attrEntity);
    this.updateById(attrEntity);    //修改本表的基本数据

    //1.执行更新属性和属性分组中间表的操作
    AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
    relationEntity.setAttrId(attrVo.getAttrId());
    relationEntity.setAttrGroupId(attrVo.getAttrGroupId());
    //还需要判断当前关联表中有没有属性和分组关系
    Integer relationCount = relationDao.selectCount(new QueryWrapper<AttrAttrgroupRelationEntity>().eq("attr_id", attrVo.getAttrId()));
    if (relationCount > 0){
        //如果有执行更新操作
        UpdateWrapper<AttrAttrgroupRelationEntity> updateWrapper = new UpdateWrapper<>();
        updateWrapper.eq("attr_id", attrVo.getAttrId());
        relationDao.update(relationEntity, updateWrapper);
    }else {
        //如果没有则需要执行增加操作
        relationDao.insert(relationEntity);
    }
}
```

### 销售属性

规则参数实际就是和销售属性差不多，只不过是属性类型的区别，规则参数类型为 1，销售属性为 0，同时只有规则参数才有分组信息，销售属性应该是通用的，不用区分属于什么分组。

#### 销售属性查询

根据接口文档，销售属性和规则参数的区别在于请求路径的细微区别，那么就可复用之前的请求，进行简单修改，添加路径参数 `attrType` 来进行区分。

修改原来的 AttrController 的查询方法：

```java
@RequestMapping("/{attrType}/list/{categoryId}")
public R baseAttrList(@RequestParam Map<String, Object> params,
                      @PathVariable("categoryId") Long categoryId,
                      @PathVariable("attrType") String attrType){
    PageUtils page = attrService.queryBaseAttrPage(params, categoryId, attrType);
    return R.ok().put("page", page);
}

@Override
    public PageUtils queryBaseAttrPage(Map<String, Object> params, Long categoryId, String type) {
        QueryWrapper<AttrEntity> wrapper = new QueryWrapper<>();
        wrapper.eq("attr_type", "base".equalsIgnoreCase(type) ? 1 : 0);
        if (categoryId != 0){   //传入了 categoryId
            wrapper.eq("catelog_id", categoryId);
        }
        //原先代码不变......
        //当为规则属性时需要设置属性分组信息，但是如果是销售属性那么就不能设置分组信息
        if ("base".equalsIgnoreCase(type)){
            //根据属性 id 获取分组id，进而再获取分组name
            AttrAttrgroupRelationEntity attrRelation =
                relationDao.selectOne(new QueryWrapper<AttrAttrgroupRelationEntity>().eq("attr_id", attrEntity.getAttrId()));
            if (attrRelation != null) {  //没有指定分组时，关联关系可能是空的
                AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrRelation.getAttrGroupId());
                attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
            }
        }
        //原先代码不变......
    }
```

#### 销售属性新增

由于经常需要进行判断，可以抽取出常量类放到 common 项目中：`constant/ProductConstant` 

```java
public class ProductConstant {
    
    //属性类型的枚举类
    @Getter
    public enum AttrEnum{
        ATTR_TYPE_BASE(1, "规则属性"),ATTR_TYPE_SALE(0, "销售属性");
        private int value;
        private String message;

        AttrEnum(int value, String message){
            this.value = value;
            this.message = message;
        }
    }
}
```

修改原先规则参数的新增方法：

```java
if (attr.getAttrType() == ProductConstant.AttrEnum.ATTR_TYPE_BASE.getValue()){
    //规则属性才需要保存分组关系
    AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
    relationEntity.setAttrGroupId(attr.getAttrGroupId());
    relationEntity.setAttrId(attrEntity.getAttrId());
    log.debug("relationEntity:{}", relationEntity);
    relationDao.insert(relationEntity); //2.关联表新增数据
}
```

相同的，在查询回显数据以及更新属性时都是需要判断属性类型是不是规则属性类型的。

注：销售属性新增都是直接使用逆向生成代码即可。

## 商品维护模块

### 发布商品模块

#### 基本信息录入

1、根据前端请求接口，需要编写会员等级相关接口：

1）查看前置注册中心相关配置是否完整。

2）网关系统配置路由信息：

```yml
- id: member_route
  uri: lb://shop-member
  predicates: # 规定前端项目的路由都带有 /api/thirdservice/ 前缀
    - Path=/api/member/**
  filters:
    - RewritePath=/api/(?<segment>.*),/$\{segment}
```

3）启动 member 项目（里面本身有逆向生成的代码），添加测试的会员等级（前端页面复用谷粒商城）：

![](https://pic1.imgdb.cn/item/634baf9816f2c2beb10afe31.png)

此时说明会员接口就是成功能够使用的。

2、根据前端页面，需要获取分类关联的所有品牌：

1）由于前端只需要品牌id和品牌name，那么可以单独封装一个 BrandVo 。

```java
@Data
public class BrandVo {
    private Long brandId;
    private String brandName;
}
```

2）具体实现请求接口的逻辑：

```java
/**
 * CategoryBrandRelationController
 * 获取某个分类关联的所有品牌
 * @param catId 分类id
 * @return 品牌id和品牌名称的集合:
 */
@GetMapping("/brands/list")
public R catRelationBrandList(@RequestParam("catId") Long catId){
    //其他位置可能还需要用到这个请求的全量数据，因此还是选择查询到所有数据
    List<BrandEntity> brandEntityList = categoryBrandRelationService.getBrandsByCatId(catId);
    List<BrandVo> brandVoList = brandEntityList.stream().map(brandEntity -> {
        BrandVo brandVo = new BrandVo();
        brandVo.setBrandId(brandEntity.getBrandId());
        brandVo.setBrandName(brandEntity.getName());
        return brandVo;
    }).collect(Collectors.toList());
    return R.ok().put("data", brandVoList);
}

/**
 * CategoryBrandRelationServiceImpl
 * 从分类品牌关联表中根据分类查询品牌信息
 * @param catId 分类id
 * @return 品牌信息
 */
@Override
public List<BrandEntity> getBrandsByCatId(Long catId) {
    QueryWrapper<CategoryBrandRelationEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("catelog_id", catId);
    List<CategoryBrandRelationEntity> relationEntities = relationDao.selectList(wrapper);
    //为了方法重用，还是获取一下品牌的详细信息
    List<BrandEntity> brandEntityList = relationEntities.stream().map(relation -> {
        Long brandId = relation.getBrandId();
        BrandEntity brandEntity = brandService.getById(brandId);
        return brandEntity;
    }).collect(Collectors.toList());
    return brandEntityList;
}
```

3）结果就是选择分类后就能够选择下面的品牌下拉框的选择：

![](https://pic1.imgdb.cn/item/634bbbfb16f2c2beb1209439.png)

4）修改前端代码中的图片上传的 action 属性：

```js
action="https://cloud-shop-bucket.oss-cn-nanjing.aliyuncs.com"
//还需要注意下面的data域的赋值操作应该使用 accessId，而非原来提供的 accessid
_self.dataObj.ossaccessKeyId = response.data.accessId;
```

#### 规则参数录入

1、根据前端请求根据分类id查询对应的属性分组以及其属性集合进行显示。

1）由于前端需要将属性分组查询出来后，还需要每个分组下的对应属性，因此封装一个 AttrGroupWithAttrsVo：

```java
@Data
public class AttrGroupWithAttrsVo {
    private Long attrGroupId;
    private String attrGroupName;
    private Integer sort;
    private String descript;
    private String icon;
    private Long catelogId;
    private List<AttrEntity> attrs;
}
```

2）具体的查询逻辑，主要就是先查询分组，再查询分组对应的属性集合。

```java
/**
 * AttrGroupController
 * 根据分类id查询对应的属性分组以及其属性集合。
 * @param categoryId 分类id
 * @return  AttrGroupWithAttrsVo 集合
 */
@GetMapping("/{catelogId}/withattr")
public R getAttrGroupWithAttrs(@PathVariable("catelogId") Long categoryId){
    List<AttrGroupWithAttrsVo> data = attrGroupService.getAttrGroupWithAttrsByCatId(categoryId)
        return R.ok().put("page", data);
}

/**
 * AttrGroupServiceImpl
 * 根据分类id查询AttrGroupWithAttrsVo集合信息
 * @param categoryId 分类id
 */

@Override
public List<AttrGroupWithAttrsVo> getAttrGroupWithAttrsByCatId(Long categoryId) {
    //1.查询分组信息
    QueryWrapper<AttrGroupEntity> AttrGroupWrapper = new QueryWrapper<>();
    AttrGroupWrapper.eq("catelog_id", categoryId);
    List<AttrGroupEntity> attrGroupEntityList = this.list(AttrGroupWrapper);
    //2.对每个分组查询其所有属性并进行封装
    List<AttrGroupWithAttrsVo> attrGroupWithAttrsVos = attrGroupEntityList.stream().map(attrGroup -> {
        AttrGroupWithAttrsVo attrGroupWithAttrsVo = new AttrGroupWithAttrsVo();
        BeanUtils.copyProperties(attrGroup, attrGroupWithAttrsVo);
        //2.1 查询所有属性进行封装，用之前已经有的方法
        List<AttrEntity> attrs = attrService.getRelationAttr(attrGroup.getAttrGroupId());
        attrGroupWithAttrsVo.setAttrs(attrs);
        return attrGroupWithAttrsVo;
    }).collect(Collectors.toList());
    return attrGroupWithAttrsVos;
}
```

前端我拷贝的页面是有问题的，需要修改对应赋值逻辑：`data.page` ，如果请求无问题但是不显示数据可以检查一下。

销售属性是使用直接展示的方式，后端逆向代码已经提供了请求方法。

#### 发布提交实现

新增商品的实现，也就是新增商品后端的逻辑并没有实现，首先肯定是需要对前端整个大表单信息的封装 Vo。

1、前端表单所提交信息的 JavaBean 封装 Vo：

1）表单提交的整体信息的封装 ProductVo 。

```java
//商品保存的Vo
@Data
public class ProductVo {
    private String spuName;
    private String spuDescription;
    private Long catalogId;
    private Long brandId;
    private BigDecimal weight;
    private int publishStatus;
    private List<String> decript;
    private List<String> images;
    private BoundVo bounds;
    private List<BaseAttrsVo> baseAttrs;
    private List<ProductSkuVo> skus;
}
```

2）积分信息的封装 BoundVo 。

```java
@Data
public class BoundVo {
    private BigDecimal buyBounds;
    private BigDecimal growBounds;
}
```

3）商品中所需基本属性信息的封装 BaseAttrsVo 。

```java
@Data
public class BaseAttrsVo {
    private Long attrId;
    private String attrValues;
    private int showDesc;
}
```

4）商品 sku 笛卡尔积组合信息的封装 ProductSkuVo 。

```java
@Data
public class ProductSkuVo {
    private List<ProductAttrVo> attr;
    private String skuName;
    private BigDecimal price;
    private String skuTitle;
    private String skuSubtitle;
    private List<ProductImageVo> images;
    private List<String> descar;
    private int fullCount;
    private BigDecimal discount;
    private int countStatus;
    private BigDecimal fullPrice;
    private BigDecimal reducePrice;
    private int priceStatus;
    private List<MemberPriceVo> memberPrice;
}
```

5）商品属性信息的单独封装 ProductAttrVo 。

```java
@Data
public class ProductAttrVo {
    private Long attrId;
    private String attrName;
    private String attrValue;
}
```

6）商品图片信息的封装 ProductImageVo 。

```java
@Data
public class ProductImageVo {
    private String imgUrl;
    private int defaultImg;
}
```

7）商品会员价格及优惠信息的封装 MemberPriceVo 。

```java
@Data
public class MemberPriceVo {
    private Long id;    //会员等级id
    private String name;    //会员等级名称
    private BigDecimal price;   //会员价格
}
```

2、接受前端提交的数据，进行商品的新增。

1）SpuInfoController 实现业务逻辑：

```java
/**
 * SpuInfoController
 * 新增商品数据，牵扯到多张表的操作修改
 * @param productVo 需要新增的商品信息
 */
@RequestMapping("/save")
public R save(@RequestBody ProductVo productVo){
    spuInfoService.saveProduct(productVo);
    return R.ok();
}
```

2）由于涉及到调用远程服务 coupon 服务进行一些优惠数据的增加，首先肯定需要确保 coupon 的配置（服务注册和发现的配置）。

3）涉及到远程调用，那么又出现了远程调用传递数据的问题，那么此时就需要在 common 模块新建 SpuBoundTo 和 SkuReductionTo 这两个网络传输的 Bean 。

```java
//会员积分信息To
@Data
public class SpuBoundTo {
    private Long spuId;
    private BigDecimal buyBounds;
    private BigDecimal growBounds;
}
```

```java
//优惠信息To
@Data
public class SkuReductionTo {
    private Long skuId;
    private int fullCount;
    private BigDecimal discount;
    private int countStatus;
    private BigDecimal fullPrice;
    private BigDecimal reducePrice;
    private int priceStatus;
    //需要在common也导入MemberPriceVo这个 Bean
    private List<MemberPriceVo> memberPrice;
}
```

3）product 新建 feign 包，编写本地的存根 SpuFeignService 。

```java
@FeignClient("shop-coupon")
public interface CouponFeignService {

    //保存spu的积分信息：需要使用商品服务远程调用member服务修改shop_sms库的sms_spu_bounds表
    @PostMapping("/coupon/spubounds/saveBounds")
    R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo);
    
    //设置sku的优惠、满减等信息：远程调用coupon服务修改shop_sms库的sms_sku_ladder、sms_sku_full_reduction以及sms_member_price表信息
    @PostMapping("/coupon/skufullreduction/saveReductionInfo")
    R saveSkuReduction(@RequestBody SkuReductionTo skuReductionTo);
}
```

4）远端 coupon 服务对调用进行具体的实现：

```java
/**
 * coupon-SpuBoundsController
 * @param spuBounds 接收到的远端传递的积分信息
 * 此处不使用相同 To 进行接收是因为本身 SpuBoundTo 信息在 SpuBoundsEntity 都存在，因此可以用 SpuBoundsEntity直接接收
 */
@PostMapping("/saveBounds")
public R saveSpuBounds(@RequestBody SpuBoundsEntity spuBounds){
    spuBoundsService.save(spuBounds);
    return R.ok();
}

/**
 * coupon-SkuFullReductionController
 * @param skuReductionTo 接收到的远端的优惠信息数据
 */
@RequestMapping("/saveReductionInfo")
public R saveSkuReduction(@RequestBody SkuReductionTo skuReductionTo){
    skuFullReductionService.saveSkuReduction(skuReductionTo);
    return R.ok();
}

/**
 * coupon-SkuFullReductionServiceImpl
 * 实现优惠信息的保存，涉及到多个数据表操作
 * @param skuReductionTo 优惠信息
 */
@Override
public void saveSkuReduction(SkuReductionTo skuReductionTo) {
    //1.保存满减打折和会员价等信息：sms_sku_ladder
    SkuLadderEntity skuLadderEntity = new SkuLadderEntity();
    skuLadderEntity.setSkuId(skuReductionTo.getSkuId());
    skuLadderEntity.setFullCount(skuReductionTo.getFullCount());
    skuLadderEntity.setDiscount(skuReductionTo.getDiscount());
    skuLadderEntity.setAddOther(skuReductionTo.getCountStatus());
    if (skuReductionTo.getFullCount() > 0){
        skuLadderService.save(skuLadderEntity);
    }

    //2.保存满减信息：sms_sku_full_reduction
    SkuFullReductionEntity skuFullReductionEntity = new SkuFullReductionEntity();
    skuFullReductionEntity.setSkuId(skuReductionTo.getSkuId());
    skuFullReductionEntity.setFullPrice(skuReductionTo.getFullPrice());
    skuFullReductionEntity.setReducePrice(skuReductionTo.getReducePrice());
    skuFullReductionEntity.setAddOther(skuReductionTo.getPriceStatus());
    if (skuFullReductionEntity.getFullPrice().compareTo(new BigDecimal("0")) == 1){
        this.save(skuFullReductionEntity);
    }

    //3.保存会员价格：sms_member_price
    List<MemberPriceVo> memberPrices = skuReductionTo.getMemberPrice();
    List<MemberPriceEntity> memberPriceEntityList = memberPrices.stream().map(memberPrice -> {
        MemberPriceEntity memberPriceEntity = new MemberPriceEntity();
        memberPriceEntity.setSkuId(skuReductionTo.getSkuId());
        memberPriceEntity.setMemberLevelId(memberPrice.getId());
        memberPriceEntity.setMemberPrice(memberPrice.getPrice());
        memberPriceEntity.setMemberLevelName(memberPrice.getName());
        memberPriceEntity.setAddOther(1);
        return memberPriceEntity;
    }).filter(item -> {
        return item.getMemberPrice().compareTo(new BigDecimal("0")) == 1;
    }).collect(Collectors.toList());
    memberPriceService.saveBatch(memberPriceEntityList);
}
```

5）product 服务本地 saveProduct 方法实现的逻辑：

```java
/**
 * SpuInfoServiceImpl
 * 对多张表的数据进行新增记录，包括远程调用服务
 * @param productVo 前端传递过来的商品信息
 */
@Transactional
@Override
public void saveProduct(ProductVo productVo) {
    //1.保存spu的基本信息：pms_spu_info
    SpuInfoEntity spuInfoEntity = new SpuInfoEntity();
    BeanUtils.copyProperties(productVo, spuInfoEntity);
    //TODO：时间推荐使用 mp 的 fill = FieldFill.INSERT 方式来设置时间
    spuInfoEntity.setCreateTime(new Date());
    spuInfoEntity.setUpdateTime(new Date());
    this.save(spuInfoEntity);

    //2.保存spu的描述图片：pms_spu_info_desc
    List<String> descriptions = productVo.getDecript();
    SpuInfoDescEntity spuInfoDescEntity = new SpuInfoDescEntity();
    spuInfoDescEntity.setSpuId(spuInfoEntity.getId());
    spuInfoDescEntity.setDecript(String.join(",", descriptions));   //以逗号拼接描述
    spuInfoDescService.save(spuInfoDescEntity);

    //3.保存spu的图片集：pms_spu_images
    List<String> images = productVo.getImages();
    if (images != null && images.size() > 0){
        List<SpuImagesEntity> spuImagesEntityList = images.stream().map(image -> {
            SpuImagesEntity spuImagesEntity = new SpuImagesEntity();
            spuImagesEntity.setSpuId(spuInfoEntity.getId());
            spuImagesEntity.setImgUrl(image);
            return spuImagesEntity;
        }).collect(Collectors.toList());
        spuImagesService.saveBatch(spuImagesEntityList);
    }

    //4.保存spu的规格参数(基本属性):pms_product_attr_value
    List<BaseAttrsVo> baseAttrs = productVo.getBaseAttrs();
    List<ProductAttrValueEntity> attrValueEntityList = baseAttrs.stream().map(baseAttr -> {
        ProductAttrValueEntity attrValueEntity = new ProductAttrValueEntity();
        attrValueEntity.setAttrId(baseAttr.getAttrId());
        //4.1 通过 attrId 获取整个 attr 信息用于下面的封装
        AttrEntity attrEntity = attrService.getById(baseAttr.getAttrId());
        attrValueEntity.setAttrName(attrEntity.getAttrName());
        attrValueEntity.setAttrValue(baseAttr.getAttrValues());
        attrValueEntity.setQuickShow(baseAttr.getShowDesc());   //实际就是对应 quickShow 字段
        attrValueEntity.setSpuId(spuInfoEntity.getId());
        return attrValueEntity;
    }).collect(Collectors.toList());
    attrValueService.saveBatch(attrValueEntityList);

    //5.保存spu的积分信息：需要使用商品服务远程调用member服务修改shop_sms库的sms_spu_bounds表
    BoundVo bounds = productVo.getBounds();
    SpuBoundTo spuBoundTo = new SpuBoundTo();
    BeanUtils.copyProperties(bounds, spuBoundTo);
    spuBoundTo.setSpuId(spuInfoEntity.getId());
    R r = couponFeignService.saveSpuBounds(spuBoundTo);
    if (r.getCode() != 0) {
        log.error("远程调用 coupon 服务保存 spu 积分信息失败!");
    }

    //6.保存spu对应的所有sku信息
    List<ProductSkuVo> skus = productVo.getSkus();
    if (skus != null && skus.size() > 0) {
        skus.forEach(sku -> {
            //6.0 寻找默认图片
            String defaultImage = "";
            for (ProductImageVo image : sku.getImages()){
                if (image.getDefaultImg() == 1) {
                    defaultImage = image.getImgUrl();
                }
            }
            //6.1 设置基本信息进行保存:pms_sku_info
            SkuInfoEntity skuInfoEntity = new SkuInfoEntity();
            BeanUtils.copyProperties(sku, skuInfoEntity);
            skuInfoEntity.setBrandId(spuInfoEntity.getBrandId());
            skuInfoEntity.setCatalogId(spuInfoEntity.getCatalogId());
            skuInfoEntity.setSaleCount(0L);
            skuInfoEntity.setSpuId(spuInfoEntity.getId());
            skuInfoEntity.setSkuDefaultImg(defaultImage);
            skuInfoService.save(skuInfoEntity);

            //6.2 设置sku的图片信息：pms_sku_images
            Long skuId = skuInfoEntity.getSkuId();
            List<ProductImageVo> skuProductImages = sku.getImages();
            List<SkuImagesEntity> skuImages = skuProductImages.stream().map(image -> {
                SkuImagesEntity skuImagesEntity = new SkuImagesEntity();
                skuImagesEntity.setSkuId(skuId);
                skuImagesEntity.setImgUrl(image.getImgUrl());
                skuImagesEntity.setDefaultImg(image.getDefaultImg());
                return skuImagesEntity;
            }).filter(skuImage -> {
                //前端传递值还存在空值的可能性（未选中就是null也会传递到后台），返回true是需要，返回false是过滤掉
                return !StringUtils.isNullOrEmpty(skuImage.getImgUrl());
            }).collect(Collectors.toList());
            skuImagesService.saveBatch(skuImages);

            //6.3 设置sku的销售属性信息：pms_sku_sale_attr_value
            List<ProductAttrVo> attrs = sku.getAttr();
            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = attrs.stream().map(attr -> {
                SkuSaleAttrValueEntity skuSaleAttrValueEntity = new SkuSaleAttrValueEntity();
                skuSaleAttrValueEntity.setSkuId(skuId);
                BeanUtils.copyProperties(attr, skuSaleAttrValueEntity);
                return skuSaleAttrValueEntity;
            }).collect(Collectors.toList());
            skuSaleAttrValueService.saveBatch(skuSaleAttrValueEntities);

            //6.4 设置sku的优惠、满减等信息：远程调用coupon服务修改shop_sms库的sms_sku_ladder、sms_sku_full_reduction以及sms_member_price表信息
            SkuReductionTo skuReductionTo = new SkuReductionTo();
            BeanUtils.copyProperties(sku, skuReductionTo);
            skuReductionTo.setSkuId(skuId);
            if (skuReductionTo.getFullCount() > 0 || skuReductionTo.getFullPrice().compareTo(new BigDecimal("0")) == 1){
                R r1 = couponFeignService.saveSkuReduction(skuReductionTo);
                if (r1.getCode() != 0) {
                    log.error("远程调用 coupon 服务设置sku的优惠和满减等信息失败!");
                }
            }
        });
    }
}
```

此时需要开启的服务已经达到比较多的程度，同时需要设置批量重启方便。

```shell
# 1.设置最大占用内存
VM OPTIONS：-Xmx100m
# 2.新增 Coumpound ，将所需服务加入到这个里面
```

启动所有需要的服务，进行示例商品的添加，为后面的实现做准备案例。

### SPU 管理模块

#### SPU 复杂检索

![](https://pic1.imgdb.cn/item/634cfc7f16f2c2beb1cf0b24.png)

根据前端接口提供后端的逻辑实现：

```java
/**
 * SpuInfoController
 * 根据条件检索 spu 列表
 * @param params 参数（包括需要的条件：品牌、分类等）
 * @return spu列表
 */
@RequestMapping("/list")
public R list(@RequestParam Map<String, Object> params){
    PageUtils page = spuInfoService.queryPageByConditions(params);
    return R.ok().put("page", page);
}

/**
 * SpuInfoServiceImpl
 * 根据条件查询对应的 spu 列表
 * @param params 条件和分页信息
 */
@Override
public PageUtils queryPageByConditions(Map<String, Object> params) {
    QueryWrapper<SpuInfoEntity> wrapper = new QueryWrapper<>();
    //进行条件的封装
    //1.是否选择分类id的判断
    String catelogId = (String) params.get("catelogId");
    if (!StringUtils.isNullOrEmpty(catelogId) && !("0".equalsIgnoreCase(catelogId))){
        wrapper.eq("catalog_id", catelogId);
    }
    //2.是否选择品牌id的判断
    String brandId = (String) params.get("brandId");
    if (!StringUtils.isNullOrEmpty(brandId) && !("0".equalsIgnoreCase(brandId))){
        wrapper.eq("brand_id", brandId);
    }
    //3.是否选择状态的判断：新建、上架、下架
    String status = (String) params.get("status");
    if (!StringUtils.isNullOrEmpty(status)){
        wrapper.eq("publish_status", status);
    }
    //4.关键字填写的判断
    String searchKey = (String) params.get("key");
    if (!StringUtils.isNullOrEmpty(searchKey)){
        wrapper.and((w) -> {
            w.eq("id", searchKey).or().like("spu_name", searchKey);
        });
    }
    IPage<SpuInfoEntity> page = this.page(new Query<SpuInfoEntity>().getPage(params),wrapper);
    return new PageUtils(page);
}
```

发现表格中显示的时间格式出现问题，那么可以添加 Spring 配置对全局时间进行格式化：

```yml
spring: 
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
```

#### SPU 规格维护

SPU 规格维护实际就是对 `规则参数` 进行修改。

> 首先解决原来代码里面 “规格” 点击 400 问题：在路由的 `index.js` 的40行补充路由信息。
>
> ```js
> { path: '/product-attrupdate', component: _import('modules/product/attrupdate'), name: 'attr-update', meta: { title: '规格维护', isTab: true } }
> ```

1、根据 spuId 查询对应的商品规格信息进行回显：

```java
/**
 * AttrController
 * 某个spu基本属性（规则参数）数据的回显
 * @param spuId spuId
 */
@GetMapping("/base/listforspu/{spuId}")
public R baseAttrListForSpu(@PathVariable("spuId") Long spuId){
    List<ProductAttrValueEntity> entities = productAttrValueService.baseAttrListForSpu(spuId);
    return R.ok().put("data", entities);
}

/**
 * ProductAttrValueServiceImpl
 * 数据信息的回显查询
 * @param spuId spuId
 */
@Override
public List<ProductAttrValueEntity> baseAttrListForSpu(Long spuId) {
    QueryWrapper<ProductAttrValueEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("spu_id", spuId);
    return this.baseMapper.selectList(wrapper);
}
```

2、需要注意的是前端页面数据的对应关系，多处出现 `data.data` 取数据，实际上应该使用 `data.page` 来取出数据，前端数据不回显可能需要检查一下。

3、数据完成回显后，就可以开始实现数据的提交确认修改：

```java
/**
 * AttrController
 * 提交某个spu基本属性（规则参数）数据的的修改
 * @param spuId spuId
 */
@PostMapping("/update/{spuId}")
public R update(@PathVariable("spuId") Long spuId,
                @RequestBody List<ProductAttrValueEntity> entities){
    productAttrValueService.updateSpuAttr(spuId, entities);
    return R.ok();
}

/**
 * ProductAttrValueServiceImpl
 * 提交数据的修改
 * @param spuId spuId
 * @param entities 提交后的spu规则参数的数据
 */
@Transactional
@Override
public void updateSpuAttr(Long spuId, List<ProductAttrValueEntity> entities) {
    //1.删除这个 spuId 对应的所有属性
    QueryWrapper<ProductAttrValueEntity> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("spu_id", spuId);
    this.baseMapper.delete(queryWrapper);
    //2.采用新增的方式来重新增加记录
    for (ProductAttrValueEntity entity : entities) {
        entity.setSpuId(spuId);
    }
    this.saveBatch(entities);
}
```

#### SPU 商品上架

当点击上架时，上架状态改为 “上架” 状态，同时商品数据需要在 ES 中进行保存（ES 部分基本使用请看 `全文检索部分`），方便后续的搜索。

1、构建 ES 存储形式索引映射，并创建对应的索引（根据后面的需求回来修改 mapping）：

```json
PUT product
{
  "mappings": {
    "properties": {
      "skuId": {
        "type": "long"
      },
      "spuId": {
        "type": "keyword"
      },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": {
        "type": "keyword"
      },
      "skuImg": {
        "type": "keyword"
      },
      "saleCount": {
        "type": "long"
      },
      "hasStock": {
        "type": "boolean"
      },
      "hotScore": {
        "type": "long"
      },
      "brandId": {
        "type": "long"
      },
      "catalogId": {
        "type": "long"
      },
      "brandName": {
        "type": "keyword"
      },
      "brandImg": {
        "type": "keyword"
      },
      "catalogName": {
        "type": "keyword"
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {
            "type": "long"
          },
          "attrName": {
            "type": "keyword"
          },
          "attrValue": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```

2、product 服务接受请求，实现商品上架功能：

1）SpuInfoController 接收请求：

```java
/**
 * SpuInfoController
 * 上架指定 spuId 的商品
 * @param spuId spuId
 */
@PostMapping("/{spuId}/up")
public R spuUp(@PathVariable("spuId") Long spuId){
    spuInfoService.up(spuId);
    return R.ok();
}
```

2）为了方便在 common 模块创建 `SkuEsModel` 类，用于传递数据。（实际应该在 product 和 search 各创建一份）

```java
@Data
public class SkuEsModel {
    private Long skuId;
    private Long spuId;
    private String skuTitle;
    private BigDecimal skuPrice;
    private String skuImg;
    private Long saleCount;
    private boolean hasStock;
    private Long hotScore;
    private Long brandId;
    private Long catalogId;
    private String brandName;
    private String brandImg;
    private String catalogName;
    private List<Attr> attrs;

    @Data
    public static class Attr{
        private Long attrId;
        private String attrName;
        private String attrValue;
    }
}
```

3）SpuInfoServiceImpl 进行具体的业务逻辑实现：

```java
/**
 * SpuInfoServiceImpl
 * 根据 spuId 上架指定的商品，并存储到 ES 中
 * @param spuId spuId
 */
@Override
public void up(Long spuId) {
    //2.查询当前sku所有的可以用来被检索的规则属性（后续需要进行设置）
    //2.1 获取当前 spuId 所有的 attrValue 信息
    List<ProductAttrValueEntity> attrValueEntityList = attrValueService.baseAttrListForSpu(spuId);
    //2.2 收集规则属性的id用来后续获取具体的 attr
    List<Long> attrValueIds = attrValueEntityList.stream().map(attrValue -> {
        return attrValue.getAttrId();
    }).collect(Collectors.toList());
    //2.3 找出可被检索的id------ 标记1调用
    List<Long> searchIds = attrService.selectSearchAttrValueIds(attrValueIds);
    //2.4 从所有属性id集合中过滤出只属于可被检索的id集合的内容
    Set<Long> searchIdSet = new HashSet<>(searchIds);
    List<SkuEsModel.Attr> attrs = attrValueEntityList.stream().filter(attrValue -> {
        //2.4.1 过滤掉不可检索的 baseAttr
        return searchIdSet.contains(attrValue.getAttrId());
    }).map( attrValue -> {
        //2.4.2 转化为可以放入 skuEsModel 的 attrs 属性对象
        SkuEsModel.Attr attr = new SkuEsModel.Attr();
        BeanUtils.copyProperties(attrValue, attr);
        return attr;
    }).collect(Collectors.toList());

    //根据 spuId 查询所有 sku 信息------------ 标记2调用
    List<SkuInfoEntity> skus = skuInfoService.getSkusBySpuId(spuId);

    //3. 远程调用 ware 服务，返回库存状态查询的批量结果
    List<Long> skuIdList = skus.stream().map(SkuInfoEntity::getSkuId).collect(Collectors.toList());
    Map<Long, Boolean> stockMap = null;
    try {
        // 远程调用 ware 仓储服务------------ 标记3调用
        List<SkuHasStockVo> skusHasStock = wareFeignService.getSkusHasStock(skuIdList);
        stockMap = skusHasStock.stream().collect(Collectors.toMap(SkuHasStockVo::getSkuId, item -> item.isHasStock()));
    }catch (Exception e){
        log.error("库存服务远程调用出现问题：{}", e);
    }

    //1.组装需要的数据
    //1.1 查询当前 supId 对应的所有sku信息和品牌分类等信息
    Map<Long, Boolean> finalStockMap = stockMap;
    List<SkuEsModel> upProducts = skus.stream().map(sku -> {
        SkuEsModel skuEsModel = new SkuEsModel();
        BeanUtils.copyProperties(sku, skuEsModel);
        //处理属性名不相同无法对拷的属性
        skuEsModel.setSkuPrice(sku.getPrice());
        skuEsModel.setSkuImg(sku.getSkuDefaultImg());
        //需要远程调用库存系统，查询是否还有库存来设置 hasStock 属性(每次遍历到都调用不合适，因此得先请求获取再直接在此处插入)
        if (finalStockMap == null){
            skuEsModel.setHasStock(true);
        }else {
            skuEsModel.setHasStock(finalStockMap.get(sku.getSkuId()));
        }
        //TODO:热度评分此处默认设置为 0，但其实也可能刚上架就置顶设置热度
        skuEsModel.setHotScore(0L);

        //查询品牌和分类信息并设置到 skuEsModel
        BrandEntity brand = brandService.getById(skuEsModel.getBrandId());
        skuEsModel.setBrandName(brand.getName());
        skuEsModel.setBrandImg(brand.getLogo());
        skuEsModel.setCatalogName(categoryService.getById(skuEsModel.getCatalogId()).getName());

        //将对应的规则属性并设置到 attrs 属性中(每次遍历到都调用不合适，因此得先请求获取再直接在此处插入)
        skuEsModel.setAttrs(attrs);
        return skuEsModel;
    }).collect(Collectors.toList());

    //远程调用 search 服务，将数据发送到 es 进行保存------------ 标记4调用
    R r = searchFeignService.productStatusUp(upProducts);
    if (r.getCode() == 0){
        //远程调用search上架成功，需要修改当前上架商品spu的状态------------ 标记5调用
        this.baseMapper.updateSpuStatus(spuId, ProductConstant.StatusEnum.SPU_UP.getCode());
    }else{
        //远程调用search上架失败
        //TODO:重复调用,也就是接口幂等性问题？ ====> 重试机制 ？ ====> 利用重试器的重试机制进行重试
        log.error("searchFeignService 远程调用进行上架商品失败!");
    }
}


/**
 * 标记1调用：AttrServiceImpl
 * 在指定的所有属性集合里面找出可检索的属性
 * @param attrValueIds attrValue的id集合
 * @return 可检索属性集合
 */
@Override
public List<Long> selectSearchAttrValueIds(List<Long> attrValueIds) {
    log.info("attrValueIds:{}", attrValueIds);
    return this.baseMapper.selectSearchAttrValueIds(attrValueIds);
}

// 标记1调用 selectSearchAttrValueIds 具体执行的 sql 语句
<select id="selectSearchAttrValueIds" resultType="java.lang.Long">
    select attr_id from pms_attr where attr_id in
    	<foreach collection="attrValueIds" item="id" separator="," open="(" close=")">
    		#{id}
		</foreach>
    and search_type = 1
</select>
            
/**
 * 标记2调用：SkuInfoServiceImpl
 * 根据 spuId 查询所有 sku 信息
 * @param spuId spuId
 */
@Override
public List<SkuInfoEntity> getSkusBySpuId(Long spuId) {
   QueryWrapper<SkuInfoEntity> queryWrapper = new QueryWrapper<>();
   queryWrapper.eq("spu_id", spuId);
   List<SkuInfoEntity> list = this.list(queryWrapper);
   return list;
}

//标记5调用处直接调用 baseMapper 执行sql语句
<update id="updateSpuStatus">
    update pms_spu_info set publish_status=#{code},update_time=NOW() where id = #{spuId}
</update>
```

`[远程调用]` 远程调用 ware 仓储服务（标记3 处调用方法）：

```java
//product 本地存根
@PostMapping("/ware/waresku/hasStock")
List<SkuHasStockVo> getSkusHasStock(@RequestBody List<Long> skuIds);

/**
 * WareSkuController
 * 查询一些商品(sku)是否有库存
 * @return 返回商品库存状态信息
 * 注：此处将 R 加上泛型再来返回实际上更好 R<T> 更有利于数据统一返回
 */
@PostMapping("/hasStock")
public List<SkuHasStockVo> getSkusHasStock(@RequestBody List<Long> skuIds){
    return wareSkuService.getSkusHasStock(skuIds);
}

/**
 * WareSkuServiceImpl
 * 检查商品库存状态
 */
@Override
public List<SkuHasStockVo> getSkusHasStock(List<Long> skuIds) {
    return skuIds.stream().map(skuId -> {
        SkuHasStockVo skuHasStockVo = new SkuHasStockVo();
        //查询当前 sku 的总库存量（多个仓库的库存之和）,单个仓库的库存还得减去锁定的库存量
        Long sumStock = this.baseMapper.getSkuSumStock(skuId);
        skuHasStockVo.setHasStock(sumStock == null ? false : (sumStock > 0));
        skuHasStockVo.setSkuId(skuId);
        return skuHasStockVo;
    }).collect(Collectors.toList());
}
//getSkuSumStock 方法的具体实现sql语句
<select id="getSkuSumStock" resultType="java.lang.Long">
    select sum(stock - stock_locked) from wms_ware_sku where sku_id = #{skuId}
</select>
```

`[远程调用]` 远程调用 search 检索服务（标记4 处调用方法）：

```java
//product 本地存根
@PostMapping("/search/save/product")
R productStatusUp(@RequestBody List<SkuEsModel> skuEsModels);

//search 服务新建商品索引 constant 常量工具类
public class EsConstant {
    public static final String PRODUCT_INDEX = "product";   //SKU商品的索引
}

//新建 ElasticSaveController 类负责检索资源的存储实现
@Slf4j
@RequestMapping("/search/save")
@RestController
public class ElasticSaveController {

    @Autowired
    ProductSaveService productSaveService;

    @PostMapping("/product")
    public R productStatusUp(@RequestBody List<SkuEsModel> skuEsModels){
        boolean upFlag = false;
        try {
            upFlag = productSaveService.productStatusUp(skuEsModels);
        } catch (IOException e) {
            log.error("ElasticSaveController 商品上架错误：{}", e);
            return R.error(BizCode.PRODUCT_UP_EXCEPTION.getCode(), BizCode.PRODUCT_UP_EXCEPTION.getMessage());
        }
        return R.ok();
    }
}

/**
 * ProductSaveServiceImpl
 * 保存 ES 数据
 * @param skuEsModels 数据集合
 */
@Override
public boolean productStatusUp(List<SkuEsModel> skuEsModels) throws IOException {
    //1.给 es 建立索引，操作 kibana 建立好映射关系 mapping（前置操作）
    //2.批量保存数据
    BulkRequest bulkRequest = new BulkRequest();
    for (SkuEsModel skuEsModel : skuEsModels) {
        //构建一个一个的保存请求
        IndexRequest indexRequest = new IndexRequest(EsConstant.PRODUCT_INDEX);
        //指定每个商品的id
        indexRequest.id(skuEsModel.getSkuId().toString());
        //每个商品的真正数据内容 Json 格式
        String s = JSON.toJSONString(skuEsModel);
        indexRequest.source(s, XContentType.JSON);
        //把每一个保存请求都放在bulk请求中
        bulkRequest.add(indexRequest);
    }
    BulkResponse bulk = esClient.bulk(bulkRequest, ElasticSearchConfig.COMMON_OPTIONS);
    //TODO:如果批量插入时出现错误，还需要单独处理（直接不处理？重新上架？记录下来？）
    boolean b = bulk.hasFailures();
    List<String> collect = Arrays.stream(bulk.getItems()).map(item -> {
        return item.getId();
    }).collect(Collectors.toList());
    log.info("商品上架成功:{}", collect);
    return b;
}
```

### 商品管理模块

#### SKU 复杂检索

![](https://pic1.imgdb.cn/item/634cfcd116f2c2beb1cf8a5a.png)

根据前端接口提供后端的逻辑实现：

```java
/**
 * SkuInfoController
 * 根据条件信息查询 sku 信息列表
 * @param params 分页参数和查询条件封装
 */
@RequestMapping("/list")
public R list(@RequestParam Map<String, Object> params){
    PageUtils page = skuInfoService.queryPageByCondition(params);
    return R.ok().put("page", page);
}

/**
 * SkuInfoServiceImpl
 * 根据条件信息查询 sku 信息
 * @param params 分页参数和条件
 */
@Override
public PageUtils queryPageByCondition(Map<String, Object> params) {
    QueryWrapper<SkuInfoEntity> wrapper = new QueryWrapper<>();
    //封装请求条件信息
    //1.设置搜索关键字条件
    String searchKey = (String) params.get("key");
    if (!StringUtils.isNullOrEmpty(searchKey)){
        wrapper.and((w) -> {
            w.eq("sku_id", searchKey).or().like("sku_name", searchKey);
        });
    }
    //2.设置分类id
    String catelogId = (String) params.get("catelogId");
    if (!StringUtils.isNullOrEmpty(catelogId) && !("0".equalsIgnoreCase(catelogId))){
        wrapper.eq("catalog_id", catelogId);
    }
    //3.设置品牌id
    String brandId = (String) params.get("brandId");
    if (!StringUtils.isNullOrEmpty(brandId) && !("0".equalsIgnoreCase(brandId))){
        wrapper.eq("brand_id", brandId);
    }
    //4.设置筛选价格下限
    String min = (String) params.get("min");
    if (!StringUtils.isNullOrEmpty(min) && !("0".equalsIgnoreCase(min))){
        wrapper.ge("price", min);
    }
    //5.设置筛选价格上限
    String max = (String) params.get("max");
    if (!StringUtils.isNullOrEmpty(max)){
            try {
                BigDecimal bigDecimal = new BigDecimal(max);
                if (bigDecimal.compareTo(new BigDecimal("0")) == 1){
                    wrapper.le("price", max);
                }
            } catch (Exception e){
                e.printStackTrace();
            }
        }
    //封装返回信息
    IPage<SkuInfoEntity> page = this.page(new Query<SkuInfoEntity>().getPage(params),wrapper);
    return new PageUtils(page);
}
```
