---
title: 谷粒商城-用户搜索业务处理
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
categories: 
  - 项目练习
description: 
keywords: SpringCloud
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

search 项目引入 Thymeleaf-starter 和 devtools，修改配置文件关闭 Thymeleaf 缓存设置，并将 index 页面放入项目，将静态资源放在 nginx 的 html 下的 search 目录下，再修改页面资源中的路径即可。

1、本地 host 文件夹新增域名设置：

```shell
127.0.0.1 search.moonshop.com
```

2、nginx 配置请求转发规则，修改 server_name 匹配更多规则。

```shell
server_name  *.moonshop.com;
```

3、修改原先的网关路由设置，新增 search.moonshop.com 的转发：

```yml
- id: shop_search_route
  # 根据域名路由到检索服务首页
  uri: lb://shop-search   
  predicates: 
    - Host=search.moonshop.com
```

4、修改前端代码里面的某些跳转逻辑，根据前端跳转的提示发现需要将 search 的 index 页面改名为 `list.html` 。

5、根据检索条件封装一个查询条件的封装类：

```java
//复杂检索条件的封装
@Data
public class SearchParam {
    private String keyword; //全文检索搜索词
    private Long catalog3Id;    //三级分类id
    private String sort;    //排序条件 sort=saleCount_asc/desc
    private Integer hasStock;   //是否有货的选项
    private String skuPrice;    //价格区间
    private List<Long> brandId;     //品牌id集合，支持多选
    private List<String> attrs;     //属性筛选条件

    private Integer pageNum;    //分页参数
}
```

同时还需要封装一个返回结果信息类：

```java
//根据查询参数获取商品查询结果的封装
@Data
public class SearchResult {
    private List<SkuEsModel> products;  //商品信息

    //分页信息
    private Integer pageNum;
    private Long total;
    private Integer totalPages;
    private List<Integer> pageNavs;     //导航页码方便前端的调用

    private List<BrandVo> brands;   //当前查询到的品牌数据信息

    private List<AttrVo> attrs;     //查询结果的涉及到的所有属性

    private List<CatalogVo> catalogs;//查询结果的涉及到的所有分类

    //查询结果中的品牌信息
    @Data
    public static class BrandVo{
        private Long brandId;
        private String brandName;
        private String brandImg;
    }

    //查询结果中的选择的属性信息
    @Data
    public static class AttrVo{
        private Long attrId;
        private String attrName;
        private List<String> attrValue;
    }

    //分类信息
    @Data
    public static class CatalogVo{
        private Long catalogId;
        private String catalogName;
    }
}
```

6、编写对应的跳转请求的处理器：

```java
/**
 * SearchController
 * 自动将页面提交过来的查询请求参数封装成指定对象进行查询
 * @param searchParam 查询参数封装
 * @return 筛选过后的商品信息
 */
@GetMapping("list.html")
public String listPage(SearchParam searchParam, Model model){
    SearchResult searchResult = searchService.search(searchParam);
    model.addAttribute("result", searchParam);
    return "list";
}
```

> 由于之前设置 `product-mapping` 在此处检索时出现问题，因此需要修改原来的 mapping，修改后的文件在笔记原位置，但此处涉及到数据的迁移：
>
> 1）新建 mapping：shop_product 。
>
> 2）迁移原来的 product 中的索引：
>
> ```json
> POST _reindex
> {
>   "source": {
>     "index": "product"
>   },
>   "dest": {
>     "index": "shop_product"
>   }
> }
> ```

7、具体的业务处理逻辑则是构建检索请求进而需要调用 ES 进行查询封装结果数据进行返回。

1）构建检索请求：

```java
//根据检索条件构建检索请求：需要构建 模糊拆线呢、过滤(属性、分类、品牌、价格区间、库存)、排序、分页、高亮设置、聚合分析
private SearchRequest buildSearchRequest(SearchParam searchParam){
    //0.构建 DSL 语句，并将封装好的搜索条件 BoolQueryBuilder 装入
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();

    //1.过滤性查询条件的装入：按照属性、分类、品牌、价格区间、库存等条件装入
    //1.1 构建 must 按照搜索词关键字条件
    if (!StringUtils.isEmpty(searchParam.getKeyword())) {
        boolQuery.must(QueryBuilders.matchQuery("skuTitle", searchParam.getKeyword()));
    }
    //1.2 构建 filter-term 按照三级分类id条件
    if (searchParam.getCatalog3Id() != null) {
        boolQuery.filter(QueryBuilders.termQuery("catalogId", searchParam.getCatalog3Id()));
    }
    //1.3 构建 filter-term 按照品牌id条件
    if (searchParam.getBrandId() != null && searchParam.getBrandId().size() > 0) {
        boolQuery.filter(QueryBuilders.termsQuery("brandId", searchParam.getBrandId()));
    }
    //1.4 构建 filter-term 按照指定属性作为条件进行查询，需要注意其是 nested 嵌入式的方式
    if (searchParam.getAttrs() != null && searchParam.getAttrs().size() > 0) {
        //每种 nested 属性都需要封装一层加入到条件封装中
        for (String attr : searchParam.getAttrs()) {
            //属性格式为 1_5寸:8寸&2_8G:16G 的形式
            BoolQueryBuilder nestedBoolQuery = QueryBuilders.boolQuery();
            String[] s = attr.split("_");
            String attrId = s[0];   //属性id
            String[] attrValues = s[1].split(":");  //属性值的集合
            nestedBoolQuery.must(QueryBuilders.termsQuery("attrs.attrId", attrId));
            nestedBoolQuery.must(QueryBuilders.termsQuery("attrs.attrValue", attrValues));
            //path = attrs,query = nestedBoolQuery, ScoreMode.None 表示不参与评分
            NestedQueryBuilder nestedQuery = QueryBuilders.nestedQuery("attrs", nestedBoolQuery, ScoreMode.None);
            boolQuery.filter(nestedQuery);
        }
    }
    //1.5 构建 filter-term 按照是否有库存作为条件
    if (searchParam.getHasStock() == 1){
        boolQuery.filter(QueryBuilders.termsQuery("hasStock", searchParam.getHasStock() == 1));
    }
    //1.6 构建filter-term 按照价格区间作为条件(格式为 1_500/_500/1_)
    if (!StringUtils.isEmpty(searchParam.getSkuPrice())){
        RangeQueryBuilder skuPriceQueryBuilder = QueryBuilders.rangeQuery("skuPrice");
        String[] s = searchParam.getSkuPrice().split("_");
        if (s.length == 2) skuPriceQueryBuilder.gte(s[0]).lte(s[1]);
        else if (s.length == 1) {
            if (searchParam.getSkuPrice().startsWith("_")) {
                skuPriceQueryBuilder.lte(s[0]);
            }
            if (searchParam.getSkuPrice().endsWith("_")) {
                skuPriceQueryBuilder.gte(s[0]);
            }
        }
        boolQuery.filter(skuPriceQueryBuilder);
    }
    sourceBuilder.query(boolQuery);

    //2.排序、分页、高亮等条件的装入
    //2.1 构建排序条件：排序字段格式是 hotScore_asc/desc
    if (!StringUtils.isEmpty(searchParam.getSort())) {
        String[] s = searchParam.getSort().split("_");
        SortOrder sortOrder = s[1].equalsIgnoreCase("asc") ? SortOrder.ASC : SortOrder.DESC;
        sourceBuilder.sort(s[0], sortOrder);
    }
    //2.2 构建分页条件:from = (pageNum - 1) * pageSize
    sourceBuilder.from((searchParam.getPageNum() - 1) * EsConstant.PRODUCT_pageSize);
    sourceBuilder.size(EsConstant.PRODUCT_pageSize);
    //2.3 构建高亮显示，但前提是使用了查询关键字条件
    if (!StringUtils.isEmpty(searchParam.getKeyword())) {
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field("skuTitle");
        highlightBuilder.preTags("<b style='color: red'>");
        highlightBuilder.postTags("</b>");
        sourceBuilder.highlighter(highlightBuilder);
    }

    //3.聚合分析查询条件的封装
    //3.1 对品牌条件进行聚合
    TermsAggregationBuilder brand_agg = AggregationBuilders.terms("brand_agg");
    brand_agg.field("brandId").size(50);
    //3.1.1 品牌名称的子聚合
    brand_agg.subAggregation(AggregationBuilders.terms("brand_name_agg").field("brandName").size(1));
    //3.1.2 品牌图片的子聚合
    brand_agg.subAggregation(AggregationBuilders.terms("brand_img_agg").field("brandImg").size(1));
    sourceBuilder.aggregation(brand_agg);
    //3.2 对分类条件进行聚合
    TermsAggregationBuilder catalog_agg = AggregationBuilders.terms("catalog_agg").field("catalogId").size(20);
    catalog_agg.subAggregation(AggregationBuilders.terms("catalog_name_agg").field("catalogName").size(1));
    sourceBuilder.aggregation(catalog_agg);
    //3.3 对属性条件进行嵌入式聚合
    NestedAggregationBuilder nestedAgg = AggregationBuilders.nested("attr_agg", "attrs");
    //聚合出当前所有的 attrId
    TermsAggregationBuilder attr_id_agg = AggregationBuilders.terms("attr_id_agg").field("attrs.attrId");
    //聚合分析出当前 attr_id 对应的 attrName
    attr_id_agg.subAggregation(AggregationBuilders.terms("attr_name_agg").field("attrs.attrName").size(1));
    //聚合分析出当前 attr_id 对应的所有的可能值
    attr_id_agg.subAggregation(AggregationBuilders.terms("attr_value_agg").field("attrs.attrValue").size(50));
    nestedAgg.subAggregation(attr_id_agg);
    sourceBuilder.aggregation(nestedAgg);

    System.out.println("构建的查询 DSL 语句为:" + sourceBuilder.toString());
    return new SearchRequest(new String[]{EsConstant.PRODUCT_INDEX}, sourceBuilder);
}
```

2）构建结果封装：

```java
//根据从 es 中查询的数据封装构建结果数据
private SearchResult buildSearchResult(SearchResponse esResponse, SearchParam searchParam) {
    SearchResult searchResult = new SearchResult();
    SearchHits hits = esResponse.getHits();
    //1.商品信息封装到结果集
    List<SkuEsModel> productList = new ArrayList<>();
    if (hits.getHits() != null && hits.getHits().length > 0) {
        for (SearchHit hit : hits.getHits()) {
            SkuEsModel skuEsModel = JSON.parseObject(hit.getSourceAsString(), SkuEsModel.class);
            if (!StringUtils.isEmpty(searchParam.getKeyword())) {
                //如果有设置搜索关键字，那么就需要设置高亮
                HighlightField skuTitle = hit.getHighlightFields().get("skuTitle");
                String highlightString = skuTitle.getFragments()[0].string();
                skuEsModel.setSkuTitle(highlightString);
            }
            productList.add(skuEsModel);
        }
    }
    searchResult.setProducts(productList);

    //2.属性信息封装到结果集
    ParsedNested attr_agg = esResponse.getAggregations().get("attr_agg");
    List<SearchResult.AttrVo> attrVoList = new ArrayList<>();
    ParsedLongTerms attr_id_agg = attr_agg.getAggregations().get("attr_id_agg");
    for (Terms.Bucket bucket : attr_id_agg.getBuckets()) {
        SearchResult.AttrVo attrVo = new SearchResult.AttrVo();
        attrVo.setAttrId(Long.parseLong(bucket.getKeyAsString()));
        //对内部聚合信息进行取值,属性名只有一种可能值，但属性值可能有多个
        ParsedStringTerms attr_name_agg = bucket.getAggregations().get("attr_name_agg");
        attrVo.setAttrName(attr_name_agg.getBuckets().get(0).getKeyAsString());
        ParsedStringTerms attr_value_agg = bucket.getAggregations().get("attr_value_agg");
        List<String> attrValues = attr_value_agg.getBuckets()
            .stream().map(attrValueBucket -> attrValueBucket.getKeyAsString())
            .collect(Collectors.toList());
        attrVo.setAttrValue(attrValues);
        attrVoList.add(attrVo);
    }
    searchResult.setAttrs(attrVoList);

    //3.品牌信息封装到结果集
    ParsedLongTerms brand_agg = esResponse.getAggregations().get("brand_agg");
    List<SearchResult.BrandVo> brandVoList = new ArrayList<>();
    for (Terms.Bucket bucket : brand_agg.getBuckets()) {
        SearchResult.BrandVo brandVo = new SearchResult.BrandVo();
        brandVo.setBrandId(Long.parseLong(bucket.getKeyAsString()));
        //对内部聚合信息进行取值
        ParsedStringTerms brand_name_agg = bucket.getAggregations().get("brand_name_agg");
        brandVo.setBrandName(brand_name_agg.getBuckets().get(0).getKeyAsString());
        ParsedStringTerms brand_img_agg = bucket.getAggregations().get("brand_img_agg");
        brandVo.setBrandImg(brand_img_agg.getBuckets().get(0).getKeyAsString());
        brandVoList.add(brandVo);
    }
    searchResult.setBrands(brandVoList);

    //4.分类信息封装到结果集
    ParsedLongTerms catalog_agg = esResponse.getAggregations().get("catalog_agg");
    List<SearchResult.CatalogVo> catalogVoList = new ArrayList<>();
    for (Terms.Bucket bucket : catalog_agg.getBuckets()) {
        SearchResult.CatalogVo catalogVo = new SearchResult.CatalogVo();
        catalogVo.setCatalogId(Long.parseLong(bucket.getKeyAsString()));
        //从内部的子聚合再获取 catalogName,分类名称就只有一个可能值，因此直接 get(0)
        ParsedStringTerms catalog_name_agg = bucket.getAggregations().get("catalog_name_agg");
        //todo:此处抛出异常是由于 catalog_name_agg 内部没有封装 catalogName

        catalogVo.setCatalogName(catalog_name_agg.getBuckets().get(0).getKeyAsString());
        catalogVoList.add(catalogVo);
    }
    searchResult.setCatalogs(catalogVoList);

    //5.设置分页信息参数
    searchResult.setPageNum(searchParam.getPageNum());
    long total = hits.getTotalHits().value;
    searchResult.setTotal(total);
    int totalPages = (int) total / EsConstant.PRODUCT_pageSize == 0 ? (int) total / EsConstant.PRODUCT_pageSize : (int) total / EsConstant.PRODUCT_pageSize + 1;
    searchResult.setTotalPages(totalPages);
    return searchResult;
}
```

3）接收请求调用方法进行业务处理：

```java
/**
 * ShopSearchServiceImpl
 * 根据检索条件查询页面需要的所有信息
 * @param searchParam   检索条件
 * @return  页面所需信息
 */
@Override
public SearchResult search(SearchParam searchParam) {
    SearchResult result = null;
    //1.动态构建出查询需要的 DSL 语句,实际就是构建 searchRequest 对象
    SearchRequest searchRequest = this.buildSearchRequest(searchParam);
    try {
        //2.执行检索请求，从 ES 中查询数据
        SearchResponse esResponse = esClient.search(searchRequest, ElasticSearchConfig.COMMON_OPTIONS);
        //3.将请求获取的结果进行分析，封装出对应的数据格式
        result = this.buildSearchResult(esResponse, searchParam);
    } catch (IOException e) {
        log.debug("执行 es 请求失败......");
        e.printStackTrace();
    }
    return result;
}
```

8、进行前端页面的渲染（直接可以使用网上的静态资源文件），启动服务测试效果。

> 需要注意的是静态页面中设置 css 样式时需要注意设置 `!important` ，否则可能会被外部引入的 css 文件覆盖掉。
>
> ```html
> <a sort="hotScore" th:attr="style = ${(#strings.isEmpty(p) || #strings.startsWith(p,'hotScore')) ? 'color: #FFF !important; border-		color: #e4393c !important; background: #e4393c !important;':'color: #333 !important; border-color: #CCC !important; background: 	#FFF !important;'}" th:class="${(!#strings.isEmpty(p) && #strings.startsWith(p,'hotScore') && #strings.endsWith(p,'desc')) ? 		'sort_a desc':'sort_a'}">
>     综合排序[[${(!#strings.isEmpty(p) && #strings.startsWith(p,'hotScore') && #strings.endsWith(p,'desc'))?'↓':'↑'}]]
> </a>
> <!-- 销量、价格设置、评论分、上架时间...... -->
> ```

9、后续实际上还有面包屑导航和 URL 请求路径处理相关的问题，此处本人都是通过前端实现 `不做后端逻辑处理` （后端处理参考谷粒商城方案）。





























































































































































































