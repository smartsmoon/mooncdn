---
title: 谷粒商城-用户商城系统首页处理
type:
comments:
tags: 
  - 分布式
  - 微服务
  - SpringBoot
  - Nginx
categories: 
  - 项目练习
description: 
keywords: SpringCloud
cover: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
top_img: https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg
---

## ES 基础

### Docker 安装 Nginx

> nginx 相关文件和之前的文件放一起：`/home/gulishop/nginx` 目录下。

1、在 docker 中随便启动一个 nginx:1.0

```shell
docker run -p 5555:80 --name nginx -d nginx:1.10
```

2、将容器内的配置文件拷贝到当前目录：

```shell
docker container cp nginx:/etc/nginx .
```

3、停止 nginx 并移除掉容器：

```shell
docker stop nginx
docker rm nginx
```

4、将 nginx 改名为 conf 目录，新建 nginx 目录，并将 conf 目录移入 nginx 目录中：

```shell
mv nginx nginx-conf	# 改名
mkdir nginx
mv nginx-conf/ nginx/
cd nginx/
mv nginx-conf/ conf	# 改名
```

5、再运行真正要使用的 nginx：

```shell
docker run -p 5555:80 --name nginx \
-v /home/gulishop/nginx/html:/usr/share/nginx/html \
-v /home/gulishop/nginx/logs:/var/log/nginx \
-v /home/gulishop/nginx/conf:/etc/nginx \
-d nginx:1.10
```

6、访问 IP：5555 来测试 nginx 启动成功。

7、配置分词器扩展词库：

```shell
# 1) 在 html 目录下新建 es 目录
mkdir es
# 2) 创建 fenci.txt 文件，输入 尚硅谷
vim fenci.txt
```

3）本地的 es 配置远程词库地址：位于 `IK/config/IKAnalyzer.cfg.xml` 文件中。

```xml
<!--用户可以在这里配置远程扩展字典 -->
<entry key="remote_ext_dict">http://8.142.92.222:5555/fenci.txt</entry>
```

8、重启 es，测试分词效果。

![](https://pic1.imgdb.cn/item/634f859616f2c2beb10e5243.png)

### Boot  引入 ES 使用 

​	官方建议使用 `9200` 端口给 ES 发送 HTTP 请求，可以使用 JestClient（非官方，不更新）、RestTemplate 和 HttpClient（封装麻烦），因此更推荐使用 ES 官方的操作方式：`Elasticsearch-Rest-Client` 这种方式，封装了 ES 操作，API 层次分明，上手简单。

1、新建 es 服务项目：shop-search，修改 boot 版本，引入 web 模块（es 7 版本不要引入 data-es 模块），后续在 pom 文件中添加相关依赖：

```xml
<properties>
    <java.version>1.8</java.version>
    <!-- 指定 es 版本，覆盖原来 boot 的指定版本 -->
    <elasticsearch.version>7.6.1</elasticsearch.version>
</properties>

<!-- 引入 client 依赖-->
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.6.1</version>
</dependency>
<dependency>
    <groupId>com.example</groupId>
    <artifactId>shop-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

2、远程 nacos 创建命名空间，并配置基本信息 search.yml ：

```yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  application:
    name: shop-search
server:
  port: 12000
```

2、编写一般的配置中心配置文件 bootstrap.yml ：

```yml
spring:
  application:
    name: shop-search
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        namespace: search-id
        group: dev
        ext-config:
          - data-id: search.yml
            group: dev
            refresh: true
```

2、新建 config 目录，编写 ES 的配置文件 ElasticSearchConfig 。

```java
@Configuration
public class ElasticSearchConfig {

    //请求头信息的设置
    public static final RequestOptions COMMON_OPTIONS;
    static {
        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();
        COMMON_OPTIONS = builder.build();
    }

    @Bean
    public RestHighLevelClient esRestClient(){
        RestHighLevelClient client = new RestHighLevelClient(
                //配置多个 ES 时使用
                RestClient.builder(new HttpHost("127.0.0.1", 9200, "http"))
        );
        return client;
    }
}
```

### Java 基本使用 ES

1、测试向 ES 中保存（更新）数据：

```java
@Test
public void indexData() throws IOException {
    IndexRequest indexRequest = new IndexRequest("users");  //新建users索引的请求
    indexRequest.id("1");   //数据的id

    User user = new User();
    user.setUsername("张三");
    user.setAge(18);
    user.setGender("男");

    //把对象转化成json，填入请求之中
    String jsonString = JSON.toJSONString(user);
    indexRequest.source(jsonString, XContentType.JSON);
    IndexResponse index = client.index(indexRequest, ElasticSearchConfig.COMMON_OPTIONS);   //同步执行保存操作
    System.out.println(index);      //提取有用的相应数据
}

@Data
class User{
    private String username;
    private String gender;
    private Integer age;
}
```

结果返回：

```shell
IndexResponse[index=users,type=_doc,id=1,version=1,result=created,seqNo=0,primaryTerm=1,shards={"total":2,"successful":1,"failed":0}]
```

2、测试从文档中检索数据：

> Account 账户数据来源于 `https://gitee.com/xlh_blog/common_content/blob/master/es%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.json` 。

```java
@Data
@ToString
public static class Account {
    private int account_number;
    private int balance;
    private String firstname;
    private String lastname;
    private int age;
    private String gender;
    private String address;
    private String employer;
    private String email;
    private String city;
    private String state;
}

@Test
public void searchData() throws IOException {
    // 1.创建检索请求
    SearchRequest searchRequest = new SearchRequest();
    // 2.指定来源，也就是索引
    searchRequest.indices("bank");
    // 3.指定 DSL 检索条件，利用 SearchSourceBuilder 封装查询的条件
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();

    // 3.1 构造检索条件，示例：查询地址包含 mill 的 address
    /*
         * 基本的用法和 cli 差不多实际上，可以和之前 kibana-cli 上的操作进行类比使用
         * sourceBuilder.query();
         * sourceBuilder.from();
         * sourceBuilder.size();
         * sourceBuilder.aggregation();
         */
    sourceBuilder.query(QueryBuilders.matchQuery("address", "mill"));

    // 3.2 构造聚合条件
    // 3.2.1 按照年龄的值分布进行聚合
    TermsAggregationBuilder ageAgg = AggregationBuilders.terms("ageAgg").field("age").size(10);
    sourceBuilder.aggregation(ageAgg);
    // 3.2.2 计算平均薪资
    AvgAggregationBuilder balanceAvg = AggregationBuilders.avg("balanceAvg").field("balance");
    sourceBuilder.aggregation(balanceAvg);

    System.out.println(sourceBuilder.toString()); //打印最终的构造条件
    searchRequest.source(sourceBuilder);
    //4.执行检索操作语句
    SearchResponse search = client.search(searchRequest, ElasticSearchConfig.COMMON_OPTIONS);
    //5.分析结果
    System.out.println(search.toString());
    //5.1 获取所有查到的数据，并进行封装到具体的 JavaBean 类型
    SearchHit[] searchHits = search.getHits().getHits();
    for (SearchHit hit : searchHits) {
        // 获取一些基本属性属性
        System.out.println(hit.getIndex());
        System.out.println(hit.getType());
        System.out.println(hit.getId());
        String sourceAsString = hit.getSourceAsString();  //把查询出来的结果转化为json字符串
        Account account = JSON.parseObject(sourceAsString, Account.class);
        System.out.println("account" + account);
    }
    //5.2 获取检索的聚合信息
    Aggregations aggregations = search.getAggregations();
    //根据聚合的名字查询，类似于 map 的操作
    Terms ageAgg1 = aggregations.get("ageAgg");
    //getBuckets() 相当于获取所有的分组信息
    for (Terms.Bucket bucket : ageAgg1.getBuckets()) {
        String keyAsString = bucket.getKeyAsString();
        System.out.println("年龄为" + keyAsString + "岁的人有" + bucket.getDocCount() + "人");
    }
    Avg balanceAvg1 = aggregations.get("balanceAvg");
    double value = balanceAvg1.getValue();
    System.out.println("平均薪资为：" + value);
}
```

## 前端商城页面

前端商城页面直接使用`谷粒商城`提供的前端代码页面，但是并不使用前后端分离的开发方式，而是使用 Thymeleaf 页面渲染，将前端页面放在各个模块的内部进行细节渲染，而后使用 nginx 来存放静态资源并转发请求（`动静分离`）

### 商城首页

> 注：前端页面的修改渲染不提供参考，可见 GitHub 代码整体效果。

product 项目引入 Thymeleaf 依赖：

```xml
<!-- Thymeleaf 模板引擎 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
<!-- 热更新： Ctrl + shift + F9 快捷键-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```

修改 Thymeleaf 相关的配置：

```yml
# Thymeleaf 相关配置:关闭缓存，采用默认前缀后缀即可
spring: 
  thymeleaf:
    cache: false
```

controller 包下新建 web 包，创建 IndexController，用于首页跳转使用。

```java
/**
 * IndexController
 * 配置请求转发到首页 index 页面的设置，需要携带一级分类数据
 * @param model MVC提供的页面数据封装
 * @return 转发页面
 */
@GetMapping({"/", "index.html"})
public String indexPage(Model model){
    //1.查出所有的一级分类数据
    List<CategoryEntity> categoryEntities = categoryService.getLevel1Categories();
    model.addAttribute("categories", categoryEntities);

    //MVC会利用视图解析器进行拼串：classpath:/templates/index.html
    return "index";
}

/**
 * CategoryServiceImpl
 * 查询所有的一级分类
 * @return 一级分类集合
 */
@Override
public List<CategoryEntity> getLevel1Categories() {
    QueryWrapper<CategoryEntity> wrapper = new QueryWrapper<>();
    wrapper.eq("parent_cid", 0);
    return this.baseMapper.selectList(wrapper);
}
```

### 子分类页面

点击某个一级分类，应该显示其对应的子分类信息，原本是使用前端 json 文件夹下的 catalog.json 静态资源来 mock 数据，现在需要修改为从数据库查询：

0）修改原来的 `catalogLoader.js` 文件，更换请求信息，并删除原来的 json 静态资源文件夹。

```js
$.getJSON("index/catalog.json",function (data) ......
```

1）根据前端页面需要的信息，编写封装出 Catelog2Vo 和 Catalog3Vo。

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Catelog2Vo {
    private String id;  // 二级分类 id
    private String name; // 二级分类名
    private String catalog1Id;  //一级父分类id
    private List<Catalog3Vo> catalog3List;  // 三级子分类
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Catalog3Vo {
        private String catalog2Id;
        private String id;
        private String name;
    }
}
```

2）具体查询分类信息进行封装前端需要的格式的 Json 数据进行返回：

```java
/**
 * IndexController
 * 查出所有分类并按照前端要求封装数据信息
 * @return 分类菜单数据
 */
@ResponseBody
@GetMapping("/index/json/catalog.json")
public Map<String, List<Catelog2Vo>> getCatalogJson() {
    return categoryService.getCatelogJson();
}

//CategoryServiceImpl 方法实现
@Override
public Map<String, List<Catelog2Vo>> getCatelogJson() {
    //1.查出所有分类
    List<CategoryEntity> level1Categories = this.getLevel1Categories();
    //2.封装数据
    Map<String, List<Catelog2Vo>> cateMenuMap = level1Categories.stream().collect(Collectors.toMap(
        level1Category -> level1Category.getCatId().toString(),
        level1Category -> {
            //2.1 根据每一个一级分类查询对应的二级分类信息数据
            QueryWrapper<CategoryEntity> queryWrapper = new QueryWrapper<CategoryEntity>();
            queryWrapper.eq("parent_cid", level1Category.getCatId());
            List<CategoryEntity> categoryEntities = this.baseMapper.selectList(queryWrapper);
            //2.2 封装上面的二级分类信息到最终结果中
            List<Catelog2Vo> catelog2Vos = null;
            if (categoryEntities != null) {
                catelog2Vos = categoryEntities.stream().map(level2Cate -> {
                    Catelog2Vo catelog2Vo = new Catelog2Vo(
                        level2Cate.getCatId().toString(),
                        level2Cate.getName(),
                        level1Category.getCatId().toString(),
                        null
                    );
                    //2.3 寻找二级分类的三级分类信息进行封装
                    QueryWrapper<CategoryEntity> wrapper = new QueryWrapper<CategoryEntity>();
                    wrapper.eq("parent_cid", level2Cate.getCatId());
                    List<CategoryEntity> level3CateList = this.baseMapper.selectList(queryWrapper);
                    if (level3CateList != null) {
                        List<Catelog2Vo.Catalog3Vo> level3Cats = level3CateList.stream().map(level3Cate -> {
                            Catelog2Vo.Catalog3Vo catalog3Vo = new Catelog2Vo.Catalog3Vo(
                                level2Cate.getCatId().toString(),
                                level3Cate.getCatId().toString(),
                                level3Cate.getName()
                            );
                            return catalog3Vo;
                        }).collect(Collectors.toList());
                        catelog2Vo.setCatalog3List(level3Cats);
                    }
                    return catelog2Vo;
                }).collect(Collectors.toList());
            }
            return catelog2Vos;
        }));
    return cateMenuMap;
}
```

> 注：如果修改过后发现并没有走自己所编写的请求 Url，可以尝试清理当前网站的浏览器缓存：`F12 -> network -> clear browser cache` 。

### 域名访问搭建

采用 `Nginx + Windows` 搭建域名访问环境的实现。

`正向代理`：就是我要访问谷歌，访问不了，然后我请另一台服务器帮我转到谷歌，那么就称这台服务器正向代理了我的请求。

`反向代理`：屏蔽内网服务器的信息，负载均衡访问。

1、修改本机 windows 系统的 host 文件，添加域名映射：

```shell
127.0.0.1       moonshop.com
```

2、本地安装 Nginx（1.22.0 版本），并修改 Nginx 配置文件，让 Nginx 将请求都转发给网关，由网关将请求装发给对应的服务。

1）修改 Nginx 配置文件：

```shell
# 增加上游服务，负载均衡的配置，给下面的请求转发使用
upstream moonshop {
	server 127.0.0.1:88;
}
# 访问 80 的根目录，就会走这个里面的请求
location / {
	# 此处进行具体的代理配置
	proxy_set_header Host $host;
     proxy_pass http://moonshop;
}
```

2）修改网关路由信息，需要注意添加在最末尾，最后拦截使用：

```yml
- id: shop_host_route
  # 路由到商品服务首页
  uri: lb://shop-product   
  predicates: # 根据域名转发
    - Host=**.moonshop.com
```

3、此时访问 `http://mooonshop.com` 发现即可访问到商城首页。

## 服务性能优化

压力测试考察当前软硬件环境下系统所能承受的`最大负荷`并帮助找出系统瓶颈所在，是为了系统在线上的处理能力和稳定性维持在一个标准范围内。使用压力测试，有希望找到很多种测试方法难以发现的问题，有两种错误类型是：`内存泄漏`，`并发和同步问题`。有效的压力测试系统将应用一下这些关键条件：`重复`、`并发`、`量级`、`随机变化`。

本次使用 `Apach Jmeter` 进行压力测试：安装 Jmeter ：`https://mirrors.cloud.tencent.com/apache/jmeter/binaries/` 腾讯镜像地址（官网下载过慢）。

根据压力测试结果 (具体使用方式参考网上博客) 则必须对服务进行优化：

1、中间件越多，性能损失越大，大多损失在网络交互上。

2、业务处理上：

1）数据库 DB： MySQL 优化，例如添加索引等。

2）模板的渲染速度：使用 Thymeleaf 项目上线时需要打开缓存。

3）业务逻辑的优化。

### 动静分离

`动态请求`：自己编写的 controller 请求处理业务逻辑。

`静态请求`：请求 js、css 等静态资源。

将静态资源分离出来放到 nginx 中，nginx 直接返回静态页面，动态请求才转发给后台的 Tomcat 进行处理 ======> `动静分离` 优化非必要请求 。

1、将所有的静态资源 `/static/**` 目录下的文件放在 nginx 安装目录的 html 目录下的 static 目录下。

2、修改原来的前端页面中的 href 属性和 src 属性，都加上 `/static` 路径。

3、增加 nginx 路由配置：

```shell
# 静态资源访问配置
server {
        # 监听 80 端口，访问请求都会被此处拦截
        listen       80;
        server_name  moonshop.com;
		proxy_set_header Host $host;
		
        # 访问 80 的根目录，就会走这个里面的请求
        location / {
			# 先访问静态页面
			root E:/environments/nginx-1.22.0/html/;
			# 如果静态页面不存在，则访问代理服务器。动态加载页面
			if (!-f $request_filename){
				# proxy_set_header Host $host;
				proxy_pass http://moonshop;
				break;
			}
        }
    }
```

此时再启动项目会发现仍然能够获取到指定的页面静态数据，也就成功实现了动静分离。

> windows 如果出现问题可能是后台启动多个 nginx，需要先将所有的 nginx 关闭：
>
> ```
> taskkill /IM nginx.exe /F
> ```

### 优化菜单查询

优化三级分类的获取，主要就是优化数据的查询，将多次数据的查询优化成一次查询数据库，在应用层进行分开保存的方式：

```java
@Override
public Map<String, List<Catelog2Vo>> getCatelogJson() {
    //将数据库的信息一次性查出来
    List<CategoryEntity> selectList = this.baseMapper.selectList(null);
    //1.查出所有一级分类
    List<CategoryEntity> level1Categories = this.getParent_cid(selectList, 0L);
    //2.封装数据
    Map<String, List<Catelog2Vo>> cateMenuMap = level1Categories.stream().collect(Collectors.toMap(
        level1Category -> level1Category.getCatId().toString(),
        level1Category -> {
            //2.1 根据每一个一级分类查询对应的二级分类信息数据,使用 getParent_cid 方法获取数据
            List<CategoryEntity> categoryEntities = this.getParent_cid(selectList, level1Category.getCatId());
            //2.2 封装上面的二级分类信息到最终结果中
            List<Catelog2Vo> catelog2Vos = null;
            if (categoryEntities != null) {
                catelog2Vos = categoryEntities.stream().map(level2Cate -> {
                    Catelog2Vo catelog2Vo = new Catelog2Vo(
                        level2Cate.getCatId().toString(),
                        level2Cate.getName(),
                        level1Category.getCatId().toString(),
                        null
                    );
                    //2.3 寻找二级分类的三级分类信息进行封装,使用 getParent_cid 方法获取数据
                    List<CategoryEntity> level3CateList = this.getParent_cid(selectList, level2Cate.getCatId());
                    if (level3CateList != null) {
                        List<Catelog2Vo.Catalog3Vo> level3Cats = level3CateList.stream().map(level3Cate -> {
                            Catelog2Vo.Catalog3Vo catalog3Vo = new Catelog2Vo.Catalog3Vo(
                                level2Cate.getCatId().toString(),
                                level3Cate.getCatId().toString(),
                                level3Cate.getName()
                            );
                            return catalog3Vo;
                        }).collect(Collectors.toList());
                        catelog2Vo.setCatalog3List(level3Cats);
                    }
                    return catelog2Vo;
                }).collect(Collectors.toList());
            }
            return catelog2Vos;
        }));
    return cateMenuMap;
}

//找出指定 parent_cid 的分类数据
public List<CategoryEntity> getParent_cid(List<CategoryEntity> selectList, Long parent_cid){
    return selectList.stream().filter( item -> item.getParentCid().equals(parent_cid)).collect(Collectors.toList());
}
```

但实际上这些优化都是有限的，因此我们还是需要使用 `缓存 Redis` 来进行优化。
